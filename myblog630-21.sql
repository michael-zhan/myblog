/*
 Navicat Premium Data Transfer

 Source Server         : xx
 Source Server Type    : MySQL
 Source Server Version : 80027
 Source Host           : localhost:3306
 Source Schema         : myblog

 Target Server Type    : MySQL
 Target Server Version : 80027
 File Encoding         : 65001

 Date: 30/06/2022 21:34:21
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for t_attachment
-- ----------------------------
DROP TABLE IF EXISTS `t_attachment`;
CREATE TABLE `t_attachment`  (
  `Id` int NOT NULL AUTO_INCREMENT,
  `attachname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件名称',
  `attachpath` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件路径',
  `attachsmallpath` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件缩略图路径',
  `attachtype` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件种类',
  `attachsuffix` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件后缀',
  `attachsize` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件大小',
  `attachwh` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '附件长宽',
  `attachorigin` int NULL DEFAULT NULL COMMENT '附件来源0：上传，1：外部链接',
  `createtime` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `rawsize` bigint NULL DEFAULT NULL COMMENT '原始大小',
  PRIMARY KEY (`Id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 71 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_attachment
-- ----------------------------
INSERT INTO `t_attachment` VALUES (27, '20200227_203053_480.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203053_480.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203053_480_small.jpg', 'image/jpeg', 'jpg', '22KB', '1006x463', 0, '2020-02-27 20:30:54', 23226);
INSERT INTO `t_attachment` VALUES (28, '20200227_203102_810.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203102_810.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203102_810_small.jpg', 'image/jpeg', 'jpg', '17KB', '485x175', 0, '2020-02-27 20:31:02', 17657);
INSERT INTO `t_attachment` VALUES (29, '20200227_203110_173.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203110_173.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203110_173_small.jpg', 'image/jpeg', 'jpg', '42KB', '665x300', 0, '2020-02-27 20:31:10', 43418);
INSERT INTO `t_attachment` VALUES (30, '20200227_203119_83.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203119_83.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203119_83_small.jpg', 'image/jpeg', 'jpg', '10KB', '554x300', 0, '2020-02-27 20:31:19', 11192);
INSERT INTO `t_attachment` VALUES (31, '20200227_203127_534.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203127_534.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203127_534_small.jpg', 'image/jpeg', 'jpg', '108KB', '550x380', 0, '2020-02-27 20:31:27', 111570);
INSERT INTO `t_attachment` VALUES (32, '20200227_203135_282.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203135_282.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203135_282_small.jpg', 'image/jpeg', 'jpg', '26KB', '522x300', 0, '2020-02-27 20:31:35', 27237);
INSERT INTO `t_attachment` VALUES (33, '20200227_203141_72.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203141_72.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203141_72_small.jpg', 'image/jpeg', 'jpg', '20KB', '605x300', 0, '2020-02-27 20:31:41', 21232);
INSERT INTO `t_attachment` VALUES (34, '20200227_203508_953.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203508_953.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203508_953_small.jpg', 'image/jpeg', 'jpg', '115KB', '760x300', 0, '2020-02-27 20:35:08', 118089);
INSERT INTO `t_attachment` VALUES (35, '20200227_220205_737.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_220205_737.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_220205_737_small.jpg', 'image/jpeg', 'jpg', '244KB', '640x640', 0, '2020-02-27 22:02:05', 250269);
INSERT INTO `t_attachment` VALUES (36, '20200229_170112_244.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_244.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_244_small.png', 'image/png', 'png', '39KB', '1458x902', 0, '2020-02-29 17:01:13', 40017);
INSERT INTO `t_attachment` VALUES (37, '20200229_170112_152.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_152.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_152_small.png', 'image/png', 'png', '92KB', '1343x716', 0, '2020-02-29 17:01:13', 94795);
INSERT INTO `t_attachment` VALUES (38, '20200229_170112_354.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_354.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_354_small.png', 'image/png', 'png', '91KB', '1897x934', 0, '2020-02-29 17:01:13', 93224);
INSERT INTO `t_attachment` VALUES (39, '20200229_170112_996.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_996.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_996_small.png', 'image/png', 'png', '181KB', '1459x851', 0, '2020-02-29 17:01:13', 186038);
INSERT INTO `t_attachment` VALUES (40, '20200229_170112_32.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_32.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_32_small.png', 'image/png', 'png', '95KB', '1448x749', 0, '2020-02-29 17:01:13', 97884);
INSERT INTO `t_attachment` VALUES (41, '20200229_170112_201.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_201.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_201_small.png', 'image/png', 'png', '309KB', '1873x934', 0, '2020-02-29 17:01:13', 316885);
INSERT INTO `t_attachment` VALUES (42, '20200229_170208_205.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_205.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_205_small.png', 'image/png', 'png', '23KB', '178x303', 0, '2020-02-29 17:02:08', 24127);
INSERT INTO `t_attachment` VALUES (43, '20200229_170208_899.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_899.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_899_small.png', 'image/png', 'png', '101KB', '1905x934', 0, '2020-02-29 17:02:09', 104261);
INSERT INTO `t_attachment` VALUES (44, '20200229_170208_313.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_313.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_313_small.png', 'image/png', 'png', '104KB', '1896x935', 0, '2020-02-29 17:02:09', 107129);
INSERT INTO `t_attachment` VALUES (45, '20200229_170208_909.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_909.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_909_small.png', 'image/png', 'png', '210KB', '1888x932', 0, '2020-02-29 17:02:09', 215190);
INSERT INTO `t_attachment` VALUES (46, '20200229_170208_63.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_63.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_63_small.png', 'image/png', 'png', '115KB', '1917x937', 0, '2020-02-29 17:02:09', 117986);
INSERT INTO `t_attachment` VALUES (47, '20200229_170209_797.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_797.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_797_small.png', 'image/png', 'png', '35KB', '457x796', 0, '2020-02-29 17:02:09', 36734);
INSERT INTO `t_attachment` VALUES (48, '20200229_170208_48.gif', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_48.gif', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_48_small.gif', 'image/gif', 'gif', '195KB', '3301x1315', 0, '2020-02-29 17:02:09', 200178);
INSERT INTO `t_attachment` VALUES (49, '20200229_170209_828.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_828.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_828_small.png', 'image/png', 'png', '101KB', '1906x935', 0, '2020-02-29 17:02:10', 103684);
INSERT INTO `t_attachment` VALUES (50, '20200229_171827_770.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_171827_770.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_171827_770_small.jpg', 'image/jpeg', 'jpg', '5KB', '500x315', 0, '2020-02-29 17:18:27', 5821);
INSERT INTO `t_attachment` VALUES (51, '20200229_194319_343.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194319_343.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194319_343_small.png', 'image/png', 'png', '20KB', '700x449', 0, '2020-02-29 19:43:19', 21000);
INSERT INTO `t_attachment` VALUES (52, '20200229_194722_287.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194722_287.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194722_287_small.jpg', 'image/jpeg', 'jpg', '12KB', '500x375', 0, '2020-02-29 19:47:22', 12364);
INSERT INTO `t_attachment` VALUES (53, '20200229_203359_455.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203359_455.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203359_455_small.jpg', 'image/jpeg', 'jpg', '96KB', '2560x1600', 0, '2020-02-29 20:34:01', 99297);
INSERT INTO `t_attachment` VALUES (54, '20200229_203427_769.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203427_769.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203427_769_small.jpg', 'image/jpeg', 'jpg', '96KB', '1920x1080', 0, '2020-02-29 20:34:28', 99254);
INSERT INTO `t_attachment` VALUES (55, '20200229_203427_113.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203427_113.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203427_113_small.jpg', 'image/jpeg', 'jpg', '108KB', '2560x1600', 0, '2020-02-29 20:34:29', 110655);
INSERT INTO `t_attachment` VALUES (56, '20200229_203427_709.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203427_709.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203427_709_small.jpg', 'image/jpeg', 'jpg', '248KB', '2880x1800', 0, '2020-02-29 20:34:29', 254948);
INSERT INTO `t_attachment` VALUES (57, '20200229_203427_187.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203427_187.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_203427_187_small.jpg', 'image/jpeg', 'jpg', '203KB', '2880x1800', 0, '2020-02-29 20:34:29', 208059);
INSERT INTO `t_attachment` VALUES (58, '20200303_153542_462.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200303_153542_462.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200303_153542_462_small.png', 'image/png', 'png', '30KB', '524x161', 0, '2020-03-03 15:35:44', 31173);
INSERT INTO `t_attachment` VALUES (59, '20200314_120536_200.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200_small.jpg', 'image/jpeg', 'jpg', '13KB', '500x369', 0, '2020-03-14 12:05:38', 13995);
INSERT INTO `t_attachment` VALUES (60, '20200316_113814_821.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_113814_821.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_113814_821_small.png', 'image/png', 'png', '5KB', '481x332', 0, '2020-03-16 11:38:14', 6022);
INSERT INTO `t_attachment` VALUES (62, '20200316_115012_220.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_115012_220.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_115012_220_small.png', 'image/png', 'png', '12KB', '531x456', 0, '2020-03-16 11:50:13', 12590);
INSERT INTO `t_attachment` VALUES (63, '20200316_120322_100.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_120322_100.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_120322_100_small.png', 'image/png', 'png', '12KB', '649x425', 0, '2020-03-16 12:03:23', 13242);
INSERT INTO `t_attachment` VALUES (64, '20200317_220428_983.JPG', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_220428_983.JPG', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_220428_983_small.JPG', 'image/jpeg', 'JPG', '19KB', '637x232', 0, '2020-03-17 22:04:29', 20280);
INSERT INTO `t_attachment` VALUES (65, '20200317_221225_32.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_221225_32.jpg', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_221225_32_small.jpg', 'image/jpeg', 'jpg', '11KB', '600x279', 0, '2020-03-17 22:12:26', 12145);
INSERT INTO `t_attachment` VALUES (66, '20200319_132124_604.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200319_132124_604.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200319_132124_604_small.png', 'image/png', 'png', '153KB', '1004x958', 0, '2020-03-19 13:21:25', 157176);
INSERT INTO `t_attachment` VALUES (67, '20200319_134115_224.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200319_134115_224.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200319_134115_224_small.png', 'image/png', 'png', '176KB', '1650x1332', 0, '2020-03-19 13:41:16', 180400);
INSERT INTO `t_attachment` VALUES (68, '20200320_121218_136.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200320_121218_136.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200320_121218_136_small.png', 'image/png', 'png', '10KB', '618x419', 0, '2020-03-20 12:12:19', 10933);
INSERT INTO `t_attachment` VALUES (69, '20200320_121218_354.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200320_121218_354.png', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200320_121218_354_small.png', 'image/png', 'png', '11KB', '712x383', 0, '2020-03-20 12:12:20', 11428);
INSERT INTO `t_attachment` VALUES (70, '20200507_121820_239.jpg', '/upload/2020/5/20200507_121820_239.jpg', '/upload/2020/5/20200507_121820_239_small.jpg', 'image/jpeg', 'jpg', '158KB', '1080x1080', 0, '2020-05-07 12:18:21', 162564);

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '内容',
  `appreciation` bit(1) NOT NULL DEFAULT b'0',
  `commentabled` bit(1) NULL DEFAULT b'0',
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `createTime` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '概要',
  `firstPicture` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '封面图',
  `flag` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `published` int NOT NULL DEFAULT 0,
  `recommend` bit(1) NULL DEFAULT b'0',
  `shareStatement` bit(1) NULL DEFAULT b'0',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `updateTime` datetime NULL DEFAULT NULL COMMENT '修改时间',
  `views` int NULL DEFAULT NULL COMMENT '浏览量',
  `type_id` bigint NULL DEFAULT NULL COMMENT '类型',
  `user_id` bigint NULL DEFAULT NULL COMMENT '作者',
  `comment_count` int NULL DEFAULT 0 COMMENT '评论数',
  `like_count` int NULL DEFAULT 0 COMMENT '点赞数',
  `posttype` int NOT NULL DEFAULT 0 COMMENT '是否转载',
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FK292449gwg5yf7ocdlmswv9w4j`(`type_id`) USING BTREE,
  INDEX `FK8ky5rrsxh01nkhctmo7d48p82`(`user_id`) USING BTREE,
  CONSTRAINT `FK292449gwg5yf7ocdlmswv9w4j` FOREIGN KEY (`type_id`) REFERENCES `t_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK8ky5rrsxh01nkhctmo7d48p82` FOREIGN KEY (`user_id`) REFERENCES `t_user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 71 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES (149, b'0', b'1', '# 前言\r\n\r\n​	在面试中经常被问 TCP 和 UDP 的区别，以及 三次握手 和 四次挥手 。回答的时候参考着网上的内容。TCP 和 UDP 的区别：\r\n\r\n- ​	TCP 是面向连接的，UDP 是面向无连接的\r\n- ​	UDP程序结构较简单\r\n- ​	TCP 是面向字节流的，UDP 是基于数据报的\r\n- ​	TCP 保证数据正确性，UDP 可能丢包\r\n- ​	TCP 保证数据顺序，UDP 不保证\r\n\r\n​	作为一名计算机专业的学生想起面试时经常被问到这方面，既是对知识的好奇，又好奇于面试官的心理。换句话说，我们了解 TCP/UDP、TCP三次握手四次挥手 的现实意义是什么。而查阅网上资料，大部分都是在解释 TCP 和 UDP 是什么。因此，本篇文章主要基于网络资料和自己的理解。\r\n​	要想理解 TCP 和 UDP，我们得先了解它们处于哪一层？\r\n\r\n# 一. 计算机网络体系结构\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203135_282.jpg)\r\n\r\n​	OSI模型(Open System Interconnection Reference Model):即开放式系统互联通信参考模型。由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。\r\n\r\n​	五层协议是教科书版的分法，便于学习和研究而分成五层的。\r\n\r\n​	四层协议是现在实际运用的，就是商业应用的。\r\n\r\n## 1.1 不同层对应的协议\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203110_173.jpg)\r\n\r\n# 二. UDP\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203102_810.jpg)\r\n\r\n\r\n​	上图是 UDP 的包头格式，可以看出 UDP 格式非常简单，只有源端口和目的端口，端口的功能是为了将数据发个某个应用。\r\n\r\n\r\n## 2.1 UDP 的特点\r\n\r\n- ​	不需要大量的数据结构，处理逻辑和包头字段\r\n- ​	不会建立连接，但是会监听这个地方，谁都可以传给它数据，它也可以传给任何人数据，甚至可以同时传给多个人数据。\r\n- ​	不会根据网络的情况进行拥塞控制，无论是否丢包，它该怎么发还是怎么发\r\n\r\n## 2.2 UDP 的主要应用场景\r\n\r\n​	因为 UDP 的这些特点，所以处理的是一些没那么难的功能，并且就算失败的也能接收。基于这些特点的话，UDP 可以使用在如下场景中：\r\n- ​	需要资源少，网络情况稳定的内网，或者对于丢包不敏感的应用，比如 DHCP 就是基于 UDP 协议的。\r\n- ​	不需要一对一沟通，建立连接，而是可以广播的应用。因为它不面向连接，所以可以做到一对多，承担广播或者多播的协议。\r\n- ​	需要处理速度快，可以容忍丢包，但是即使网络拥塞，也毫不退缩，一往无前的时候\r\n## 2.3 UDP 的几个例子\r\n\r\n- ​	直播。直播对实时性的要求比较高，宁可丢包，也不要卡顿的，所以很多直播应用都基于 UDP 实现了自己的视频传输协议\r\n- ​	实时游戏。游戏的特点也是实时性比较高，在这种情况下，采用自定义的可靠的 UDP 协议，自定义重传策略，能够把产生的延迟降到最低，减少网络问题对游戏造成的影响\r\n- ​	物联网。一方面，物联网领域中断资源少，很可能知识个很小的嵌入式系统，而维护 TCP 协议的代价太大了；另一方面，物联网对实时性的要求也特别高。比如 Google 旗下的 Nest 简历 Thread Group，推出了物联网通信协议 Thread，就是基于 UDP 协议的\r\n\r\n# 三. TCP\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203053_480.jpg)\r\n\r\n​	TCP 的包头有哪些内容，分别有什么用：\r\n\r\n- ​	首先，源端口和目标端口是不可少的。\r\n- ​	接下来是包的序号。主要是为了解决乱序问题。不编好号怎么知道哪个先来，哪个后到\r\n- ​	确认序号。发出去的包应该有确认，这样能知道对方是否收到，如果没收到就应该重新发送，这个解决的是不丢包的问题\r\n- ​	状态位。SYN 是发起一个链接，ACK 是回复，RST 是重新连接，FIN 是结束连接。因为 TCP 是面向连接的，因此需要双方维护连接的状态，这些状态位的包会引起双方的状态变更\r\n- ​	窗口大小，TCP 要做流量控制，需要通信双方各声明一个窗口，标识自己当前的处理能力。\r\n\r\n​	通过对 TCP 头的解析，我们知道要掌握 TCP 协议，应该重点关注以下问题：\r\n\r\n- ​	顺序问题\r\n- ​	丢包问题\r\n- ​	连接维护\r\n- ​	流量控制\r\n- ​	拥塞控制\r\n\r\n## 3.1 TCP 的三次握手\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203141_72.jpg)\r\n\r\n​	这是网上经常见到的一张图，刚开始的时候，客户端和服务器都处于 CLOSED 状态，先是服务端主动监听某个端口，处于 LISTEN 状态。然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。服务端接收了发起的连接，返回 SYN，并且 ACK ( 确认 ) 客户端的 SYN，之后处于 SYN-SENT 状态。客户端接收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后就处于 ESTAVLISHED 状态，因为它一发一收成功了。服务端收到 ACK 的 ACK 之后，也处于 ESTABLISHED 状态，因为它也一发一收了\r\n## 3.2 TCP 的四次挥手\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203127_534.jpg)\r\n\r\n​	说完建立连接，再说下断开连接，也被称为四次挥手，可以简单理解如下：\r\n- ​	第一次挥手：双方数据传输的差不多，此时客户端也已经结束传输了，接下来要断开通信连接，所以告诉服务端客户端数据传输完毕（FIN），此时客户端进入等待结束连接的状态。\r\n- ​	第二次挥手：，服务端知道客户端数据传输完毕（ACK），但服务端可能还有数据未传输，接着继续传输。\r\n- ​	第三次挥手：此时客户端接收数据继续处于等待结束的状态，然后服务器端也传输完毕，自身此时处于等待关闭连接的状态，并对告诉客户端，自己的数据也传输完毕（FIN）”\r\n- ​	第四次挥手：客户端知道服务端也传输完毕，也要告诉服务端一声（ACK），因为连接和断开要双方都按下关闭操作才能断开，客户端同时又为自己定义一个定时器，因为不知道刚才说的这句话能不能准确到达服务端（网络不稳定或者其他因素引起的网络原因），默认时间定为两个通信的最大时间之和，超出这个时间就默认服务器端已经接收到了自己的确认信息，此时客户端就关闭自身连接，服务器端一旦接收到客户端发来的确定通知就立刻关闭服务器端的连接\r\n\r\n​	到此为止双方整个通信过程就此终结。但断开链接不一定就是客户端，谁都可以先发起断开指令，另外客户端和服务端是没有固定标准的，谁先发起请求谁就是客户端。\r\n## 3.3 TCP 累计确认\r\n\r\n​	首先为了保证顺序性，每个包都有一个 ID。在建立连接的时候会商定起始 ID 是什么，然后按照 ID 一个个发送，为了保证不丢包，需要对发送的包都要进行应答，当然，这个应答不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式成为累计应答或累计确认。\r\n\r\n​	为了记录所有发送的包和接收的包，TCP 需要发送端和接收端分别来缓存这些记录，发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分\r\n\r\n- ​	发送并且确认的\r\n- ​	发送尚未确认的\r\n- ​	没有发送等待发送的\r\n- ​	没有发送并且暂时不会发送的\r\n\r\n​	这里的第三部分和第四部分就属于流量控制的内容\r\n\r\n​	在 TCP 里，接收端会给发送端报一个窗口大小，叫 Advertised window。这个窗口应该等于上面的第二部分加上第三部分，超过这个窗口，接收端做不过来，就不能发送了，于是，发送端要保持下面的数据结构：\r\n​	对于接收端来讲，它的缓存里面的内容要简单一些\r\n\r\n- ​	接收并且确认过的\r\n- ​	还没接收，但是马上就能接收的\r\n- ​	还没接收，但也无法接收的\r\n\r\n## 3.4 TCP 顺序问题和丢包问题\r\n\r\n​	举个例子：在发送端，1、2、3 已发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。\r\n\r\n​	在接收端来看，1、2、3、4、5 是已经完成 ACK 但是还没读取的；6、7 是等待接收的；8、9 是已经接收还没有 ACK 的。\r\n\r\n​	发送端和接收端当前的状态如下：\r\n\r\n- ​	1、2、3 没有问题，双方达成了一致\r\n\r\n- ​	4、5 接收方说 ACK 了，但是发送方还没收到\r\n\r\n- ​	6、7、8、9 肯定都发了，但是 8、9 已经到了，6、7 没到，出现了乱序，缓存着但是没办法 ACK。\r\n\r\n​	根据这个例子可以知道顺序问题和丢包问题都有可能存在，所以我们先来看确认与重传机制。\r\n\r\n​	假设 4 的确认收到了，5 的 ACK 丢了，6、7 的数据包丢了，该怎么办？\r\n\r\n​	一种方法是超时重试，即对每一个发送了但是没有 ACK 的包设定一个定时器，超过了一定的事件就重新尝试。这个时间必须大于往返时间，但也不宜过长，否则超时时间变长，访问就变慢了。\r\n​	如果过一段时间，5、6、7 都超时了就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，TCP 的策略是超时间隔加倍。每当遇到一次超时重传的时候，都会讲下一次超时时间间隔设为先前值的两倍。\r\n\r\n​	超时重传的机制是超时周期可能相对较长，是否有更快的方式呢？\r\n\r\n​	有一个快速重传的机制，即当接收方接收到一个序号大于期望的报文段时，就检测到了数据流之间的间隔，于是发送三个冗余的 ACK，客户端接收到之后，知道数据报丢失，于是重传丢失的报文段。\r\n​	例如，接收方发现 6、8、9 都接收了，但是 7 没来，所以肯定丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端接收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。\r\n\r\n## 3.4 TCP 流量控制的问题\r\n\r\n​	在流量控制的机制里面，在对于包的确认中，会携带一个窗口的大小\r\n\r\n​	简单的说一下就是接收端在发送 ACK 的时候会带上缓冲区的窗口大小，但是一般在窗口达到一定大小才会更新窗口，因为每次都更新的话，刚空下来就又被填满了\r\n\r\n## 3.5 TCP 拥塞控制的问题\r\n\r\n​	也是通过窗口的大小来控制的，但是检测网络满不满是个挺难的事情，所以 TCP 发送包经常被比喻成往谁管理灌水，所以拥塞控制就是在不堵塞，不丢包的情况下尽可能的发挥带宽。\r\n\r\n​	水管有粗细，网络有带宽，即每秒钟能发送多少数据；水管有长度，端到端有时延。理想状态下，水管里面的水 = 水管粗细 * 水管长度。对于网络上，通道的容量 = 带宽 * 往返时延。\r\n\r\n​	如果我们设置发送窗口，使得发送但未确认的包为通道的容量，就能撑满整个管道。\r\n\r\n\r\n\r\n​	假设往返时间为 8 秒，去 4 秒，回 4 秒，每秒发送一个包，已经过去了 8 秒，则 8 个包都发出去了，其中前四个已经到达接收端，但是 ACK 还没返回，不能算发送成功，5-8 后四个包还在路上，还没被接收，这个时候，管道正好撑满，在发送端，已发送未确认的 8 个包，正好等于带宽，也即每秒发送一个包，也即每秒发送一个包，乘以来回时间 8 秒。\r\n\r\n​	如果在这个基础上调大窗口，使得单位时间可以发送更多的包，那么会出现接收端处理不过来，多出来的包会被丢弃，这个时候，我们可以增加一个缓存，但是缓存里面的包 4 秒内肯定达不到接收端课，它的缺点会增加时延，如果时延达到一定程度就会超时重传\r\n\r\n​	TCP 拥塞控制主要来避免两种现象，包丢失和超时重传，一旦出现了这些现象说明发送的太快了，要慢一点。\r\n\r\n​	具体的方法就是发送端慢启动，比如倒水，刚开始倒的很慢，渐渐变快。然后设置一个阈值，当超过这个值的时候就要慢下来\r\n\r\n​	慢下来还是在增长，这时候就可能水满则溢，出现拥塞，需要降低倒水的速度，等水慢慢渗下去。\r\n\r\n​	拥塞的一种表现是丢包，需要超时重传，这个时候，采用快速重传算法，将当前速度变为一半。所以速度还是在比较高的值，也没有一夜回到解放前。\r\n\r\n# 四. 总结\r\n## 4.1 TCP 和 UDP 的区别\r\n\r\n- ​	TCP 是面向连接的，UDP 是面向无连接的\r\n- ​	UDP程序结构较简单\r\n- ​	- ​	TCP 是面向字节流的，UDP 是基于数据报的\r\n- ​	TCP 保证数据正确性，UDP 可能丢包\r\n- ​	TCP 保证数据顺序，UDP 不保证\r\n\r\n## 4.2 什么是面向连接，什么是面向无连接\r\n\r\n- ​	在互通之前，面向连接的协议会先建立连接，如 TCP 有三次握手，而 UDP 不会\r\n\r\n## 4.3 TCP 为什么是可靠连接\r\n\r\n- ​	通过 TCP 连接传输的数据无差错，不丢失，不重复，且按顺序到达。\r\n- ​	TCP 报文头里面的序号能使 TCP 的数据按序到达\r\n- ​	报文头里面的确认序号能保证不丢包，累计确认及超时重传机制\r\n- ​	TCP 拥有流量控制及拥塞控制的机制\r\n- ​	 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的\r\n- ​	拥塞控制时通过拥塞窗口来解决的\r\n\r\n​	 TCP/IP并不是一个完美的协议,但是它却能在那么多的网络协议中脱颖而出,至少表明它是出色的,至少在目前还没有任何协议可以取代它。\r\n\r\n​	 文章主要内容摘自https://www.cnblogs.com/reload-sun/p/12216936.html', '2020-02-24 21:36:13', '在面试中经常被问 TCP 和 UDP 的区别，以及 三次握手 和 四次挥手 。回答的时候参考着网上的内容。作为一名计算机专业的学生想起面试时经常被问到这方面，既是对知识的好奇，又好奇于面试官的心理。换句话说', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203119_83.jpg', '转载', 0, b'1', b'0', 'TCP和UDP总结', '2020-03-12 14:36:18', 47, 53, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (150, b'0', b'1', '##### 请在申请友链之前请在贵站加好本站的链接\r\n\r\n- ​	名称：islizx -Blog\r\n- ​	网址：https://islizx.cn\r\n- ​	头像：<img src=\"/images/islizx.jpg\" style=\"zoom:25%;\" />\r\n\r\n##### 申请方法\r\n\r\n- ​	在下方留言或者任意其他位置留言\r\n- ​	如需设置友链头像可通过QQ、微信或者Email联系博主\r\n\r\n##### 备注\r\n\r\n- ​	不健康站、未备案站、非常见域名后缀等 **不友链**\r\n- ​	欢迎加好友交流学习', '2020-02-27 21:17:48', NULL, NULL, NULL, 0, b'0', b'0', '友链申请', '2020-02-27 21:53:24', 46, NULL, 2, 0, 0, 2, 'apply-links');
INSERT INTO `t_blog` VALUES (151, b'0', b'1', '##### 有什么问题欢迎在此处留言\r\n##### 您的支持和鼓励是我最大的动力！', '2020-02-27 22:05:42', NULL, NULL, NULL, 0, b'0', b'0', '留言板', '2020-02-27 22:05:42', 57, NULL, 2, 0, 0, 2, 'message');
INSERT INTO `t_blog` VALUES (153, b'0', b'1', '## 	前言\r\n\r\n​	首先，建立个人网站是大二的时候萌生的一个想法，网站前前后后推翻重构了三次。由原本的struts+jsp+servlet变成ssh，到现在的ssm。其中前台前端框架使用的是semantic ui，后台前端框架使用的是bootstrap，模板引擎使用的是thymeleaf。总的来说，整个网站使用的技术架构比较简单，但是随着新技术的学习，网站将来还是会更新技术架构。预览地址：https://islizx.cn\r\n\r\n​	项目源码已托管至GitHub，GitHub地址：https://github.com/isLizx/islizxBlog。 如果可以，GitHub上麻烦给个star。\r\n\r\n## 一.建站故事与技术架构\r\n\r\n### 	1.1 建站过程\r\n\r\n​	萌生开发个人博客网站的想法是因为学校毕业设计需要交一个自己开发的网站项目。加上平时遇问题到网上找答案，看到博客园、CSDN等技术博客平台的人有自己的网站着实有点羡慕。于是将自己的毕业设计主题选择为个人博客网站。毕竟，哪个男孩不想有一个属于自己的网站呢？期初学的是简单的struts，加上之前学的jsp和servlet简简单单的写了一个博客项目。\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_244.png)\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_152.png)\r\n\r\n​	第一版功能简单，后台还有一些功能没有实现以及存在许多bug，但至少能够发博客了。\r\n\r\n​	第二版参考李仁密的开发小而美博客的视频，只不过他使用的是springboot，而我改成了Struts+Spring+Hiernate。功能上和他一样，只是技术架构不同。\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_996.png)\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_32.png)\r\n\r\n​	该项目源码目前托管在GitHub上，地址 https://github.com/isLizx/blog 感兴趣的同学可以看一看。\r\n\r\n​	现在的版本前台页面还是采用李仁密博客的模板。后台自己在网上找了一个后台管理的bootstrap模板，前端自己改，后端自己全部重写，最终变成了现在这个版本。总之，页面现在看着还算凑合，但是仔细看看还是有一些问题。比如首页的轮播组件存在动画累积的问题，部分页面存在移动端不适应，有些地方还存在一些bug。只能等之后自己仔细琢磨一下前端了。\r\n\r\n### 1.2 技术架构\r\n\r\n- **Java后端框架：** SpringMVC、Spring、MyBatis\r\n\r\n- **前端框架：** Bootstrap、Jquery、Semantic UI\r\n\r\n- **数据库：** MySQL\r\n\r\n- **部署：** Tomcat、阿里云服务器\r\n\r\n- **模板引擎：** Thymeleaf\r\n\r\n- 前端页面还是采用上一版的模板页面（基于Semantic UI），后台模板采用 INSPINIA+ Admin Theme的模板（基于Bootstrap）\r\n\r\n​	网站核心主要采用SpringMVC、Spring和Mybatis,下图是用户访问一篇文章时，ssm框架执行流程原理，参考了[张开涛](https://www.iteye.com/blog/jinnianshilongnian-1594806)的博客文章\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_48.gif)\r\n\r\n\r\n\r\n​	**运行流程分析**\r\n\r\n1.浏览器发送请求查看一篇文章，articleid=1\r\n\r\n2.启动WEB项目容器。首先会去读取web.xml配置文件里的配置。 web.xml中标签的加载顺序：<context-param>  >  <listener> (spring的相关工作)  >  filter >servlet（springmvc的相关工作）\r\n\r\n3.spring初始化完成\r\n\r\n4.DispatcherServlet->HandlerMapping进行请求到处理的映射，HandlerMapping将“/articledetail”路径直接映射到名字为“/articledetail”的Bean进行处理，即ArticleController，返回Handler。\r\n\r\n5.如果存在自定义拦截器（比如后台需用户登录才能进行接下来的操作），则会先执行拦截器，接着返回一个执行链\r\n\r\n3.前端控制器拿着处理器映射器返回的Handler调用处理器适配器HandlerAdapter去执行Handler,HandlerAdapter处理器适配为ArticleController。\r\n\r\n7.ArticleController执行查询，取得结果集返回数据。\r\n\r\n8.前端控制器请求视图解析器ViewResolver进行视图解析，根据逻辑视图解析成真正的视图，向前端控制器返回view\r\n\r\n9.Thymeleaf（/articledetail.html）进行渲染，将在处理器传入的模型数据在视图中展示出来；\r\n10.返回响应。\r\n\r\n\r\n\r\n## 二、页面预览\r\n\r\n### 2.1 介绍几张后台的页面\r\n\r\n1.后台首页 DashBoard\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_63.png)\r\n\r\n2.文章列表\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_313.png)\r\n\r\n3.编辑文章（MarkDown编辑器）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_354.png)\r\n\r\n4.页面管理（可以自定义页面，申请友链和留言板即为自定义页面）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_828.png)\r\n\r\n5.附件管理（点击附件可以查看详细信息以及删除操作）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_201.png)\r\n\r\n6.评论管理（管理员回复回收站和待审核的评论后直接通过审核并发送邮件给评论者）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_899.png)\r\n\r\n7.日志管理\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_909.png)\r\n\r\n## 三、项目结构\r\n\r\n1.代码结构\r\n\r\n   <img src=\"https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_797.png\" style=\"zoom:67%;\" />\r\n\r\n2.数据库表\r\n\r\n   ![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_205.png)\r\n\r\n## 四、总结\r\n\r\n​	折腾这么久总算能够看看，如果大家发现本网站的bug，也麻烦各位在本站留言或联系博主。最后希望大家GitHub上麻烦给个star，https://github.com/isLizx/islizxBlog。\r\n\r\n## 五、更新日志\r\n\r\n- 2020-01-30至2020-02-21：项目基本完成\r\n\r\n- 2020-02-26：ICP备案信息通过\r\n\r\n- 2020-02-27：在阿里云上线\r\n\r\n- 2020-02-27：公网安备通过\r\n\r\n- 2020-02-28：配置HTTPS成功，配置quartz定时备份数据库\r\n\r\n- 2020-03-11：加入redis缓存和数据库。对首页访问频率多的数据加入缓存。对于经常更新的数据如：浏览量之类的数据先添加到redis数据库中，再通过quartz定时刷新到数据库中\r\n\r\n- 2020-03-12：将图片附件部署到阿里云OSS上\r\n  \r\n\r\n ​	​	​	​	​	​	​	 **持续更新中...**\r\n\r\n\r\n\r\n', '2020-02-29 17:18:57', '萌生开发个人博客网站的想法是因为学校毕业设计需要交一个自己开发的网站项目。加上平时遇问题到网上找答案，看到博客园、CSDN等技术博客平台的人有自己的网站着实有点羡慕', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_171827_770.jpg', '原创', 0, b'1', b'1', '个人网站的建立（一）建站历史和技术架构', '2020-03-12 14:41:43', 73, 54, 2, 0, 1, 0, NULL);
INSERT INTO `t_blog` VALUES (154, b'0', b'1', '## 一、Quartz\r\n\r\n### 1.1 核心概念\r\n\r\n- Quartz作为开源定时调度器，功能强悍，使用方便。\r\n\r\n- Quartz结构图：\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194319_343.png)\r\n\r\n### 1.2 主要组成部分\r\n\r\n- Job：表示一个工作，要执行的具体内容。此接口中只有一个方法\r\n\r\n```java\r\nvoid execute(JobExecutionContext context)\r\n```\r\n\r\n- JobDetail：表示一个具体的可执行的调度程序，Job是这个可执行程调度程序所要执行的内容，另外JobDetail还包含了这个任务调度的方案和策略。\r\n\r\n- Trigger：代表一个调度参数的配置，什么时候去调。\r\n\r\n- Scheduler：代表一个调度容器，一个调度容器中可以注册多个JobDetail和Trigger。当Trigger与JobDetail组合，就可以被Scheduler容器调度了。\r\n\r\n## 二、spring+quartz实现定时备份数据库数据\r\n\r\n### 	2.1 基于quartz强大的强大的调度功能，本站使用quartz来对数据库进行备份，与Spring结合\r\n\r\n### 	2.2 使用\r\n\r\n1.pom文件添加依赖包\r\n\r\n   ```java\r\n   <!-- quartz定时支持 -->\r\n   <dependency>\r\n   	<groupId>org.springframework</groupId>\r\n   	<artifactId>spring-context-support</artifactId>\r\n   	<version>4.2.0.RELEASE</version>\r\n   </dependency>\r\n   <dependency>\r\n   	<groupId>org.quartz-scheduler</groupId>\r\n   	<artifactId>quartz</artifactId>\r\n   	<version>2.2.1</version>\r\n   </dependency>\r\n   ```\r\n\r\n   \r\n\r\n2.数据库配置文件 db.properties\r\n\r\n   ```properties\r\n   #MySQL\r\n   mysql.url=jdbc:mysql://127.0.0.1:3306/blog?useUnicode=true&characterEncoding=utf8\r\n   mysql.username=root\r\n   mysql.password=123456\r\n   #将数据文件到分到哪个路径下，这里backdatabase为最后一个目录，生成的格式为blog2020-2-28 23_39_00.sql\r\n   databasePath=/usr/islizx/backdatabase/blog\r\n   #要备份的数据库\r\n   databaseName=blog\r\n   ```\r\n\r\n3.用于读取 db.properties 配置文件的类\r\n\r\n   ```java\r\n   package com.islizx.util;\r\n   \r\n   import java.io.IOException;\r\n   import java.io.InputStream;\r\n   import java.util.Properties;\r\n   \r\n   /**\r\n    * 用于读取 db.properties 配置文件\r\n    * \r\n    * @author lizx\r\n    * @date 2020-02-28 - 23:00\r\n    */\r\n   public class ConfigManager {\r\n       private static Properties props = null;\r\n       static {\r\n           InputStream is = null;\r\n           is = ConfigManager.class.getClassLoader().getResourceAsStream(\r\n                   \"db.properties\");\r\n           if (is == null)\r\n               throw new RuntimeException(\"找不到数据库参数配置文件!\");\r\n           props = new Properties();\r\n           try {\r\n               props.load(is);\r\n           } catch (IOException e) {\r\n               throw new RuntimeException(\"数据库配置参数加载错误!\", e);\r\n           } finally {\r\n               try {\r\n                   is.close();\r\n               } catch (IOException e) {\r\n                   e.printStackTrace();\r\n               }\r\n           }\r\n       }\r\n       public static String getProperty(String key) {\r\n           return props.getProperty(key);\r\n       }\r\n   }\r\n   \r\n   ```\r\n\r\n   \r\n\r\n4.备份mysql数据库的java代码 BackMySql.java\r\n\r\n   ```java\r\n   package com.islizx.util;\r\n   \r\n   import java.io.*;\r\n   import java.text.DateFormat;\r\n   import java.util.Date;\r\n   \r\n   /**\r\n    * 备份mysql数据库的java代码\r\n    * \r\n    * @author lizx\r\n    * @date 2020-02-28 - 21:11\r\n    */\r\n   public class BackMySql {\r\n       public static void exportDataBase(){\r\n   		// 根据当前时间来命名sql文件\r\n           Date now = new Date();\r\n           DateFormat df= DateFormat.getDateTimeInstance();\r\n           String dbName = df.format(now)+\".sql\";\r\n           dbName=dbName.replaceAll(\":\", \"_\");\r\n   		// 读取配置文件\r\n           String user = ConfigManager.getProperty(\"mysql.username\");\r\n           String password = ConfigManager.getProperty(\"mysql.password\");\r\n           String database = ConfigManager.getProperty(\"databaseName\");\r\n           String filepath = ConfigManager.getProperty(\"databasePath\")+dbName;\r\n   		// 备份数据库的sql语句\r\n           String stmt1 = \"mysqldump  -u \"+user+\" -p\"+password+\" --set-charset=utf8 \"+database;\r\n           try{\r\n               Process process = Runtime.getRuntime().exec(stmt1);\r\n               InputStream in = process.getInputStream();\r\n               InputStreamReader xx = new InputStreamReader(in, \"utf8\");\r\n               String inStr;\r\n               StringBuffer sb = new StringBuffer(\"\");\r\n               String outStr;\r\n               BufferedReader br = new BufferedReader(xx);\r\n               while ((inStr = br.readLine()) != null) {\r\n                   sb.append(inStr + \"\\r\\n\");\r\n               }\r\n               outStr = sb.toString();\r\n               FileOutputStream fout = new FileOutputStream(filepath);\r\n               OutputStreamWriter writer = new OutputStreamWriter(fout, \"utf8\");\r\n               writer.write(outStr);\r\n               writer.flush();\r\n               in.close();\r\n               xx.close();\r\n               br.close();\r\n               writer.close();\r\n               fout.close();\r\n           }catch(IOException e){\r\n               e.printStackTrace();\r\n           }\r\n   \r\n       }\r\n   }\r\n   \r\n   ```\r\n\r\n5.定时调度类的核心代码 TriggerImpl.java\r\n\r\n   ```java\r\n   package com.islizx.service.impl;\r\n   \r\n   import com.islizx.util.BackMySql;\r\n   \r\n   /**\r\n    * 备份数据库\r\n    * @author lizx\r\n    * @date 2020-02-28 - 23:04\r\n    */\r\n   public class TriggerImpl {\r\n       public void BackMySQL(){\r\n           BackMySql.exportDataBase();\r\n       }\r\n   }\r\n   \r\n   ```\r\n\r\n6.Spring的配置：\r\n\r\n   ```java\r\n   <bean id=\"trigger\" class=\"com.islizx.service.impl.TriggerImpl\"></bean>\r\n       <!-- 定义调用对象和调用对象的方法 -->\r\n       <bean id=\"projobtask2\" class=\"org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean\">\r\n           <property name=\"targetObject\">\r\n               <ref bean=\"trigger\"/>\r\n           </property>\r\n           <property name=\"targetMethod\">\r\n               <value>BackMySQL</value>\r\n           </property>\r\n       </bean>\r\n       <!--定义触发时间  -->\r\n       <bean id=\"timecard2\" class=\"org.springframework.scheduling.quartz.CronTriggerFactoryBean\">\r\n           <property name=\"jobDetail\">\r\n               <ref bean=\"projobtask2\"/>\r\n           </property>\r\n           <!-- cron表达式 -->\r\n           <property name=\"cronExpression\">\r\n               <!-- 每周一上午十点十五备份一次-->\r\n               <value>0 15 10 ? * MON</value>\r\n           </property>\r\n       </bean>\r\n       <!-- 总管理类 如果将lazy-init=\'false\'那么容器启动就会执行调度程序 -->\r\n       <bean id=\"startQuertz2\" lazy-init=\"false\" autowire=\"no\" class=\"org.springframework.scheduling.quartz.SchedulerFactoryBean\">\r\n           <property name=\"triggers\">\r\n               <list>\r\n                   <ref bean=\"timecard2\"/>\r\n               </list>\r\n           </property>\r\n       </bean>\r\n   ```\r\n\r\n## 三、总结\r\n\r\n​	数据库可以一星期完全备份一次，增量备份一天一次，事务日志备份一小时或者三十分钟一次。\r\n\r\n', '2020-02-29 19:48:36', 'spring+quartz实现定时备份sqlserver数据库数据。基于quartz强大的强大的调度功能，本站使用quartz来对数据库进行备份，与Spring结合', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194722_287.jpg', '原创', 0, b'1', b'1', '个人网站的建立（二）Quartz整合Spring定时备份数据库', '2020-03-12 14:42:09', 20, 55, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (155, b'0', b'1', '## 一、关于项目\r\n\r\n1.该博客是基于SSM实现的个人博客系统，适合初学SSM和个人博客制作的同学学习。主要技术架构包括Maven、SpringMVC、Spring、MyBatis、Thymeleaf等。前端采用Bootstarp和Semantic UI。\r\n2.详细介绍：https://islizx.cn/article/153.html\r\n\r\n## 二、效果预览\r\n\r\n1.预览地址：https://islizx.cn\r\n\r\n2.前台效果图就不展示了，可前往网站浏览\r\n\r\n3.介绍几张后台的页面\r\n\r\n3.1 后台首页 DashBoard\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_63.png)\r\n\r\n3.2 文章列表\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_313.png)\r\n\r\n3.3 编辑文章（MarkDown编辑器）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_354.png)\r\n\r\n3.4 页面管理（可以自定义页面，申请友链和留言板即为自定义页面）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170209_828.png)\r\n\r\n3.5 附件管理（点击附件可以查看详细信息以及删除操作）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170112_201.png)\r\n\r\n3.6 评论管理（管理员回复回收站和待审核的评论后直接通过审核并发送邮件给评论者）\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_899.png)\r\n\r\n3.7 日志管理\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_170208_909.png)\r\n\r\n## 三、使用注意\r\n\r\n1.开发工具的选择\r\n\r\n   请使用 IntelliJ IDEA, 尽量不要用 Eclipse/MyEclipse。后者可能要折腾一会儿\r\n\r\n2.确保你安装了 Maven\r\n\r\n3.请给你的IDE安装Lombok插件\r\n\r\n   实体类中多次使用到 @Data 注解，请确保你的 IDE 安装了 Lombok 插件，否则找不到 getter/setter 方法\r\n\r\n## 四、使用步骤\r\n\r\n1.Fork项目\r\n\r\n   fork或者下载项目到本地（建议先fork到自己仓库，在通过码云导入仓库下载，实测下载速度可以）。完整项目源码，可以使用IDEA导入。数据库文件请先创建数据库，然后以运行sql文件方式导入\r\n\r\n2.导入数据库\r\n\r\n   新建数据库**blog**,导入数据库blog.sql。注意，数据库的编码和排序规则是utf-8和utf-8_general_ci。数据库默认用户名 root，密码 123456\r\n\r\n3.修改项目中的数据库连接信息\r\n\r\n   修改 db.properties 文件，该文件很容易找到，在 src/main/resources 中。里面有 MySQL 数据库连接信息，请确保已安装和启动 MySQL。注意修改数据库地址、表名、用户名和密码。\r\n\r\n## 五、下载地址\r\n\r\n​	GitHub地址：https://github.com/isLizx/islizxBlog  （如果可以帮忙点一次Star和Fork）', '2020-02-29 20:30:55', '该博客是基于SSM实现的个人博客系统，适合初学SSM和个人博客制作的同学学习。主要技术架构包括Maven、SpringMVC、Spring、MyBatis、Thymeleaf等。前端采用Bootstarp和Semantic UI', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200227_203508_953.jpg', '原创', 0, b'1', b'1', '【免费开源】一个简单的Java博客系统-适合初学ssm者', '2020-03-17 16:05:03', 37, 54, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (156, b'0', b'1', '欢迎访问本站，需要友链请在评论区留言！\r\n\r\n也请大家友善留言评论，正确填写邮箱地址及昵称。所有评论和留言都会经过审核。:fa-comment-o:', '2020-02-29 20:40:02', NULL, NULL, NULL, 0, b'0', b'0', '欢迎访问本站，需要友链请在评论区留言！', '2020-02-29 20:40:02', 21, NULL, 2, 0, 0, 1, NULL);
INSERT INTO `t_blog` VALUES (157, b'0', b'1', '# mysql 50道经典练习题，学生——老师——课程——分数\r\n\r\n## 前言\r\n\r\n本篇文章来记录一下自己做这50道练习题遇到的问题，也算记录自己的学习记录。其实之前也有做过，只是做到一半就放弃了，这次好好来重新练习一遍。\r\n\r\n网上有很多这50道练习题的解答过程，自己有几道题做不出的时候也会去参考，但网上的许多教程只是列举了答案，没有解析。所以本篇文章会在一些难的题目下提供解题思路。\r\n\r\n## 一、练习前的数据准备\r\n\r\n1.课程信息表\r\n\r\n```sql\r\ncreate table course(Cid varchar(10),Cname nvarchar(10),Tid varchar(10));\r\ninsert into course values(\'01\' , N\'语文\' , \'02\');\r\ninsert into course values(\'02\' , N\'数学\' , \'01\');\r\ninsert into course values(\'03\' , N\'英语\' , \'03\');\r\n```\r\n\r\n   \r\n\r\n2.学生成绩表\r\n\r\n```sql\r\ncreate table sc(Sid varchar(10),Cid varchar(10),score decimal(18,1));\r\ninsert into sc values(\'01\' , \'01\' , 80);\r\ninsert into sc values(\'01\' , \'02\' , 90);\r\ninsert into sc values(\'01\' , \'03\' , 99);\r\ninsert into sc values(\'02\' , \'01\' , 70);\r\ninsert into sc values(\'02\' , \'02\' , 60);\r\ninsert into sc values(\'02\' , \'03\' , 80);\r\ninsert into sc values(\'03\' , \'01\' , 80);\r\ninsert into sc values(\'03\' , \'02\' , 80);\r\ninsert into sc values(\'03\' , \'03\' , 80);\r\ninsert into sc values(\'04\' , \'01\' , 50);\r\ninsert into sc values(\'04\' , \'02\' , 30);\r\ninsert into sc values(\'04\' , \'03\' , 20);\r\ninsert into sc values(\'05\' , \'01\' , 76);\r\ninsert into sc values(\'05\' , \'02\' , 87);\r\ninsert into sc values(\'06\' , \'01\' , 31);\r\ninsert into sc values(\'06\' , \'03\' , 34);\r\ninsert into sc values(\'07\' , \'02\' , 89);\r\ninsert into sc values(\'07\' , \'03\' , 98);\r\n```\r\n\r\n   \r\n\r\n3.学生信息表\r\n\r\n```sql\r\ncreate table student(Sid varchar(10),Sname nvarchar(10),Sage datetime,Ssex nvarchar(10))\r\ninsert into student values(\'01\' , N\'赵雷\' , \'1990-01-01\' , N\'男\');\r\ninsert into student values(\'02\' , N\'钱电\' , \'1990-12-21\' , N\'男\');\r\ninsert into student values(\'03\' , N\'孙风\' , \'1990-05-20\' , N\'男\');\r\ninsert into student values(\'04\' , N\'李云\' , \'1990-08-06\' , N\'男\');\r\ninsert into student values(\'05\' , N\'周梅\' , \'1991-12-01\' , N\'女\');\r\ninsert into student values(\'06\' , N\'吴兰\' , \'1992-03-01\' , N\'女\');\r\ninsert into student values(\'07\' , N\'郑竹\' , \'1989-07-01\' , N\'女\');\r\ninsert into student values(\'08\' , N\'王菊\' , \'1990-01-20\' , N\'女\');\r\n```\r\n\r\n   \r\n\r\n4.教师信息表\r\n\r\n```sql\r\ncreate table teacher(Tid varchar(10),Tname nvarchar(10));\r\ninsert into teacher values(\'01\' , N\'张三\');\r\ninsert into teacher values(\'02\' , N\'李四\');\r\ninsert into teacher values(\'03\' , N\'王五\');\r\n```\r\n\r\n## 二、练习题\r\n\r\n1.查询\" 01 \"课程比\" 02 \"课程成绩高的学生的信息及课程分数\r\n\r\n   先查出两个课程的所有学生成绩，利用关联条件a.sid=b.sid来达到同一学生的两门课程比较，再通过关联学生信息表获取学生信息\r\n\r\n```sql\r\nselect a.* ,b.* , c.* from (select * from sc where cid = \"01\") a left join (select * from sc where cid = \"02\") b\r\non a.sid = b.sid\r\nleft join student c\r\non a.sid = c.sid\r\nwhere a.score > b.score;\r\n```\r\n\r\n2.查询同时存在\" 01 \"课程和\" 02 \"课程的情况\r\n\r\n```sql\r\nselect a.* ,b.* from (select * from sc where cid = \"01\") a inner join (select * from sc where cid = \"02\") b\r\non a.sid = b.sid\r\n```\r\n\r\n3.查询存在\" 01 \"课程但可能不存在\" 02 \"课程的情况(不存在时显示为 null )\r\n\r\n   可能不存在02课程只能左外连接了\r\n\r\n```sql\r\nselect a.* ,b.* from (select * from sc where cid = \"01\") a left join (select * from sc where cid = \"02\") b\r\non a.sid = b.sid\r\n```\r\n\r\n4.查询不存在\" 01 \"课程但存在\" 02 \"课程的情况\r\n\r\n   可以先查出存在01课程的情况再not in\r\n\r\n```sql\r\nselect a.* from sc a where a.cid = \"02\" and a.sid not in (select sid from sc where cid = \"01\"); \r\n```\r\n\r\n5.查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩\r\n\r\n```sql\r\nselect a.sid, b.sname, avg(score) from sc a left join student b on a.sid = b.sid group by a.sid having avg(score) > 60;     \r\n```\r\n\r\n6.查询在 sc 表存在成绩的学生信息\r\n\r\n   存在成绩即为sc表中存在记录，以下有两种思路\r\n\r\n```sql\r\n#第一种\r\nselect distinct student.* from sc left join student on sc.sid = student.sid \r\n\r\n#第二种\r\nselect a.* from student a where a.sid in (select sid from sc);      \r\n```\r\n\r\n7.查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null )\r\n\r\n   编号和选课总数以及所有课程的总成绩都隐藏在sc表中，只需一个group by sid即可。至于没有成绩则需要从student表查sc表，right join student。\r\n\r\n```sql\r\nselect b.sid, b.sname, selcousum, scoresum  from (select sid, count(cid) as selcousum, sum(score) as scoresum from sc group by sid) a right join student b on a.sid = b.sid     \r\n```\r\n\r\n8.查有成绩的学生信息\r\n\r\n```sql\r\nselect distinct student.* from sc left join student on sc.sid = student.sid \r\n\r\nselect a.* from student a where a.sid in (select sid from sc);      \r\n```\r\n\r\n9.查询「李」姓老师的数量\r\n\r\n```sql\r\nselect count(tid) from teacher where tname like \"李%\";      \r\n```\r\n\r\n10.查询学过「张三」老师授课的同学的信息\r\n\r\n这题只是表关联多而已，只需将题目拆分一下即可\r\n\r\n```sql\r\nselect st.* from sc left join student st on sc.sid = st.sid where cid in (select c.cid from teacher t inner join course c on t.tid = c.tid where t.tname = \"张三\");    \r\n```\r\n\r\n11.查询没有学全所有课程的同学的信息\r\n\r\n这题思路参考第四题，反向思考。可以先查询出学全所有课程同学的sid,然后在student表中not in即可\r\n\r\n```sql\r\nselect student.* from student where student.sid not in (select sid from sc group by sid having count(cid) = (select count(cid) from course));      \r\n```\r\n\r\n12.查询至少有一门课与学号为\" 01 \"的同学所学相同的同学的信息\r\n\r\n```sql\r\nselect stu.* from student stu where sid in (select distinct sid from sc where cid in (select cid from sc where sid = \"01\"));      \r\n```\r\n\r\n13.查询和\" 01 \"号的同学学习的课程完全相同的其他同学的信息\r\n\r\n这题不会做，网上查找答案后才知道。这道题的思路就是卡在如何比较两个同学的课程是否相同。\r\n\r\n而网上的答案的思路则是换了一种。先查出一门都没选过01号同学课程的sid，not in 一下就只剩少选的和全选的。最后只要找出课程数和01号同学相等即可。\r\n\r\n```sql\r\nselect * from student where sid in (\r\nselect sid from sc where sid not in (select sid from sc where cid not in (select cid from sc where sid = \"01\")) \r\ngroup by sid having count(cid) = (select count(cid) from sc where sid = \"01\")\r\n) and sid != \"01\"      \r\n```\r\n\r\n14.查询没学过\"张三\"老师讲授的任一门课程的学生姓名\r\n\r\n```sql\r\nselect sname from student where sid not in (select distinct sid from sc where cid = (select cid from teacher t join course c on t.tid = c.tid where t.tname = \"张三\"))      \r\n```\r\n\r\n15.查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩\r\n\r\n```sql\r\nselect s.sid, s.sname, avg(score) from sc inner join student s on sc.sid = s.sid where score < 60 group by sc.sid having count(sc.sid) >= 2      \r\n```\r\n\r\n16.检索\" 01 \"课程分数小于 60，按分数降序排列的学生信息\r\n\r\n```sql\r\nselect st.* from student st join sc on st.sid = sc.sid where cid = \"01\" and score < 60 order by sc.score desc      \r\n```\r\n\r\n17.按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩\r\n\r\n```sql\r\nselect sc.*, a from (select sid, avg(score) as a from sc group by sid) r left join sc on r.sid = sc.sid order by a desc      \r\n```\r\n\r\n18.查询各科成绩最高分、最低分和平均分：\r\n\r\n```sql\r\nselect c.cname, max(score), min(score), avg(score) from course c join sc on c.cid = sc.cid group by c.cid     \r\n```\r\n\r\n19.以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率\r\n-- 及格为>=60，中等为：70-80，优良为：80-90，优秀为：>=90\r\n\r\n这是主要考察case-when-then-else-end。\r\n\r\n```sql\r\nselect c.cid as \"课程 ID\", c.cname as \"课程 name\", max(score) as \"最高分\", min(score) as \"最低分\", avg(score) as \"平均分\", \r\nsum(case when score >= 60 then 1 else 0 end)/count(distinct sid) as \"及格率\", \r\nsum(case when score>=70 and score < 80 then 1 else 0 end)/count(distinct sid) as \"中等率\", \r\nsum(case when score>=80 and score < 90 then 1 else 0 end)/count(distinct sid) as \"优良率\", \r\nsum(case when score>=90 then 1 else 0 end)/count(distinct sid) as \"优秀率\"\r\nfrom course c join sc on c.cid = sc.cid group by c.cid     \r\n```\r\n\r\n20.要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列\r\n\r\n```sql\r\nselect cid, count(sid) from sc group by cid order by count(distinct sid) desc, cid asc      \r\n```\r\n\r\n21.按各科成绩进行排序，并显示排名， score 重复时保留名次空缺\r\n\r\n这里通过自己关联自己，首先只同一门科目对比同一门科目的成绩s1.cid=s2.cid，至于排名靠查询出的次数来实现，如果s1的某门科目比某个人分数低，则排名加一（不会存在自己跟自己比的，因为成绩是相等的）。最后只需要按照每门课程分组，在按照学生分组即可\r\n\r\n```sql\r\nselect s1.cid, s1.sid, s1.score, count(s2.score)+1 as rank \r\nfrom sc s1 \r\nleft join sc s2 \r\non s1.score < s2.score and s1.cid = s2.cid\r\ngroup by s1.cid, s1.sid\r\norder by s1.cid, rank      \r\n```\r\n\r\n22.查询学生的总成绩，并进行排名，总分重复时不保留名次空缺\r\n\r\n```sql\r\nset @i = 0;\r\nselect @i := @i +1 as rank, b.sid, b.sumscore from \r\n(select sid, sum(score) as sumscore from sc group by sid) b;      \r\n```\r\n\r\n23.统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比\r\n\r\n同19题\r\n\r\n```sql\r\nselect count(sid), c.cid, c.cname, \r\nsum(case when 100 >= score and score > 85 then 1 else 0 end)/(count(sid)) as \"[100-85]\",\r\nsum(case when 85 >= score and score > 70 then 1 else 0 end)/(count(sid)) as \"[85-70]\",\r\nsum(case when 70 >= score and score > 60 then 1 else 0 end)/(count(sid)) as \"[70-60]\",\r\nsum(case when 60 >= score and score >= 0 then 1 else 0 end)/(count(sid)) as \"[60-0]\"\r\nfrom sc join course c on sc.cid = c.cid group by sc.cid      \r\n```\r\n\r\n24.查询各科成绩前三名的记录\r\n\r\n由于mysql不能group by以后再去limit，所以这题没有想象中的简单。\r\n\r\n第一种方法是网上找来的，比较难以理解。找比自己分数大的记录有几条。如果小于三，即自己在前三排名中，则将自己查询出来。这样循环sc表就可查询各科成绩前三名的记录\r\n\r\n第二种是自己通过第一种理解改过来的。还是利用自己关联自己，比较后如果sc的某条记录排名前三，则select.\r\n\r\n```sql\r\nselect * from sc\r\nwhere (\r\nselect count(*) from sc as a \r\nwhere sc.cid = a.cid and sc.score<a.score \r\n)< 3\r\norder by cid asc, sc.score desc;\r\n\r\nselect s1.cid, s1.sid, s1.score from sc s1 left join sc s2 on \r\ns1.cid = s2.cid and s1.score < s2.score  \r\ngroup by s1.cid, s1.sid having count(s2.cid) < 3 order by s1.cid asc, s1.score desc;      \r\n```\r\n\r\n25.查询每门课程被选修的学生数\r\n\r\n```sql\r\nselect cid, count(sid) from sc group by cid;      \r\n```\r\n\r\n26.查询出只选修两门课程的学生学号和姓名\r\n\r\n```sql\r\nselect st.sid, sname from sc left join student st on sc.sid = st.sid group by sid having count(cid) = 2      \r\n```\r\n\r\n27.查询男生、女生人数\r\n\r\n```sql\r\nselect count(ssex) from student group by ssex      \r\n```\r\n\r\n28.查询名字中含有「风」字的学生信息\r\n\r\n```sql\r\nselect * from student where sname like \"%风%\"      \r\n```\r\n\r\n29.查询同名学生名单，并统计同名人数\r\n\r\n```sql\r\nselect count(*) from student s1 inner join student s2 on \r\ns1.sid != s2.sid and s1.sname = s2.sname \r\n\r\nselect sname, count(*) from student group by sname having count(sname) > 1       \r\n```\r\n\r\n30.查询 1990 年出生的学生名单\r\n\r\n```sql\r\nselect * from student where year(sage) = \"1990\"      \r\n```\r\n\r\n31.查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列\r\n\r\n```sql\r\nselect cid, avg(score) from sc group by cid order by avg(score) desc, cid       \r\n```\r\n\r\n32.查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩\r\n\r\n```sql\r\nselect st.sid, st.sname, avg(score) from sc join student st on sc.sid = st.sid group by sc.sid having avg(score) >= 85      \r\n```\r\n\r\n33.查询课程名称为「数学」，且分数低于 60 的学生姓名和分数\r\n\r\n```sql\r\nselect st.sname, sc.score from sc join student st on sc.sid = st.sid \r\njoin course c on c.cid = sc.cid where c.cname = \"数学\" and score < 60      \r\n```\r\n\r\n34.查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况）\r\n\r\n```sql\r\nselect st.sid, sc.score from student st left join sc on st.sid = sc.sid       \r\n```\r\n\r\n35.查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数\r\n\r\n```sql\r\nselect sname, cname, score from student st join sc on st.sid = sc.sid join \r\ncourse c on sc.cid = c.cid where score > 70      \r\n```\r\n\r\n36.查询存在不及格的课程\r\n\r\n```sql\r\nselect cid from sc group by cid having min(score) < 60      \r\n```\r\n\r\n37.查询课程编号为 01 且课程成绩在 80 分及以上的学生的学号和姓名\r\n\r\n```sql\r\nselect st.sid, st.sname from sc join student st on sc.sid = st.sid \r\nwhere cid = \"01\" and score >= 80      \r\n```\r\n\r\n38.求每门课程的学生人数\r\n\r\n```sql\r\nselect count(sid) from sc group by cid;      \r\n```\r\n\r\n39.成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩\r\n\r\n这个只是表关联复杂一点，这里使用max()也可以\r\n\r\n```sql\r\nselect st.*, score from sc join student st on sc.sid = st.sid,\r\n(select sid,cid from sc where cid = (select cid from teacher t join course c on t.tid = c.tid where t.tname = \"张三\") order by score desc limit 1) a \r\nwhere sc.sid = a.sid and sc.cid = a.cid      \r\n```\r\n\r\n40.成绩有重复的情况下，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩\r\n\r\n第一种是自己开始做的，做完之后感觉自己短路了，虽然结果没错，但是存在代码冗余。\r\n\r\n第二种为网上版本，由于存在成绩有重复，可以先找出第一名的成绩，再找出和第一名相同的学生即可。\r\n\r\n记录一下\r\n\r\n```sql\r\nselect st.* , sc.score from student st join sc on st.sid = sc.sid, \r\n(select score from sc where cid = (select cid from teacher join course on teacher.tid = course.tid where tname = \"张三\") order by score desc limit 1) a\r\nwhere sc.score = a.score and cid = (select cid from teacher join course on teacher.tid = course.tid where tname = \"张三\");\r\n\r\nselect st.*, sc.score from student st, teacher te ,course co ,sc where st.sid = sc.sid and te.tid = co.tid and sc.cid = co.cid\r\nand te.tname = \"张三\" and sc.score = (\r\nselect max(score) from sc, teacher te, course co where sc.cid = co.cid and te.tid = co.tid and te.tname = \"张三\"\r\n)      \r\n```\r\n\r\n41.查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩\r\n\r\n还是利用自交的方式，最重要的是group by cid, sid。\r\n\r\n```sql\r\nselect sc1.sid, sc1.cid, sc1.score from sc sc1 inner join sc sc2 on sc1.cid != sc2.cid and sc1.score = sc2.score and sc1.sid = sc2.sid group by cid, sid      \r\n```\r\n\r\n42.查询每门功成绩最好的前两名\r\n\r\n同上\r\n\r\n```sql\r\nselect a.cid, a.sid, a.score from sc a left join sc b on \r\na.cid = b.cid and a.score < b.score group by a.cid, a.sid having count(*) < 2 order by a.cid , a.score desc      \r\n```\r\n\r\n43.统计每门课程的学生选修人数（超过 5 人的课程才统计）\r\n\r\n```sql\r\nselect a.cid, a.coursesum from (select cid, count(sid) as coursesum from sc group by cid) a where a.coursesum > 5\r\n\r\nselect cid, count(sid) from sc group by cid having count(sid) > 5      \r\n```\r\n\r\n44.检索至少选修两门课程的学生学号\r\n\r\n在这题上跑偏了，想着先找出选修了两门一下的同学再not in。又短路了\r\n\r\n```sql\r\nselect sid, count(*) from sc group by sid having count(cid) >= 2      \r\n```\r\n\r\n45.查询选修了全部课程的学生信息\r\n\r\n```sql\r\nselect distinct st.* from student st join sc on st.sid = sc.sid where sc.sid in \r\n(\r\nselect sid from sc group by sid having count(*) = (select count(*) from course)\r\n)      \r\n```\r\n\r\n46.查询各学生的年龄，只按年份来算\r\n\r\n从这题开始就是mysql日期函数的使用\r\n\r\n```sql\r\nselect sid, date_format(now(), \"%Y\")-year(sage) from student      \r\n```\r\n\r\n47.按照出生日期来算，当前月日 < 出生年月的月日则，年龄减一\r\n\r\n```sql\r\nselect sid, timestampdiff(year,sage,curdate()) from student;      \r\n```\r\n\r\n48.查询本周过生日的学生\r\n\r\n```sql\r\nselect * from student where weekofyear(sage) = weekofyear(curdate());      \r\n```\r\n\r\n49.查询下周过生日的学生\r\n\r\n```sql\r\nselect * from student where weekofyear(sage) = weekofyear(curdate())+1;      \r\n```\r\n\r\n50.查询本月过生日的学生\r\n\r\n```sql\r\nselect * from student where month(sage) = month(curdate());      \r\n```\r\n\r\n51.查询下月过生日的学生\r\n\r\n```sql\r\nselect * from student where month(sage) = month(curdate())+1;      \r\n```\r\n\r\n## 三、课外题\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200303_153542_462.png)\r\n\r\n**用一条sql语句查出每位用户每天获取到的积分**\r\n\r\n```sql\r\nselect username, date_format(datetime1, \"%Y%m%d\"), sum(score) from jifen group by username, date_format(datetime1, \"%Y%m%d\")\r\n```\r\n\r\n## 四、总结\r\n\r\n1.大多数的sql题都是考察group by的使用，只要group by够熟悉，都能够掌握一般的sql题。外加一些内置函数的学习\r\n\r\n2.拆分题目，解析题干。如果一道题要查询的字段很多，多半是需要通过表关联查出来的。抛去这些字段，我们只要去关心如何查出核心字段即可。', '2020-03-03 15:36:35', '本篇文章来记录一下自己做这50道练习题遇到的问题，也算记录自己的学习记录。其实之前也有做过，只是做到一半就放弃了，这次好好来重新练习一遍。', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/2/20200229_194722_287.jpg', '原创', 0, b'1', b'1', 'mysql 50道经典练习题，学生——老师——课程——分数', '2020-03-12 14:43:08', 21, 55, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (158, b'0', b'0', '前台用户登录注册还在开发中，展示的登录还只是个样式。具体代码还在开发中\r\n\r\n\r\n\r\n\r\n#### 敬请期待....', '2020-03-12 14:48:16', NULL, NULL, NULL, 0, b'0', b'0', '用户登录注册正在开发中！', '2020-03-12 14:48:16', 22, NULL, 2, 0, 0, 1, NULL);
INSERT INTO `t_blog` VALUES (159, b'0', b'0', '###  一、数据结构与算法\r\n- 7个数据结构：数组、链表、栈、队列、二叉树、堆、图\r\n- 10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法\r\n### 二、Java基础\r\n- J2SE基础\r\n\r\n	面向对象的思想、Java常用类、[集合框架](https://www.cnblogs.com/syp172654682/p/7994496.html \"集合框架\")、IO、NIO、多线程并发、设计模式、JVM\r\n- J2EE基础\r\n\r\n	Servlet、JSP、JDBC\r\n- 常用框架原理\r\n\r\n	Struts、Hibernate、Spring、Spring MVC、MyBatis\r\n### 三、操作系统\r\n处理器管理、存储器管理、设备管理、文件管理和作业管理\r\n### 四、计算机网络\r\n[TCP/IP协议栈](https://www.islizx.cn/article/149.html \"TCP/IP协议栈\")\r\n### 五、数据库原理\r\nMySQL\r\n### 六、常用中间件原理\r\nRedis\r\n\r\n\r\n\r\n### 资料链接：\r\n[java集合框架常见面试题](https://www.cnblogs.com/iwenwen/p/11052689.html \"java集合框架常见面试题\")', '2020-03-14 12:11:16', '7个数据结构：数组、链表、栈、队列、二叉树、堆、图\r\n10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200.jpg', '原创', 0, b'1', b'0', '基础知识梳理', '2020-03-14 21:08:15', 46, 56, 2, 0, 1, 0, NULL);
INSERT INTO `t_blog` VALUES (160, b'0', b'1', '## 一、基本介绍\r\n1.代理模式为一个对象提供一个替身,以控制对这个对象的访问。即通过代理对象访问目标对象,这样做的好处是: 可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能\r\n2.被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象\r\n3.代理模式有不同的形式,主要有三种**静态代理、动态代理(JDK代理、接口代理)和Cglib代理(可以在内存动态的创建对象,而不需要实现接口,属于动态代理范畴)**\r\n## 二. 静态代理\r\n### 1. 基本介绍\r\n静态代理在使用时,需要定义接口或者父类,被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类\r\n### 2. 应用实例\r\n#### (1)需求\r\ni. 定义一个接口ITeacherDAO\r\nii. 目标对象TeacherDAO实现接口ITeacherDAO\r\niii. 使用静态代理方式,就需要在代理对象TeacherDAOProxy中也实现ITeacherDAO\r\niiii. 调用的时候通过调用代理对象的方法来调用目标对象\r\niiiii. 特别提醒: 代理对象与目标对象需要实现相同的接口,然后通过调用相同的方法来调用目标对象的方法\r\n#### (2)类图\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_113814_821.png)\r\n#### (3)代码\r\n```java\r\n// 接口 \r\npublic interface ITeacherDao {\r\n    void teach();\r\n}\r\n\r\n// 被代理对象,接口实现类\r\npublic class TeacherDao implements ITeacherDao {\r\n    @Override\r\n    public void teach() {\r\n        System.out.println(\"老师授课中...\");\r\n    }\r\n}\r\n\r\n// 代理对象,静态代理\r\npublic class TeacherDaoProxy implements ITeacherDao {\r\n    private ITeacherDao target; //目标对象,通过接口来聚合\r\n    public TeacherDaoProxy(ITeacherDao target) {\r\n        this.target = target;\r\n    }\r\n    @Override\r\n    public void teach() {\r\n        System.out.println(\"开始代理...\");\r\n        target.teach();\r\n        System.out.println(\"代理结束...\");\r\n    }\r\n}\r\n\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //创建目标对象(被代理对象)\r\n        TeacherDao teacherDao = new TeacherDao();\r\n        //创建代理对象,同时将被代理对象传递给代理对象\r\n        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);\r\n        //执行代理对象方法\r\n        teacherDaoProxy.teach();\r\n    }\r\n}\r\n\r\n//输出结果\r\n开始代理...\r\n老师授课中...\r\n代理结束...\r\n```\r\n### 3. 优缺点\r\n(1)优点: 在不修改目标对象的功能前提下,能通过代理对象对目标功能扩展\r\n(2)缺点: 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类。一旦接口增加方法,对目标对象与代理对象都要维护\r\n## 三. 动态代理\r\n### 1. 基本介绍\r\n(1) 代理对象,不需要实现接口,但是目标对象要实现接口,否则不能使用动态代理\r\n(2) 代理对象的生成,是利用JDK的API,动态地在内存中构建代理对象\r\n(3) 动态代理也叫: JDK代理、接口代理\r\n\r\n### 2. 应用案例\r\n利用前面的静态代理改进成动态代理模式\r\n#### (1)类图\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_115012_220.png)\r\n#### (2)代码\r\nITeacherDao接口和TeacherDao实现类与上面一致,这里省略\r\n```java\r\n// 动态代理工厂类\r\npublic class ProxyFactory {\r\n    //存放目标接口的实现类\r\n    private Object target;\r\n    public ProxyFactory(Object target){\r\n        this.target = target;\r\n    }\r\n    //给目标对象生成一个代理对象\r\n    /**\r\n     *     public static Object newProxyInstance(ClassLoader loader,\r\n                Class<?>[] interfaces,\r\n                InvocationHandler h)\r\n     * 说明\r\n     * 1. ClassLoader loader : 指定当前目标对象使用的类加载器,获取加载器的方法固定\r\n     * 2. Class<?>[] interfaces : 目标对象实现的接口类型,使用泛型方法确认类型\r\n     * 3. InvocationHandler h : 事情处理,执行目标对象的方法时,会触发事情处理器方法,会把当前执行的目标对象方法作为参数传入\r\n     */\r\n    public Object getProxyInstance(){\r\n        return Proxy.newProxyInstance(target.getClass().getClassLoader(),\r\n                target.getClass().getInterfaces(),\r\n                new InvocationHandler() {\r\n                    @Override\r\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\r\n                        System.out.println(\"JDK代理开始 ...\");\r\n                        //反射机制调用目标对象方法\r\n                        Object returnVal = method.invoke(target, args);\r\n                        System.out.println(\"JDK代理结束 ...\");\r\n                        return returnVal;\r\n                    }\r\n                }\r\n        );\r\n    }\r\n}\r\n\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //创建目标对象\r\n        ITeacherDao target = new TeacherDao();\r\n\r\n        //给目标对象,创建代理对象,可以转成ITeacherDao\r\n        ITeacherDao proxyInstance = (ITeacherDao) new ProxyFactory(target).getProxyInstance();\r\n\r\n        //内存中动态生成了代理对象 proxyInstance = class com.sun.proxy.$Proxy0\r\n        System.out.println(\"proxyInstance = \" + proxyInstance.getClass());\r\n\r\n        //通过代理对象,调用目标对象的方法\r\n        proxyInstance.teach();\r\n    }\r\n}\r\n\r\n//输出结果\r\nproxyInstance = class com.sun.proxy.$Proxy0\r\nJDK代理开始 ...\r\n老师授课中...\r\nJDK代理结束 ...\r\n```\r\n## 四. Cglib代理\r\n### 1. 基本介绍\r\n(1) 目标对象无需实现任何接口,可以使用目标对象子类来实现代理\r\n(2) Cglib代理也叫子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能扩展,有些书也将Cglib代理归属到动态代理\r\n(3) Cglib是一个强大的高性能代码生成包,它可以在运行期扩展Java类与实现Java接口。它广泛被许多AOP框架使用,例如Spring AOP实现方法拦截\r\n(4) 在AOP编程中如何选择代理模式:\r\n1. 目标对象需要实现接口,使用JDK代理\r\n2. 目标对象不需要实现接口,使用Cglib代理\r\n\r\n(5) Cglib包底层时通过使用字节码处理框架ASM来转换字节码并生成新的类\r\n### 2. 应用案例\r\n#### (1)类图\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200316_120322_100.png)\r\n#### (2)代码\r\n```java\r\n<!-- 需要使用到的jar包 -->\r\n<dependency>\r\n    <groupId>cglib</groupId>\r\n    <artifactId>cglib</artifactId>\r\n    <version>3.1</version>\r\n</dependency>\r\n\r\n// 目标对象,无需实现接口了\r\npublic class TeacherDao {\r\n    public void teach() {\r\n        System.out.println(\"老师授课中...\");\r\n    }\r\n}\r\n\r\n// Cglib 动态代理\r\npublic class ProxyFactory implements MethodInterceptor{\r\n    private Object target;\r\n    public ProxyFactory(Object target){\r\n        this.target = target;\r\n    }\r\n    //返回一个代理对象,是target对象的代理对象\r\n    public Object getProxyInstance(){\r\n        //1.创建一个工具类\r\n        Enhancer enhancer = new Enhancer();\r\n        //2.设置父类\r\n        enhancer.setSuperclass(target.getClass());\r\n        //3.设置回调函数\r\n        enhancer.setCallback(this);\r\n        //4.创建子类对象,即代理对象\r\n        return enhancer.create();\r\n    }\r\n    //重写intercept方法,会调用目标对象的方法\r\n    @Override\r\n    public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\r\n        System.out.println(\"Cglib代理模式开始 ...\");\r\n        Object returnVal = method.invoke(target, args);\r\n        System.out.println(\"Cglib代理模式结束 ...\");\r\n        return returnVal;\r\n    }\r\n}\r\n\r\n\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        TeacherDao teacherDao = new TeacherDao();\r\n        ProxyFactory proxyFactory = new ProxyFactory(teacherDao);\r\n        TeacherDao proxyInstance = (TeacherDao) proxyFactory.getProxyInstance();\r\n        proxyInstance.teach();\r\n    }\r\n}\r\n\r\n//输出结果\r\nCglib代理模式开始 ...\r\n老师授课中...\r\nCglib代理模式结束 ...\r\n```\r\n', '2020-03-16 12:07:02', '代理模式为一个对象提供一个替身,以控制对这个对象的访问。即通过代理对象访问目标对象,这样做的好处是: 可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200.jpg', '原创', 0, b'1', b'0', '代理设计模式', '2020-03-16 12:07:02', 11, 57, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (161, b'0', b'1', '## 前言\r\n如果你的spring项目部署在tomcat服务器上，那么tomcat启动，servlet容器随之启动，读取service.xml配置文件，启动里面配置的web应用，为每个应用创建一个ServletContext（全局上下文环境），接着创建Spring容器、SpringMVC容器。\r\n本文将简述Web容器、Servlet容器、Spring容器、SpringMVC容器之间的关系，以及spring的启动流程。\r\n## servlet\r\nservlet是sun公司为开发动态web而提供的一门技术，用户若想用发一个动态web资源(即开发一个Java程序向浏览器输出数据)，需要完成以下2个步骤：\r\n1. 编写一个Java类，实现servlet接口。\r\n2. 把开发好的Java类部署到web服务器中。按照一种约定俗成的称呼习惯，通常我们也把实现了servlet接口的java程序，称之为Servlet。\r\n\r\n## web容器\r\nweb容器（web服务器）主要有：Apache、IIS、Tomcat、Jetty、JBoss、webLogic等，这些服务器同时也是servlet容器，因为它们包含了servlet容器。没有servlet容器，也可以用web容器直接访问静态页面。**但是如果要显示jsp/servlet，就需要安装一个servlet容器，但是光有servlet容器是不够的，因为它要被解析成html输出，所以你仍需要一个web容器。大多数servlet容器同时提供了web容器的功能，也就是说大多servelt容器可以独立运行你的web应用。**\r\n\r\n** web容器是管理servlet（通过servlet容器），以及监听器(Listener)和过滤器(Filter)的。**这些都是在web容器的掌控范围里。但他们不在spring和springmvc的掌控范围里。因此，我们无法在这些类中直接使用Spring注解的方式来注入我们需要的对象，是无效的，web容器是无法识别的。\r\n## Servlet容器\r\nServlet容器是管理servlet对象的。\r\n## Spring容器\r\nSpring容器是管理service和dao的。\r\n## SpringMVC容器\r\nSpringMVC容器是管理controller对象的。\r\n\r\nSpring容器和SpringMVC容器的关系是父子容器的关系。Spring容器是父容器，SpringMVC容器是子容器。在子容器里可以访问父容器里的对象，但是在父容器里不可以访问子容器的对象。\r\n## Servlet容器和ServletContext的关系\r\nServletContext是servlet与servlet容器之间的直接通信的接口。Servlet容器在启动一个Web应用时，会为它创建一个servletContext对象。**每个web应用有唯一的servletContext对象。同一个web应用的所有servlet对象共享一个serveltContext,servlet对象可以通过它来访问容器中的各种资源。 **\r\n\r\n## servlet的运行过程\r\n1.浏览器发出请求，被web容器获取到\r\n\r\n2.Web服务器首先检查是否已经装载并创建了该Servlet的实例对象。\r\n\r\n3.如果没有则装载并创建该Servlet的一个实例对象，调用Servlet实例对象的init()方法。\r\n\r\n4.创建一个用于封装HTTP请求消息的HttpServletRequest对象和一个代表HTTP响应消息的HttpServletResponse对象，然后调用Servlet的service()方法并将请求和响应对象作为参数传递进去。\r\n\r\n5.WEB应用程序被停止或重新启动之前，Servlet引擎将卸载Servlet，并在卸载之前调用Servlet的destroy()方法。\r\n\r\n## web.xml\r\n```xml\r\n<!--加载spring容器-->\r\n<context-param>\r\n	<param-name>contextConfigLocation</param-name>\r\n	<param-value>\r\n		classpath:spring/spring-*.xml,\r\n	</param-value>\r\n</context-param>\r\n<!--配置监听器，来加载spring容器-->\r\n<listener>\r\n	<listener-class>\r\n		org.springframework.web.context.ContextLoaderListener\r\n	</listener-class>\r\n</listener>\r\n\r\n<!--springmvc前端控制器 -->\r\n<servlet>\r\n	<servlet-name>Blog</servlet-name>\r\n	<servlet-class>com.islizx.exception.MyDispatcherServlet</servlet-class>\r\n	<init-param>\r\n		<param-name>contextConfigLocation</param-name>\r\n		<param-value>classpath:spring/spring-mvc.xml</param-value>\r\n	</init-param>\r\n</servlet>\r\n<servlet-mapping>\r\n	<servlet-name>Blog</servlet-name>\r\n	<url-pattern>/</url-pattern>\r\n	<url-pattern>*.js</url-pattern>\r\n	<url-pattern>*.css</url-pattern>\r\n	<url-pattern>*.img</url-pattern>\r\n	<url-pattern>*.html</url-pattern>\r\n</servlet-mapping>\r\n```\r\n\r\n## web容器的加载过程：\r\n1.启动web项目后，web容器首先回去找web.xml文件，读取<context-param>和<listener>两个节点。\r\n\r\n2.容器会创建一个 ServletContext （ servlet 上下文），并将web.xml中的属性设置到Context容器中。整个 web 项目的所有部分都将共享这个上下文。\r\n\r\n3.容器将<context-param>转换为键值对，并交给 servletContext。因为listener, filter 等在初始化时会用到这些上下文中的信息，所以要先加载。\r\n\r\n4.容器创建<listener>中的类实例，创建监听器。\r\n\r\n5.容器加载filter，创建过滤器， 要注意对应的filter-mapping一定要放在filter的后面。\r\n\r\n6.容器加载servlet，加载顺序按照 Load-on-startup 来执行\r\n\r\n**web.xml组件加载顺序：context-param -> listener -> filter -> servlet**\r\n\r\n## spring的启动流程\r\n1.启动web项目后，web容器首先回去找web.xml文件，读取<context-param>和<listener>两个节点。\r\n\r\n2.其中<context-param>节点中是contextConfigLocation初始化上下文，<listener>节点加载配置文件，其中调用的spring包中的`ContextLoaderListener`这个上下文监听器，`ContextLoaderListener`是一个实现了`ServletContextListener`接口的监听器，他的父类是  `ContextLoader`，在启动项目时会触发`contextInitialized`上下文初始化方法。这个方法又调用了父类`ContextLoader`的`initWebApplicationContext(event.getServletContext())`方法。该方法主要做了三件事：\r\n创建了WebApplicationContext，加载对应的spring配置文件中的Bean，将WebApplicationContext放入ServletContext（Java Web的全局变量）中。\r\n\r\n3.如果配置了springmvc，则会创建SpringMVC容器实例。调用web.xml中配置的servlet-class，为其初始化自己的上下文信息，并加载其设置的配置信息到该上下文中。将WebApplicationContext设置为它的父容器。\r\n\r\n**总结来说如下图所示**\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_220428_983.JPG)\r\n\r\n**2020-03-17 22:07:02 星期二**', '2020-03-17 22:13:01', 'tomcat启动，servlet容器随之启动，读取service.xml配置文件，启动里面配置的web应用，为每个应用创建一个ServletContext（全局上下文环境），接着创建Spring容器、SpringMVC容器。\r\n本文将简述Web容器、Servlet容器、Spring容器、SpringMVC容器之间的关系，以及spring的启动流程', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_221225_32.jpg', '原创', 0, b'1', b'0', 'Spring的启动流程以及各种容器之间的关系', '2020-03-17 22:20:49', 17, 58, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (162, b'0', b'1', '## 前言\r\n排序算法在算法中很常见,是数据处理中十分常见且核心的操作，也是最经典的算法之一。所以本文基本排序算法进行了整理。\r\n\r\n## 选择排序\r\n选择排序是最简单直观的一种算法，基本思想为每一趟从待排序的数据元素中选择最小（或最大）的一个元素作为首元素，直到所有元素排完为止，简单选择排序是不稳定排序。\r\n\r\n### **原理：**\r\n(1) 从未排序序列中选出最小(或大)元素 , 存放在序列起始位置 , 作为已排序序列。\r\n\r\n(2) 从未排序序列中选出最小(或大)元素 , 存放在已排序序列的末尾。\r\n\r\n(3) 重复(2)直到未排序序列元素个数为零。\r\n\r\n### **代码实现**\r\n```java\r\npublic static void selectSort(int[] arr) {\r\n	for (int i = 0; i < arr.length - 1; i++) {\r\n		int min = i;\r\n		for (int j = i + 1; j < arr.length; j++) {\r\n			if (arr[j] < arr[min]) {\r\n				min = j;\r\n			}\r\n		}\r\n		if (min != i) {\r\n			swap(arr,min,i);\r\n		}\r\n	}\r\n}\r\n```\r\n\r\n### **时间复杂度和稳定性**\r\n**时间复杂度:O(N2)**\r\n**算法稳定性:不稳定**\r\n\r\n对于比较操作，无论原始数组如何排布，比较次数是不变的。\r\n\r\n对于交换操作，在最理想的情况下也就是数据本身有序，无需任何交换移动。在最差情况下，数组倒序的时候，交换次数为n-1次\r\n\r\n## 冒泡排序法\r\n### **原理：**\r\n冒泡排序法每一轮排序都是在比较相邻的元素 , 若前一个元素比后一个元素大 , 就交换两个元素 , 反之不变。\r\n在冒泡排序中，如果外循环一次没有进行过交换操作，则说明数组已经完全有序。此时只要跳出循环即可\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200319_132124_604.png)\r\n\r\n### **代码实现：**\r\n```java\r\npublic static void bubbleSort(int[] arr) {\r\n	for(int i = 0; i < arr.length; i++){\r\n		boolean flag = true;\r\n		for(int j = 0;j < arr.length-1-i;j++){\r\n			if(arr[j] > arr[j+1]){\r\n				swap(arr, j, j+1);\r\n				flag = false;\r\n			}\r\n		}\r\n		if(flag){\r\n			break;\r\n		}\r\n	}\r\n}\r\n```\r\n### **时间复杂度和稳定性**\r\n**时间复杂度:O(N2)**\r\n\r\n在最理想的情况下，即数组本身有序，仅需n-1次比较就可完成；\r\n但如果是倒序，遍历次数是 (n-1)+(n-2)+…+2+1 = n*(n-1)/2 = 0.5*n2-0.5*n，所以时间复杂度是O(N2)。\r\n\r\n**算法稳定性:稳定**\r\n\r\n在比较arr[j]和arr[j+1]时 , 可以不交换两个值 , 排完序的元素相对顺序不会变化 , 所以冒泡排序是稳定的\r\n\r\n## 插入排序\r\n### **原理：**\r\n把待排序的记录按照元素大小逐个插入到一个已经排好序的有序序列中 , 直到所有的记录插入完位置 , 得到一个新的有序序列。\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200319_134115_224.png)\r\n\r\n### **代码实现：**\r\n```java\r\npublic static void insertionSort(int[] arr) {\r\n	for(int i = 0; i < arr.length; i++){\r\n		int j = i;\r\n		// while循环做的事就是将要插入的数字与部分排好序的数据逐一比较，直到找到合适的位置\r\n		while(j > 0 && arr[j] < arr[j - 1]){\r\n			swap(arr, j, j-1);\r\n			j--;\r\n		}\r\n	}\r\n}\r\n```\r\n### **时间复杂度和稳定性**\r\n**时间复杂度: 最佳情况O(N) , 最差情况O(N2)**\r\n\r\n(1) 当初始序列为正序时，只需要外循环N-1次，每次进行一次比较，无需移动元素。\r\n此时时间复杂度为O(N)。\r\n\r\n(2) 当初始序列为反序时，需要外循环N-1次，每次排序中待插入的元素都要和[0,i-1]中的i个元素进行比较且要将这i个元素后移i次，如果使用了tmp，加上tmp=arr[i]与arr[j]=temp的两次移动，每趟移动次数为i+2,此时比较次数和移动次数达到最大值。\r\n\r\n= 1+2+…+(n-1) = n(n-1)/2\r\n= (1+2）+ （2+2）+…+（n-1+2）=（n-1）(n+4)/2\r\n\r\n此时时间复杂度O(N2)。\r\n\r\n**算法稳定性:稳定**\r\n\r\n相等元素的前后顺序没有改变 ，从原无序序列出去的顺序就是排好序后的顺序 ，所以插入排序是稳定的。\r\n\r\n## 希尔排序\r\n## 快速排序\r\n## 归并排序\r\n## 堆排序\r\n\r\n**2020-03-19 14:09:23 星期四**\r\n\r\n**未完待续...**', '2020-03-19 14:11:10', '排序算法在算法中很常见,是数据处理中十分常见且核心的操作，也是最经典的算法之一。所以本文基本排序算法进行了整理', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200.jpg', '原创', 0, b'1', b'0', '排序算法', '2020-03-19 14:12:59', 10, 59, 2, 0, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (163, b'0', b'1', '## 一、基本介绍\r\n1.建造者模式(Builder Pattern)又叫生成器模式,是一种对象构建模式。它可以将复杂对象的建造过程抽象出来,是这个抽象过程的不同实现方法可以构造出不同表现的对象\r\n\r\n2.构造这模式是一步一步创建一个复杂的对象,它允许用户只通过指定复杂对象的类别和内容就可以构建它们,用户不需要知道内部的具体构建细节\r\n## 二、角色\r\n### 1. Product\r\n产品角色,一个具体产品对象\r\n\r\n### 2. Builder\r\n抽象建造者,创建一个Product对象的各个部件指定的接口\r\n\r\n### 3. ConcreteBuilder\r\n具体建造者,实现接口,构造和装配各个部件\r\n\r\n### 4. Director\r\n指挥者,构建一个使用Builder接口的对象,它主要是用于创建一个复杂的对象。它主要有两个作用,一是:隔离了客户与对象生产的过程,二是:负责控制产品对象的生产过程\r\n\r\n## 三、类图\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200320_121218_136.png)\r\n\r\n## 四、例子\r\n**造房子:**\r\n建房子的流程大概是 打地基 - 砌墙 - 盖顶\r\n无论建小房子还是高楼都是这个顺序,故我们采用建造者模式\r\n\r\n**类图：**\r\n\r\n![](https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200320_121218_354.png)\r\n\r\n**代码实现：**\r\n1.Product\r\n```java\r\npublic class House {\r\n    private String baise;\r\n    private String wall;\r\n    private String roofed;\r\n}\r\n```\r\n2.Builder\r\n```java\r\npublic abstract class HouseBuilder {\r\n    protected House house = new House();\r\n    //将建造流程写好,抽象的方法\r\n    public abstract void buildBasic();\r\n    public abstract void buildWalls();\r\n    public abstract void roofed();\r\n    //建造房子\r\n    public House buildHouse(){\r\n        return house;\r\n    }\r\n}\r\n```\r\n3.ConcreteBuilder\r\n```java\r\n// 高楼建造子类\r\npublic class HighBuilding extends HouseBuilder{\r\n    @Override\r\n    public void buildBasic() {\r\n        System.out.println(\"高楼打地基100米\");\r\n    }\r\n    @Override\r\n    public void buildWalls() {\r\n        System.out.println(\"高楼砌墙150米\");\r\n    }\r\n    @Override\r\n    public void roofed() {\r\n        System.out.println(\"高楼屋顶盖好\");\r\n    }\r\n}\r\n\r\n// 平房建造子类\r\npublic class CommonHouse extends HouseBuilder {\r\n    @Override\r\n    public void buildBasic() {\r\n        System.out.println(\"普通房子打地基5米\");\r\n    }\r\n    @Override\r\n    public void buildWalls() {\r\n        System.out.println(\"普通房子砌墙3米\");\r\n    }\r\n    @Override\r\n    public void roofed() {\r\n        System.out.println(\"普通房子屋顶盖好\");\r\n    }\r\n}\r\n```\r\n4.Director\r\n```java\r\n// 指挥者,指定制作流程,返回产品\r\npublic class HouseDirector {\r\n    HouseBuilder houseBuilder = null;\r\n    public HouseDirector(HouseBuilder houseBuilder) {\r\n        this.houseBuilder = houseBuilder;\r\n    }\r\n    public void setHouseBuilder(HouseBuilder houseBuilder) {\r\n        this.houseBuilder = houseBuilder;\r\n    }\r\n    //如何处理建造房子的流程,交给指挥者\r\n    public House constructHouse(){\r\n        houseBuilder.buildBasic();\r\n        houseBuilder.buildWalls();\r\n        houseBuilder.roofed();\r\n        return houseBuilder.buildHouse();\r\n    }\r\n}\r\n```\r\n5.主类\r\n```java\r\npublic class Client {\r\n    public static void main(String[] args) {\r\n        //盖普通房子\r\n        CommonHouse commonHouse = new CommonHouse();\r\n        //创建指挥者\r\n        HouseDirector houseDirector = new HouseDirector(commonHouse);\r\n        //完成盖房子\r\n        House house = houseDirector.constructHouse();\r\n\r\n        //盖高楼\r\n        HighBuilding highBuilding = new HighBuilding();\r\n        //重置建造者\r\n        houseDirector.setHouseBuilder(highBuilding);\r\n        //完成盖高楼\r\n        House hightHouse = houseDirector.constructHouse();\r\n    }\r\n}\r\n```\r\n## 总结\r\n### 优点：\r\n1.客户端不必知道产品内部组成细节,将产品本身与产品的创建过程解耦,使得相同的创建过程可以创建不同的产品对象\r\n\r\n2.用户使用不同的具体建造者即可得到不同的产品对象\r\n\r\n3.可以更精细地控制产品地创建过程\r\n\r\n4.增加新的具体建造者无需修改原有类库地代码,符合OCP原则\r\n\r\n### 缺点：\r\n1.若产品间差异性很大,则不适合使用建造者模式,而房子地建造步骤基本一致\r\n\r\n2.若产品地内部变化复杂,要考虑这种情况并权衡是否选择建造者模式\r\n\r\n## 对比抽象工厂模式\r\n抽象工厂模式实现堆产品家族地创建,一个产品家族是这样一系列产品:具有不同分类维度地产品组合,采用抽象工厂模式不需要关心构建过程,只关心什么产品由什么工厂生产即可\r\n\r\n建造者模式则是要求按照指定蓝图构建产品,它的主要目的是通过组装零配件而产生一个新产品\r\n\r\n**2020-03-20 12:19:13 星期五**', '2020-03-20 12:20:17', '建造者模式(Builder Pattern)又叫生成器模式,是一种对象构建模式。它可以将复杂对象的建造过程抽象出来,是这个抽象过程的不同实现方法可以构造出不同表现的对象', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200314_120536_200.jpg', '原创', 0, b'1', b'0', '构建者模式', '2020-03-20 12:21:10', 24, 57, 2, 1, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (164, b'0', b'1', '## 一、框架机制\r\n1、Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现,SpringMVC（DispatcherServlet）则采用Servlet实现。\r\n\r\n2、Filter在容器启动之后即初始化；服务停止以后坠毁，晚于Servlet。Servlet在是在调用时初始化，先于Filter调用，服务停止后销毁。\r\n\r\n## 二、拦截机制\r\n**struts:**\r\n\r\n1.Struts2框架是类级别的拦截，每次请求就会创建一个Action\r\n\r\n2.一个Action对应一个request，response\r\n\r\n3.Action的一个方法可以对应一个url，而其类属性却被所有方法共享\r\n\r\n**springmvc:**\r\n\r\n1.SpringMVC是方法级别的拦截，一个方法对应一个Request上下文\r\n\r\n2.SpringMVC的Controller Bean默认单例模式Singleton，所以默认对所有的请求，只会创建一个Controller，又因为没有共享的属性，所以是线程安全的，如果要改变默认的作用域，需要添加@Scope注解修改。\r\n\r\n## 三、性能方面\r\nSpringMVC基于方法的拦截，有加载一次单例模式bean注入。而Struts2是类级别的拦截，每次请求对应实例一个新的Action，需要加载所有的属性值注入，所以，SpringMVC开发效率和性能高于Struts2。\r\n\r\n## 附：\r\n### 拦截器（Interceptor）和过滤器（Filter）的执行顺序和区别\r\n\r\n#### 过滤器(Filter)：\r\n\r\n**因为Filter需要在web.xml中配置，所以依赖于servlet容器。至于为什么在实现上基于函数回调。**\r\n\r\n因为从Filter的 doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) 这个方法中可以看到，FilterChain作为一个参数传递了进来，\r\n当前的字符过滤Filter将字符编码设置好后，调用了FilterChain的 filterChain.doFilter(servletRequest, servletResponse); 让FilterChain去找下一个Filter进行新的处理，如果没有下一个Filter了，就直接放行，访问servlet获取资源。这就是典型的一个函数回调，Filter就相当于类A，FilterChain就相当于类B，类A调用类B。\r\n\r\n**Filter可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。**\r\n\r\n通过使用Filter，我们可以用来做一些过滤操作，获取我们想要获取的数据。比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。通常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。\r\n\r\n#### 拦截器（Interceptor）：\r\n\r\n**因为Interceptor需要在SpringMVC中配置，所以依赖于web框架。在实现上,基于Java的反射机制。**\r\n\r\n拦截器可以在方法执行前后进行其他操作，属于面向切面编程（AOP）的一种运用\r\n\r\n由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。**但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。**\r\n\r\n#### Filter的执行顺序在Interceptor之前\r\n\r\n\r\n\r\n------------\r\n\r\n\r\n\r\n\r\n**2020-03-20 22:15:02 星期五**', '2020-03-20 22:21:10', 'Struts2采用Filter（StrutsPrepareAndExecuteFilter）实现,SpringMVC（DispatcherServlet）则采用Servlet实现', 'https://islizx.oss-cn-hangzhou.aliyuncs.com/images/2020/3/20200317_221225_32.jpg', '原创', 0, b'1', b'0', 'Struts2和SpringMVC的区别', '2020-03-20 22:24:49', 44, 60, 2, 1, 0, 0, NULL);
INSERT INTO `t_blog` VALUES (165, b'1', b'1', 'test', '2020-04-24 19:56:03', 'test', 'aaaa', '原创', 2, b'1', b'0', 'test1', '2020-04-24 19:56:38', 2, 53, 2, 1, 1, 0, NULL);
INSERT INTO `t_blog` VALUES (167, b'0', b'0', 'test', '2020-04-24 19:58:19', NULL, NULL, NULL, 2, b'0', b'0', 'test', '2020-04-24 19:58:19', 1, NULL, 2, 0, 0, 1, NULL);

-- ----------------------------
-- Table structure for t_blog_t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_t_tag`;
CREATE TABLE `t_blog_t_tag`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `blogs_id` bigint NOT NULL COMMENT '博客id',
  `tags_id` bigint NOT NULL COMMENT '标签id',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKhl5bn19gf2sq5o31s7amn0l1t`(`tags_id`) USING BTREE,
  INDEX `FKk1nf67s05jh2pbvf45gmhvhja`(`blogs_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_blog_t_tag
-- ----------------------------
INSERT INTO `t_blog_t_tag` VALUES (1, 149, 30);
INSERT INTO `t_blog_t_tag` VALUES (2, 149, 31);
INSERT INTO `t_blog_t_tag` VALUES (3, 153, 32);
INSERT INTO `t_blog_t_tag` VALUES (4, 153, 33);
INSERT INTO `t_blog_t_tag` VALUES (5, 154, 34);
INSERT INTO `t_blog_t_tag` VALUES (6, 154, 35);
INSERT INTO `t_blog_t_tag` VALUES (7, 157, 34);
INSERT INTO `t_blog_t_tag` VALUES (8, 155, 32);
INSERT INTO `t_blog_t_tag` VALUES (9, 155, 33);
INSERT INTO `t_blog_t_tag` VALUES (10, 161, 36);
INSERT INTO `t_blog_t_tag` VALUES (11, 162, 37);
INSERT INTO `t_blog_t_tag` VALUES (12, 164, 38);
INSERT INTO `t_blog_t_tag` VALUES (13, 164, 39);
INSERT INTO `t_blog_t_tag` VALUES (14, 165, 31);
INSERT INTO `t_blog_t_tag` VALUES (15, 165, 33);

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '内容',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '邮箱',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `blog_id` bigint NULL DEFAULT NULL COMMENT '博客id',
  `ip` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'ip',
  `pass` int NULL DEFAULT 0 COMMENT '0:审核中1:成功2:失败',
  `admin_comment` bit(1) NOT NULL DEFAULT b'0' COMMENT '作者是否回复',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `parent_comment_id` bigint NULL DEFAULT NULL COMMENT '上一级评论',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `FKke3uogd04j4jx316m1p51e05u`(`blog_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES (1, '/images/otherUserAvatar.jpg', '.klk;kl;', '26@qq.com', 'shmily', 163, '182.110.30.58', 1, b'0', '2020-04-11 12:35:24', -1);
INSERT INTO `t_comment` VALUES (2, '/images/otherUserAvatar.jpg', '的深V', '2681561311@qq.com', 'shmily', 164, '182.109.236.245', 1, b'0', '2020-04-14 08:55:42', -1);
INSERT INTO `t_comment` VALUES (3, '/images/islizx.jpg', 'test', 'islizx@163.com', 'RAYMOND', 165, '0:0:0:0:0:0:0:1', 1, b'1', '2020-04-24 19:56:23', -1);
INSERT INTO `t_comment` VALUES (4, '/images/otherUserAvatar.jpg', '111', '111@1.com', '1', 164, '0:0:0:0:0:0:0:1', 0, b'0', '2022-06-27 15:33:29', -1);

-- ----------------------------
-- Table structure for t_friendship
-- ----------------------------
DROP TABLE IF EXISTS `t_friendship`;
CREATE TABLE `t_friendship`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` bigint NOT NULL COMMENT '用户id',
  `friend_id` bigint NOT NULL COMMENT '好友id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_friendship
-- ----------------------------

-- ----------------------------
-- Table structure for t_history
-- ----------------------------
DROP TABLE IF EXISTS `t_history`;
CREATE TABLE `t_history`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` bigint NULL DEFAULT NULL COMMENT '用户id',
  `visitor_id` bigint NULL DEFAULT NULL COMMENT '访客id',
  `visitTime` datetime NULL DEFAULT NULL COMMENT '访问时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_history
-- ----------------------------

-- ----------------------------
-- Table structure for t_notice
-- ----------------------------
DROP TABLE IF EXISTS `t_notice`;
CREATE TABLE `t_notice`  (
  `id` int NOT NULL AUTO_INCREMENT,
  `sender` bigint NOT NULL COMMENT '发送者',
  `receiver` bigint NOT NULL COMMENT '接受者',
  `status` bit(1) NOT NULL COMMENT '是否已读',
  `sendtime` datetime NOT NULL COMMENT '发送时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_notice
-- ----------------------------

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标签名称',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 40 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES (30, 'TCP', '');
INSERT INTO `t_tag` VALUES (31, 'UDP', '');
INSERT INTO `t_tag` VALUES (32, '个人网站', '');
INSERT INTO `t_tag` VALUES (33, 'SSM', '');
INSERT INTO `t_tag` VALUES (34, 'MYSQL', '');
INSERT INTO `t_tag` VALUES (35, '备份', '');
INSERT INTO `t_tag` VALUES (36, '容器', '');
INSERT INTO `t_tag` VALUES (37, '排序', '');
INSERT INTO `t_tag` VALUES (38, 'Spring', '');
INSERT INTO `t_tag` VALUES (39, 'Struts', '');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '类别名称',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  `icon` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图标',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 61 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES (53, '计算机网络', '', '');
INSERT INTO `t_type` VALUES (54, 'Java', '', '');
INSERT INTO `t_type` VALUES (55, '数据库', '', '');
INSERT INTO `t_type` VALUES (56, '面试', '', '');
INSERT INTO `t_type` VALUES (57, '设计模式', '', '');
INSERT INTO `t_type` VALUES (58, 'Spring', '', '');
INSERT INTO `t_type` VALUES (59, '数据结构与算法', '', '');
INSERT INTO `t_type` VALUES (60, 'Java架构', '', '');

-- ----------------------------
-- Table structure for t_user
-- ----------------------------
DROP TABLE IF EXISTS `t_user`;
CREATE TABLE `t_user`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '邮箱',
  `nickname` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '昵称',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '密码',
  `type` bit(1) NULL DEFAULT b'0' COMMENT '类型',
  `username` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '用户名',
  `url` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '首页',
  `last_login_ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '上次登录ip',
  `register_time` datetime NULL DEFAULT NULL COMMENT '注册时间',
  `last_login_time` datetime NULL DEFAULT NULL COMMENT '上次登录时间',
  `status` bit(1) NOT NULL DEFAULT b'0' COMMENT '状态',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `username`(`username`) USING BTREE,
  UNIQUE INDEX `email`(`email`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of t_user
-- ----------------------------
INSERT INTO `t_user` VALUES (2, '/images/islizx.jpg', 'islizx@163.com', 'RAYMOND', '96e79218965eb72c92a549dd5a330112', b'1', 'admin', 'hello', '127.0.0.1', '2020-02-04 11:42:36', '2022-06-30 15:20:24', b'0', '2020-05-08 15:02:23', 'hello ');

SET FOREIGN_KEY_CHECKS = 1;
